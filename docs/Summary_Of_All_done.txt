This is the text file that summariwe everyting being done about the project PME_TPE


Edge Functions (Supabase)
=============================================================================================

create_business

// supabase/functions/create_business/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const supabaseUrl = Deno.env.get("PROJECT_URL");
const anonKey = Deno.env.get("PROJECT_ANON_KEY");
const serviceKey = Deno.env.get("SERVICE_ROLE_KEY");

if (!supabaseUrl || !anonKey || !serviceKey) {
  throw new Error("Missing env: PROJECT_URL / PROJECT_ANON_KEY / SERVICE_ROLE_KEY");
}

const admin = createClient(supabaseUrl, serviceKey, {
  auth: { persistSession: false },
});

function json(status: number, body: unknown) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

serve(async (req) => {
  // CORS (au cas où tu testes depuis navigateur)
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 204,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "authorization, apikey, content-type",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
      },
    });
  }

  if (req.method !== "POST") {
    return json(405, { error: "Method not allowed" });
  }

  try {
    const authHeader = req.headers.get("Authorization") ?? "";
    if (!authHeader.toLowerCase().startsWith("bearer ")) {
      return json(401, { error: "Missing Authorization Bearer token" });
    }

    // Client "user" pour valider le JWT via Supabase Auth
    const userClient = createClient(supabaseUrl, anonKey, {
      auth: { persistSession: false },
      global: { headers: { Authorization: authHeader } },
    });

    const { data: userData, error: userErr } = await userClient.auth.getUser();
    if (userErr || !userData.user) {
      return json(401, { error: "Unauthorized" });
    }
    const user = userData.user;

    const body = await req.json().catch(() => null);
    if (!body || typeof body !== "object") {
      return json(400, { error: "Invalid JSON body" });
    }

    const b = body as Record<string, unknown>;

    const name = String(b.name ?? "").trim();
    const slug = String(b.slug ?? "").trim();

    if (!name) return json(400, { error: "name is required" });
    if (!slug) return json(400, { error: "slug is required" });

    const description = (b.description ?? null) as string | null;
    const whatsapp_phone = (b.whatsapp_phone ?? null) as string | null;
    const address_text = (b.address_text ?? null) as string | null;

    const lat = (b.lat ?? null) as number | null;
    const lng = (b.lng ?? null) as number | null;

    const location =
      (lat !== null && lng !== null) ? `SRID=4326;POINT(${lng} ${lat})` : null;

    const { data: biz, error: bizErr } = await admin
      .from("businesses")
      .insert({
        name,
        slug,
        description,
        whatsapp_phone,
        address_text,
        location,
        created_by: user.id,
      })
      .select("id")
      .single();

    if (bizErr) {
      return json(400, { error: bizErr.message });
    }

    await admin.from("business_members").insert({
      business_id: biz.id,
      user_id: user.id,
      role: "owner",
    });

    const { data: plan, error: planErr } = await admin
      .from("plans")
      .select("id")
      .eq("code", "free")
      .single();

    if (planErr || !plan) {
      return json(500, { error: "Free plan not found" });
    }

    await admin.from("entitlements").insert({
      business_id: biz.id,
      plan_id: plan.id,
      visibility_multiplier: 1.0,
      can_receive_orders: false,
      can_run_ads: false,
    });

    return json(200, { business_id: biz.id });
  } catch (e) {
    return json(500, { error: String(e) });
  }
});

=============================================================================================
send_push

// supabase/functions/send_push/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

import { create, getNumericDate } from "https://deno.land/x/djwt@v2.9/mod.ts";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

const FIREBASE_PROJECT_ID = Deno.env.get("FIREBASE_PROJECT_ID")!;
const FIREBASE_CLIENT_EMAIL = Deno.env.get("FIREBASE_CLIENT_EMAIL")!;
const FIREBASE_PRIVATE_KEY = Deno.env.get("FIREBASE_PRIVATE_KEY")!;

function pemToArrayBuffer(pem: string): ArrayBuffer {
  const b64 = pem
    .replaceAll("-----BEGIN PRIVATE KEY-----", "")
    .replaceAll("-----END PRIVATE KEY-----", "")
    .replaceAll("\n", "")
    .trim();
  const raw = atob(b64);
  const bytes = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
  return bytes.buffer;
}

async function getGoogleAccessToken(): Promise<string> {
  // OAuth token endpoint
  const tokenUrl = "https://oauth2.googleapis.com/token";

  // Import private key for djwt
  const keyData = pemToArrayBuffer(FIREBASE_PRIVATE_KEY);
  const cryptoKey = await crypto.subtle.importKey(
    "pkcs8",
    keyData,
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const now = Math.floor(Date.now() / 1000);
  const jwt = await create(
    { alg: "RS256", typ: "JWT" },
    {
      iss: FIREBASE_CLIENT_EMAIL,
      sub: FIREBASE_CLIENT_EMAIL,
      aud: tokenUrl,
      iat: getNumericDate(now),
      exp: getNumericDate(now + 3600),
      scope: "https://www.googleapis.com/auth/firebase.messaging",
    },
    cryptoKey,
  );

  const body = new URLSearchParams({
    grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
    assertion: jwt,
  });

  const resp = await fetch(tokenUrl, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body,
  });

  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`OAuth token error: ${resp.status} ${txt}`);
  }

  const json = await resp.json();
  return json.access_token as string;
}

async function sendFcmMessage(accessToken: string, token: string, title: string, body: string, data: Record<string, string>) {
  const url = `https://fcm.googleapis.com/v1/projects/${FIREBASE_PROJECT_ID}/messages:send`;

  const payload = {
    message: {
      token,
      notification: { title, body },
      data,
      android: {
        priority: "HIGH",
      },
    },
  };

  const resp = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });

  const text = await resp.text();
  if (!resp.ok) {
    throw new Error(`FCM error: ${resp.status} ${text}`);
  }
  return text;
}

serve(async (_req) => {
  const sb = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

  // 1) prendre un batch de notifications queued
  const { data: notifs, error: nErr } = await sb
    .from("notifications")
    .select("id,user_id,business_id,title,body,data,deep_link")
    .eq("status", "queued")
    .order("created_at", { ascending: true })
    .limit(50);

  if (nErr) return new Response(`DB error: ${nErr.message}`, { status: 500 });
  if (!notifs || notifs.length === 0) return new Response("OK: nothing to send");

  // 2) token google (une fois)
  let accessToken: string;
  try {
    accessToken = await getGoogleAccessToken();
  } catch (e) {
    return new Response(`OAuth error: ${String(e)}`, { status: 500 });
  }

  for (const n of notifs) {
    // prefs push ?
    const { data: pref } = await sb
      .from("notification_preferences")
      .select("push_enabled")
      .eq("user_id", n.user_id)
      .maybeSingle();

    if (pref && pref.push_enabled === false) {
      await sb.from("notifications").update({ status: "sent", sent_at: new Date().toISOString() }).eq("id", n.id);
      continue;
    }

    // tokens actifs
    const { data: tokens } = await sb
      .from("device_tokens")
      .select("id,token,revoked_at")
      .eq("user_id", n.user_id)
      .is("revoked_at", null);

    if (!tokens || tokens.length === 0) {
      await sb.from("notifications").update({ status: "failed" }).eq("id", n.id);
      await sb.from("notification_deliveries").insert({
        notification_id: n.id,
        channel: "push",
        provider: "fcm",
        ok: false,
        error: "no_device_tokens",
      });
      continue;
    }

    let anyOk = false;

    for (const t of tokens) {
      try {
        await sendFcmMessage(
          accessToken,
          t.token,
          n.title,
          n.body,
          {
            notification_id: n.id,
            deep_link: n.deep_link ?? "",
            type: (n.data?.type ?? "") as string, // optionnel
          },
        );

        anyOk = true;

        await sb.from("notification_deliveries").insert({
          notification_id: n.id,
          channel: "push",
          provider: "fcm",
          ok: true,
        });
      } catch (e) {
        // si token invalide -> on révoque
        const msg = String(e);
        if (msg.includes("UNREGISTERED") || msg.includes("NotRegistered") || msg.includes("registration-token-not-registered")) {
          await sb.from("device_tokens").update({ revoked_at: new Date().toISOString() }).eq("id", t.id);
        }

        await sb.from("notification_deliveries").insert({
          notification_id: n.id,
          channel: "push",
          provider: "fcm",
          ok: false,
          error: msg.slice(0, 800),
        });
      }
    }

    await sb.from("notifications").update({
      status: anyOk ? "sent" : "failed",
      sent_at: anyOk ? new Date().toISOString() : null,
    }).eq("id", n.id);
  }

  return new Response("OK");
});

=============================================================================================
Database sql

CREATE TABLE public.ad_campaigns (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  objective USER-DEFINED NOT NULL,
  status USER-DEFINED NOT NULL DEFAULT 'draft'::campaign_status,
  daily_budget numeric NOT NULL DEFAULT 0,
  currency text NOT NULL DEFAULT 'XOF'::text,
  start_at timestamp with time zone,
  end_at timestamp with time zone,
  target_category_id uuid,
  target_radius_km integer,
  target_center USER-DEFINED,
  post_id uuid,
  product_id uuid,
  headline text,
  call_to_action text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT ad_campaigns_pkey PRIMARY KEY (id),
  CONSTRAINT ad_campaigns_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT ad_campaigns_target_category_id_fkey FOREIGN KEY (target_category_id) REFERENCES public.categories(id),
  CONSTRAINT ad_campaigns_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id),
  CONSTRAINT ad_campaigns_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id)
);
CREATE TABLE public.ad_stats_daily (
  campaign_id uuid NOT NULL,
  day date NOT NULL,
  impressions integer NOT NULL DEFAULT 0,
  clicks integer NOT NULL DEFAULT 0,
  spend numeric NOT NULL DEFAULT 0,
  CONSTRAINT ad_stats_daily_pkey PRIMARY KEY (campaign_id, day),
  CONSTRAINT ad_stats_daily_campaign_id_fkey FOREIGN KEY (campaign_id) REFERENCES public.ad_campaigns(id)
);
CREATE TABLE public.audit_logs (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  actor_user_id uuid,
  action text NOT NULL,
  entity_type text NOT NULL,
  entity_id uuid,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT audit_logs_pkey PRIMARY KEY (id),
  CONSTRAINT audit_logs_actor_user_id_fkey FOREIGN KEY (actor_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.business_categories (
  business_id uuid NOT NULL,
  category_id uuid NOT NULL,
  CONSTRAINT business_categories_pkey PRIMARY KEY (business_id, category_id),
  CONSTRAINT business_categories_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT business_categories_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id)
);
CREATE TABLE public.business_domains (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  domain text NOT NULL CHECK (length(TRIM(BOTH FROM domain)) > 0),
  status USER-DEFINED NOT NULL DEFAULT 'pending'::domain_verification_status,
  verification_token text DEFAULT encode(gen_random_bytes(16), 'hex'::text),
  verified_at timestamp with time zone,
  last_checked_at timestamp with time zone,
  dns_details jsonb NOT NULL DEFAULT '{}'::jsonb,
  ssl_details jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  ssl_status text CHECK (ssl_status = ANY (ARRAY['pending'::text, 'issued'::text, 'failed'::text])),
  CONSTRAINT business_domains_pkey PRIMARY KEY (id),
  CONSTRAINT business_domains_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id)
);
CREATE TABLE public.business_hours (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  day_of_week smallint NOT NULL CHECK (day_of_week >= 1 AND day_of_week <= 7),
  is_closed boolean NOT NULL DEFAULT false,
  open_time time without time zone,
  close_time time without time zone,
  timezone text NOT NULL DEFAULT 'Africa/Lome'::text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  opens_at time without time zone,
  closes_at time without time zone,
  CONSTRAINT business_hours_pkey PRIMARY KEY (id),
  CONSTRAINT business_hours_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id)
);
CREATE TABLE public.business_members (
  business_id uuid NOT NULL,
  user_id uuid NOT NULL,
  role USER-DEFINED NOT NULL DEFAULT 'staff'::member_role,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT business_members_pkey PRIMARY KEY (business_id, user_id),
  CONSTRAINT business_members_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT business_members_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.business_social_links (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  platform USER-DEFINED NOT NULL,
  url text NOT NULL CHECK (length(TRIM(BOTH FROM url)) > 0),
  label text,
  sort_order integer NOT NULL DEFAULT 0,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT business_social_links_pkey PRIMARY KEY (id),
  CONSTRAINT business_social_links_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id)
);
CREATE TABLE public.businesses (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  description text,
  logo_path text,
  cover_path text,
  whatsapp_phone text,
  address_text text,
  location USER-DEFINED,
  is_active boolean NOT NULL DEFAULT true,
  is_verified boolean NOT NULL DEFAULT false,
  created_by uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT businesses_pkey PRIMARY KEY (id),
  CONSTRAINT businesses_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.categories (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL UNIQUE,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT categories_pkey PRIMARY KEY (id)
);
CREATE TABLE public.device_tokens (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  token text NOT NULL UNIQUE,
  platform text NOT NULL CHECK (platform = ANY (ARRAY['android'::text, 'ios'::text, 'web'::text, 'windows'::text, 'macos'::text, 'linux'::text])),
  app_id text,
  app_version text,
  device_id text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  last_seen_at timestamp with time zone,
  revoked_at timestamp with time zone,
  CONSTRAINT device_tokens_pkey PRIMARY KEY (id),
  CONSTRAINT device_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.entitlements (
  business_id uuid NOT NULL,
  plan_id uuid NOT NULL,
  visibility_multiplier numeric NOT NULL DEFAULT 1.00,
  can_receive_orders boolean NOT NULL DEFAULT false,
  can_run_ads boolean NOT NULL DEFAULT false,
  monthly_order_limit integer,
  monthly_ad_budget_limit numeric,
  boosted_until timestamp with time zone,
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT entitlements_pkey PRIMARY KEY (business_id),
  CONSTRAINT entitlements_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT entitlements_plan_id_fkey FOREIGN KEY (plan_id) REFERENCES public.plans(id)
);
CREATE TABLE public.inventory_movements (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  variant_id uuid NOT NULL,
  delta_qty integer NOT NULL CHECK (delta_qty <> 0),
  reason text,
  ref_type text,
  ref_id uuid,
  created_by uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT inventory_movements_pkey PRIMARY KEY (id),
  CONSTRAINT inventory_movements_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES public.product_variants(id),
  CONSTRAINT inventory_movements_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.invoice_items (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  invoice_id uuid NOT NULL,
  product_id uuid,
  title text NOT NULL,
  description text,
  qty integer NOT NULL DEFAULT 1 CHECK (qty > 0),
  unit_price numeric NOT NULL DEFAULT 0 CHECK (unit_price >= 0::numeric),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT invoice_items_pkey PRIMARY KEY (id),
  CONSTRAINT invoice_items_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoices(id),
  CONSTRAINT invoice_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id)
);
CREATE TABLE public.invoices (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  request_id uuid NOT NULL,
  quote_id uuid,
  customer_user_id uuid NOT NULL,
  invoice_number text,
  status USER-DEFINED NOT NULL DEFAULT 'draft'::invoice_status,
  currency text NOT NULL DEFAULT 'XOF'::text,
  subtotal numeric NOT NULL DEFAULT 0,
  tax numeric NOT NULL DEFAULT 0,
  total numeric NOT NULL DEFAULT 0,
  issued_at timestamp with time zone,
  due_at timestamp with time zone,
  paid_at timestamp with time zone,
  pdf_path text,
  created_by uuid,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT invoices_pkey PRIMARY KEY (id),
  CONSTRAINT invoices_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT invoices_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT invoices_quote_id_fkey FOREIGN KEY (quote_id) REFERENCES public.quotes(id),
  CONSTRAINT invoices_customer_user_id_fkey FOREIGN KEY (customer_user_id) REFERENCES auth.users(id),
  CONSTRAINT invoices_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.notification_deliveries (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  notification_id uuid NOT NULL,
  channel USER-DEFINED NOT NULL,
  provider text NOT NULL,
  provider_message_id text,
  ok boolean NOT NULL DEFAULT false,
  error text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT notification_deliveries_pkey PRIMARY KEY (id),
  CONSTRAINT notification_deliveries_notification_id_fkey FOREIGN KEY (notification_id) REFERENCES public.notifications(id)
);
CREATE TABLE public.notification_preferences (
  user_id uuid NOT NULL,
  push_enabled boolean NOT NULL DEFAULT true,
  email_enabled boolean NOT NULL DEFAULT true,
  sms_enabled boolean NOT NULL DEFAULT false,
  marketing_enabled boolean NOT NULL DEFAULT false,
  quiet_hours jsonb,
  categories jsonb NOT NULL DEFAULT '{}'::jsonb,
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT notification_preferences_pkey PRIMARY KEY (user_id),
  CONSTRAINT notification_preferences_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.notifications (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  business_id uuid,
  type text NOT NULL,
  title text NOT NULL,
  body text NOT NULL,
  data jsonb NOT NULL DEFAULT '{}'::jsonb,
  deep_link text,
  status USER-DEFINED NOT NULL DEFAULT 'queued'::notification_status,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  sent_at timestamp with time zone,
  read_at timestamp with time zone,
  CONSTRAINT notifications_pkey PRIMARY KEY (id),
  CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.payment_intents (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  request_id uuid,
  invoice_id uuid,
  status USER-DEFINED NOT NULL DEFAULT 'pending'::payment_intent_status,
  provider text,
  amount numeric NOT NULL DEFAULT 0,
  currency text NOT NULL DEFAULT 'XOF'::text,
  external_ref text,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_by uuid,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT payment_intents_pkey PRIMARY KEY (id),
  CONSTRAINT payment_intents_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT payment_intents_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT payment_intents_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoices(id),
  CONSTRAINT payment_intents_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.payments (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  provider USER-DEFINED NOT NULL,
  amount numeric NOT NULL,
  currency text NOT NULL DEFAULT 'XOF'::text,
  status text NOT NULL CHECK (status = ANY (ARRAY['pending'::text, 'paid'::text, 'failed'::text, 'refunded'::text])),
  external_ref text,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  payment_intent_id uuid,
  CONSTRAINT payments_pkey PRIMARY KEY (id),
  CONSTRAINT payments_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT payments_payment_intent_id_fkey FOREIGN KEY (payment_intent_id) REFERENCES public.payment_intents(id)
);
CREATE TABLE public.plans (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  code text NOT NULL UNIQUE CHECK (code = ANY (ARRAY['free'::text, 'pro'::text, 'premium'::text])),
  name text NOT NULL,
  description text,
  monthly_price_amount numeric,
  currency text DEFAULT 'XOF'::text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT plans_pkey PRIMARY KEY (id)
);
CREATE TABLE public.post_comments (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  post_id uuid NOT NULL,
  user_id uuid NOT NULL,
  parent_id uuid,
  content text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT post_comments_pkey PRIMARY KEY (id),
  CONSTRAINT post_comments_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id),
  CONSTRAINT post_comments_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id),
  CONSTRAINT post_comments_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.post_comments(id)
);
CREATE TABLE public.post_likes (
  post_id uuid NOT NULL,
  user_id uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT post_likes_pkey PRIMARY KEY (post_id, user_id),
  CONSTRAINT post_likes_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id),
  CONSTRAINT post_likes_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.post_media (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  post_id uuid NOT NULL,
  media_type text NOT NULL CHECK (media_type = ANY (ARRAY['image'::text, 'video'::text, 'pdf'::text])),
  storage_path text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT post_media_pkey PRIMARY KEY (id),
  CONSTRAINT post_media_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id)
);
CREATE TABLE public.posts (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  author_user_id uuid NOT NULL,
  title text,
  content text,
  is_published boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT posts_pkey PRIMARY KEY (id),
  CONSTRAINT posts_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT posts_author_user_id_fkey FOREIGN KEY (author_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.product_categories_map (
  product_id uuid NOT NULL,
  category_id uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT product_categories_map_pkey PRIMARY KEY (product_id, category_id),
  CONSTRAINT product_categories_map_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id),
  CONSTRAINT product_categories_map_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id)
);
CREATE TABLE public.product_media (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  product_id uuid NOT NULL,
  media_type text NOT NULL CHECK (media_type = ANY (ARRAY['image'::text, 'video'::text, 'pdf'::text])),
  storage_path text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT product_media_pkey PRIMARY KEY (id),
  CONSTRAINT product_media_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id)
);
CREATE TABLE public.product_variants (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  product_id uuid NOT NULL,
  title text,
  sku text CHECK (sku IS NULL OR length(TRIM(BOTH FROM sku)) > 0),
  attributes jsonb NOT NULL DEFAULT '{}'::jsonb,
  price_amount numeric,
  currency text DEFAULT 'XOF'::text,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  options jsonb NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT product_variants_pkey PRIMARY KEY (id),
  CONSTRAINT product_variants_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id)
);
CREATE TABLE public.products (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  title text NOT NULL,
  description text,
  price_amount numeric,
  currency text DEFAULT 'XOF'::text,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT products_pkey PRIMARY KEY (id),
  CONSTRAINT products_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id)
);
CREATE TABLE public.profiles (
  user_id uuid NOT NULL,
  display_name text,
  phone text,
  photo_url text,
  locale text DEFAULT 'fr'::text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT profiles_pkey PRIMARY KEY (user_id),
  CONSTRAINT profiles_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.quote_items (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  quote_id uuid NOT NULL,
  product_id uuid,
  title text NOT NULL,
  description text,
  qty integer NOT NULL DEFAULT 1 CHECK (qty > 0),
  unit_price numeric NOT NULL DEFAULT 0 CHECK (unit_price >= 0::numeric),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT quote_items_pkey PRIMARY KEY (id),
  CONSTRAINT quote_items_quote_id_fkey FOREIGN KEY (quote_id) REFERENCES public.quotes(id),
  CONSTRAINT quote_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id)
);
CREATE TABLE public.quotes (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  request_id uuid NOT NULL,
  customer_user_id uuid NOT NULL,
  status USER-DEFINED NOT NULL DEFAULT 'draft'::quote_status,
  currency text NOT NULL DEFAULT 'XOF'::text,
  subtotal numeric NOT NULL DEFAULT 0,
  tax numeric NOT NULL DEFAULT 0,
  total numeric NOT NULL DEFAULT 0,
  notes text,
  issued_at timestamp with time zone,
  expires_at timestamp with time zone,
  created_by uuid,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT quotes_pkey PRIMARY KEY (id),
  CONSTRAINT quotes_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT quotes_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT quotes_customer_user_id_fkey FOREIGN KEY (customer_user_id) REFERENCES auth.users(id),
  CONSTRAINT quotes_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.reports (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  reporter_user_id uuid NOT NULL,
  content_type text NOT NULL CHECK (content_type = ANY (ARRAY['business'::text, 'post'::text, 'comment'::text])),
  content_id uuid NOT NULL,
  reason text,
  status USER-DEFINED NOT NULL DEFAULT 'open'::report_status,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT reports_pkey PRIMARY KEY (id),
  CONSTRAINT reports_reporter_user_id_fkey FOREIGN KEY (reporter_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.service_request_assignments (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  request_id uuid NOT NULL,
  staff_user_id uuid NOT NULL,
  assigned_by_user_id uuid NOT NULL,
  role text NOT NULL DEFAULT 'primary'::text CHECK (role = ANY (ARRAY['primary'::text, 'secondary'::text])),
  assigned_at timestamp with time zone NOT NULL DEFAULT now(),
  unassigned_at timestamp with time zone,
  CONSTRAINT service_request_assignments_pkey PRIMARY KEY (id),
  CONSTRAINT service_request_assignments_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT service_request_assignments_staff_user_id_fkey FOREIGN KEY (staff_user_id) REFERENCES auth.users(id),
  CONSTRAINT service_request_assignments_assigned_by_user_id_fkey FOREIGN KEY (assigned_by_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.service_request_attachments (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  request_id uuid NOT NULL,
  storage_path text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT service_request_attachments_pkey PRIMARY KEY (id),
  CONSTRAINT service_request_attachments_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id)
);
CREATE TABLE public.service_request_items (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  request_id uuid NOT NULL,
  product_id uuid,
  title_snapshot text,
  qty integer NOT NULL DEFAULT 1 CHECK (qty > 0),
  unit_price_snapshot numeric,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT service_request_items_pkey PRIMARY KEY (id),
  CONSTRAINT service_request_items_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT service_request_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id)
);
CREATE TABLE public.service_request_messages (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  request_id uuid NOT NULL,
  sender_user_id uuid NOT NULL,
  message text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT service_request_messages_pkey PRIMARY KEY (id),
  CONSTRAINT service_request_messages_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT service_request_messages_sender_user_id_fkey FOREIGN KEY (sender_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.service_request_status_history (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  request_id uuid NOT NULL,
  from_status USER-DEFINED,
  to_status USER-DEFINED NOT NULL,
  actor_user_id uuid,
  note text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT service_request_status_history_pkey PRIMARY KEY (id),
  CONSTRAINT service_request_status_history_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.service_requests(id),
  CONSTRAINT service_request_status_history_actor_user_id_fkey FOREIGN KEY (actor_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.service_requests (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  customer_user_id uuid NOT NULL,
  type USER-DEFINED NOT NULL DEFAULT 'freeform'::request_type,
  status USER-DEFINED NOT NULL DEFAULT 'new'::request_status,
  address_text text,
  location USER-DEFINED,
  notes text,
  total_estimate numeric,
  currency text DEFAULT 'XOF'::text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT service_requests_pkey PRIMARY KEY (id),
  CONSTRAINT service_requests_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id),
  CONSTRAINT service_requests_customer_user_id_fkey FOREIGN KEY (customer_user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.spatial_ref_sys (
  srid integer NOT NULL CHECK (srid > 0 AND srid <= 998999),
  auth_name character varying,
  auth_srid integer,
  srtext character varying,
  proj4text character varying,
  CONSTRAINT spatial_ref_sys_pkey PRIMARY KEY (srid)
);
CREATE TABLE public.subscriptions (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL,
  provider USER-DEFINED NOT NULL,
  status USER-DEFINED NOT NULL DEFAULT 'active'::subscription_status,
  provider_customer_id text,
  provider_subscription_id text,
  product_id text,
  current_period_start timestamp with time zone,
  current_period_end timestamp with time zone,
  last_verified_at timestamp with time zone,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT subscriptions_pkey PRIMARY KEY (id),
  CONSTRAINT subscriptions_business_id_fkey FOREIGN KEY (business_id) REFERENCES public.businesses(id)
);


















=============================================================================================

=============================================================================================
Supabase SQL Editor Queries (rangé du plus recemment exécuté jusqu'au plus nouvellement exécuté)
=============================================================================================
=============================================================================================
=============================================================================================

=============================================================================================

Owners/Admins Read Business Members Policy

drop policy if exists "members_can_read_business_members_as_admin" on public.business_members;
create policy "members_can_read_business_members_as_admin"
on public.business_members
for select
to authenticated
using (
  public.is_business_member(business_id, array['owner','admin'])
);

=============================================================================================

Business Member Management

-- Add member by email (requires existing auth user)
create or replace function public.add_business_member_by_email(
  bid uuid,
  member_email text,
  new_role public.member_role default 'staff'::public.member_role
)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  uid uuid;
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  select id into uid
  from auth.users
  where lower(email) = lower(member_email)
  limit 1;

  if uid is null then
    raise exception 'user_not_found';
  end if;

  insert into public.business_members(business_id, user_id, role)
  values (bid, uid, new_role)
  on conflict (business_id, user_id) do update
    set role = excluded.role;
end;
$$;

grant execute on function public.add_business_member_by_email(uuid, text, public.member_role) to authenticated;


-- Update role
create or replace function public.update_business_member_role(
  bid uuid,
  member_user_id uuid,
  new_role public.member_role
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  if exists (
    select 1 from public.business_members
    where business_id = bid and user_id = member_user_id and role = 'owner'
  ) then
    raise exception 'cannot_change_owner';
  end if;

  update public.business_members
  set role = new_role
  where business_id = bid and user_id = member_user_id;
end;
$$;

grant execute on function public.update_business_member_role(uuid, uuid, public.member_role) to authenticated;

=============================================================================================

Drop obsolete function overloads

-- IMPORTANT: supprime l'ancienne surcharge (text) pour éviter l'ambiguïté
drop function if exists public.add_business_member_by_email(uuid, text, text);
drop function if exists public.update_business_member_role(uuid, uuid, text);

=============================================================================================

Business member management functions

-- =========================
-- Business Member RPCs (ENUM-safe + profile ensure)
-- =========================

create or replace function public.add_business_member_by_email(
  bid uuid,
  member_email text,
  new_role public.member_role default 'staff'::public.member_role
)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  uid uuid;
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  if new_role = 'owner'::public.member_role then
    raise exception 'cannot_assign_owner';
  end if;

  select id into uid
  from auth.users
  where lower(email) = lower(member_email)
  limit 1;

  if uid is null then
    raise exception 'user_not_found';
  end if;

  -- Ensure profiles row exists (FK business_members.user_id -> profiles.user_id)
  insert into public.profiles (user_id, email, full_name, created_at, updated_at)
  values (uid, member_email, member_email, now(), now())
  on conflict (user_id) do update
    set email = coalesce(public.profiles.email, excluded.email),
        full_name = coalesce(public.profiles.full_name, excluded.full_name),
        updated_at = now();

  insert into public.business_members(business_id, user_id, role)
  values (bid, uid, new_role)
  on conflict (business_id, user_id) do update
    set role = excluded.role;
end;
$$;

grant execute on function public.add_business_member_by_email(uuid, text, public.member_role) to authenticated;


create or replace function public.update_business_member_role(
  bid uuid,
  member_user_id uuid,
  new_role public.member_role
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  if new_role = 'owner'::public.member_role then
    raise exception 'cannot_assign_owner';
  end if;

  if exists (
    select 1 from public.business_members
    where business_id = bid and user_id = member_user_id and role = 'owner'::public.member_role
  ) then
    raise exception 'cannot_change_owner';
  end if;

  update public.business_members
  set role = new_role
  where business_id = bid and user_id = member_user_id;
end;
$$;

grant execute on function public.update_business_member_role(uuid, uuid, public.member_role) to authenticated;


create or replace function public.remove_business_member(
  bid uuid,
  member_user_id uuid
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  if exists (
    select 1 from public.business_members
    where business_id = bid and user_id = member_user_id and role = 'owner'::public.member_role
  ) then
    raise exception 'cannot_remove_owner';
  end if;

  delete from public.business_members
  where business_id = bid and user_id = member_user_id;
end;
$$;

grant execute on function public.remove_business_member(uuid, uuid) to authenticated;

-- Reload PostgREST schema cache (évite "schema cache" / relation non détectée)
select pg_notify('pgrst', 'reload schema');

=============================================================================================

Business membership management

-- Add member by email (requires existing auth user)
create or replace function public.add_business_member_by_email(
  bid uuid,
  member_email text,
  new_role public.member_role default 'staff'::public.member_role
)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  uid uuid;
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  -- sécurité: ne pas permettre d'ajouter un owner via cette fonction
  if new_role = 'owner' then
    raise exception 'cannot_set_owner';
  end if;

  select id into uid
  from auth.users
  where lower(email) = lower(member_email)
  limit 1;

  if uid is null then
    raise exception 'user_not_found';
  end if;

  insert into public.business_members(business_id, user_id, role)
  values (bid, uid, new_role)
  on conflict (business_id, user_id) do update
    set role = excluded.role;
end;
$$;

grant execute on function public.add_business_member_by_email(uuid, text, public.member_role) to authenticated;


-- Update role
create or replace function public.update_business_member_role(
  bid uuid,
  member_user_id uuid,
  new_role public.member_role
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  -- ne jamais promouvoir owner ici
  if new_role = 'owner' then
    raise exception 'cannot_set_owner';
  end if;

  -- prevent changing owner (safety)
  if exists (
    select 1 from public.business_members
    where business_id = bid and user_id = member_user_id and role = 'owner'
  ) then
    raise exception 'cannot_change_owner';
  end if;

  update public.business_members
  set role = new_role
  where business_id = bid and user_id = member_user_id;
end;
$$;

grant execute on function public.update_business_member_role(uuid, uuid, public.member_role) to authenticated;


-- IMPORTANT: reload PostgREST schema cache
select pg_notify('pgrst', 'reload schema');

=============================================================================================

Profiles sync, RLS & add-member RPC

begin;

-- 1) PROFILES: colonnes attendues par le front (idempotent)
alter table public.profiles
  add column if not exists full_name text;

alter table public.profiles
  add column if not exists email text;

-- backfill simple
update public.profiles
set full_name = coalesce(full_name, display_name)
where full_name is null;

-- 2) Backfill depuis auth.users (utile si certains users n'ont pas de profile complet)
insert into public.profiles (user_id, email, full_name)
select
  u.id,
  u.email,
  coalesce(u.raw_user_meta_data->>'full_name', u.raw_user_meta_data->>'name', u.email)
from auth.users u
on conflict (user_id) do update
set
  email = coalesce(excluded.email, public.profiles.email),
  full_name = coalesce(public.profiles.full_name, excluded.full_name),
  updated_at = now();

-- 3) Trigger: créer/mettre à jour profile à chaque inscription (optionnel mais recommandé)
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles(user_id, email, full_name)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', new.email)
  )
  on conflict (user_id) do update
  set
    email = excluded.email,
    full_name = coalesce(public.profiles.full_name, excluded.full_name),
    updated_at = now();

  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- 4) RLS PROFILES: permettre owner/admin de lire les profiles des membres (si pas déjà fait)
alter table public.profiles enable row level security;

grant select, insert, update on public.profiles to authenticated;

drop policy if exists profiles_select_own on public.profiles;
create policy profiles_select_own
on public.profiles
for select
to authenticated
using (user_id = auth.uid());

drop policy if exists profiles_update_own on public.profiles;
create policy profiles_update_own
on public.profiles
for update
to authenticated
using (user_id = auth.uid())
with check (user_id = auth.uid());

drop policy if exists profiles_select_business_admin on public.profiles;
create policy profiles_select_business_admin
on public.profiles
for select
to authenticated
using (
  exists (
    select 1
    from public.business_members me
    join public.business_members other
      on other.business_id = me.business_id
    where me.user_id = auth.uid()
      and me.role::text in ('owner','admin')
      and other.user_id = profiles.user_id
  )
);

-- 5) RPC: add member by email (amélioré: assure profile avant insertion membership)
create or replace function public.add_business_member_by_email(
  bid uuid,
  member_email text,
  new_role text default 'staff'
)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  uid uuid;
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  if new_role not in ('staff','admin') then
    raise exception 'invalid_role';
  end if;

  select id into uid
  from auth.users
  where lower(email) = lower(member_email)
  limit 1;

  if uid is null then
    raise exception 'user_not_found';
  end if;

  -- assure profile (sinon FK business_members -> profiles peut échouer)
  insert into public.profiles (user_id, email, full_name)
  select
    u.id,
    u.email,
    coalesce(u.raw_user_meta_data->>'full_name', u.raw_user_meta_data->>'name', u.email)
  from auth.users u
  where u.id = uid
  on conflict (user_id) do update
  set
    email = coalesce(excluded.email, public.profiles.email),
    full_name = coalesce(public.profiles.full_name, excluded.full_name),
    updated_at = now();

  insert into public.business_members(business_id, user_id, role)
  values (bid, uid, new_role)
  on conflict (business_id, user_id) do update
    set role = excluded.role;
end;
$$;

grant execute on function public.add_business_member_by_email(uuid, text, text) to authenticated;

-- 6) Important: reload schema cache PostgREST (corrige immédiatement les erreurs de cache)
select pg_notify('pgrst', 'reload schema');

commit;

=============================================================================================

Profiles enhancements and RLS setup

begin;

-- =========================================================
-- 1) PROFILES: ajouter les colonnes attendues par le front
-- =========================================================
alter table public.profiles
  add column if not exists full_name text;

alter table public.profiles
  add column if not exists email text;

-- Backfill simple: si full_name absent, copie display_name
update public.profiles
set full_name = coalesce(full_name, display_name)
where full_name is null;

-- =========================================================
-- 2) PROFILES: backfill depuis auth.users (pour éviter FK qui casse)
--    (nécessite exécution en SQL Editor)
-- =========================================================
insert into public.profiles (user_id, email, full_name)
select
  u.id,
  u.email,
  coalesce(u.raw_user_meta_data->>'full_name', u.raw_user_meta_data->>'name', u.email)
from auth.users u
on conflict (user_id) do update
set
  email = coalesce(excluded.email, public.profiles.email),
  full_name = coalesce(public.profiles.full_name, excluded.full_name),
  updated_at = now();

-- =========================================================
-- 3) Trigger: création automatique de profiles à l’inscription
-- =========================================================
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles(user_id, email, full_name)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', new.email)
  )
  on conflict (user_id) do update
  set
    email = excluded.email,
    full_name = coalesce(public.profiles.full_name, excluded.full_name),
    updated_at = now();

  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- =========================================================
-- 4) Relation PostgREST propre: business_members.user_id -> profiles.user_id
--    On remplace l’ancienne FK vers auth.users pour éviter ambiguïtés de join
-- =========================================================
do $$
begin
  if exists (
    select 1
    from pg_constraint c
    join pg_class t on t.oid = c.conrelid
    join pg_namespace n on n.oid = t.relnamespace
    where n.nspname = 'public'
      and t.relname = 'business_members'
      and c.conname = 'business_members_user_id_fkey'
  ) then
    alter table public.business_members drop constraint business_members_user_id_fkey;
  end if;
end $$;

alter table public.business_members
  add constraint business_members_user_id_fkey
  foreign key (user_id) references public.profiles(user_id)
  on delete cascade;

-- =========================================================
-- 5) RLS PROFILES: lecture owner/admin sur les profils des membres
-- =========================================================
alter table public.profiles enable row level security;

-- droits table (parfois nécessaires selon ton setup)
grant select, insert, update on public.profiles to authenticated;

-- (re)crée policies propres
drop policy if exists profiles_select_own on public.profiles;
create policy profiles_select_own
on public.profiles
for select
to authenticated
using (user_id = auth.uid());

drop policy if exists profiles_update_own on public.profiles;
create policy profiles_update_own
on public.profiles
for update
to authenticated
using (user_id = auth.uid())
with check (user_id = auth.uid());

-- Owner/Admin peuvent lire les profils des membres de leur business
drop policy if exists profiles_select_business_admin on public.profiles;
create policy profiles_select_business_admin
on public.profiles
for select
to authenticated
using (
  exists (
    select 1
    from public.business_members me
    join public.business_members other
      on other.business_id = me.business_id
    where me.user_id = auth.uid()
      and me.role::text = any (array['owner','admin'])
      and other.user_id = profiles.user_id
  )
);

-- =========================================================
-- 6) Recharge PostgREST schema cache (utile si erreur "schema cache")
-- =========================================================
select pg_notify('pgrst', 'reload schema');

commit;

=============================================================================================

Business members: RLS, profiles FK fix & schema reload

begin;

-- =========================================================
-- 0) S'assurer qu'un profile existe pour chaque user membre
-- (sinon la FK vers profiles échouera)
-- =========================================================
insert into public.profiles (user_id, created_at, updated_at)
select distinct bm.user_id, now(), now()
from public.business_members bm
left join public.profiles p on p.user_id = bm.user_id
where p.user_id is null;

-- =========================================================
-- 1) FIX relation PostgREST: business_members.user_id -> profiles.user_id
-- (on remplace la FK actuelle vers auth.users)
-- =========================================================
alter table public.business_members
  drop constraint if exists business_members_user_id_fkey;

alter table public.business_members
  add constraint business_members_user_id_fkey
  foreign key (user_id) references public.profiles(user_id)
  on delete cascade;

-- =========================================================
-- 2) RLS business_members: permettre de lister les membres d'une entreprise
-- + permettre aux owner/admin de gérer les membres
-- =========================================================
alter table public.business_members enable row level security;

-- Lecture: tout membre peut voir tous les membres de son entreprise
drop policy if exists members_select_same_business on public.business_members;
create policy members_select_same_business
on public.business_members
for select
to authenticated
using (
  public.is_business_member(business_id, array['owner','admin','staff'])
);

-- Insert: seulement owner/admin
drop policy if exists members_insert_by_admin on public.business_members;
create policy members_insert_by_admin
on public.business_members
for insert
to authenticated
with check (
  public.is_business_member(business_id, array['owner','admin'])
);

-- Update role: seulement owner/admin
drop policy if exists members_update_by_admin on public.business_members;
create policy members_update_by_admin
on public.business_members
for update
to authenticated
using (
  public.is_business_member(business_id, array['owner','admin'])
)
with check (
  public.is_business_member(business_id, array['owner','admin'])
);

-- Delete: seulement owner/admin
drop policy if exists members_delete_by_admin on public.business_members;
create policy members_delete_by_admin
on public.business_members
for delete
to authenticated
using (
  public.is_business_member(business_id, array['owner','admin'])
);

-- (optionnel) tu peux laisser members_select_own existante, elle ne gêne pas.

-- =========================================================
-- 3) RLS profiles: autoriser un owner/admin à lire les profiles
-- des membres de sa propre entreprise (sinon liste "membres" inutile)
-- =========================================================
alter table public.profiles enable row level security;

drop policy if exists profiles_select_scoped on public.profiles;
create policy profiles_select_scoped
on public.profiles
for select
to authenticated
using (
  user_id = auth.uid()
  or exists (
    select 1
    from public.business_members bm_me
    join public.business_members bm_other
      on bm_other.business_id = bm_me.business_id
    where bm_me.user_id = auth.uid()
      and bm_me.role::text in ('owner','admin')
      and bm_other.user_id = profiles.user_id
  )
);

-- =========================================================
-- 4) RLS categories: autoriser owner/admin à créer une catégorie
-- =========================================================
alter table public.categories enable row level security;

drop policy if exists categories_public_read on public.categories;
create policy categories_public_read
on public.categories
for select
to public
using (true);

drop policy if exists categories_insert_by_admin on public.categories;
create policy categories_insert_by_admin
on public.categories
for insert
to authenticated
with check (
  exists (
    select 1
    from public.business_members bm
    where bm.user_id = auth.uid()
      and bm.role::text in ('owner','admin')
  )
);

-- =========================================================
-- 5) Reload PostgREST schema cache (corrige PGRST200 immédiatement)
-- =========================================================
select pg_notify('pgrst', 'reload schema');

commit;

=============================================================================================

Product Variant Media

-- Table: variant_media
create table if not exists public.variant_media (
  id uuid primary key default gen_random_uuid(),
  variant_id uuid not null references public.product_variants(id) on delete cascade,
  media_type text not null check (media_type in ('image','video')),
  storage_path text not null,
  created_at timestamptz not null default now()
);

alter table public.variant_media enable row level security;

-- Select: any authenticated business member of the variant's business
drop policy if exists "variant_media_select_members" on public.variant_media;
create policy "variant_media_select_members"
on public.variant_media
for select
to authenticated
using (
  exists (
    select 1
    from public.product_variants v
    join public.products p on p.id = v.product_id
    where v.id = variant_media.variant_id
      and public.is_business_member(p.business_id, array['owner','admin','staff'])
  )
);

-- Insert: member + path first segment must match business_id
drop policy if exists "variant_media_insert_members" on public.variant_media;
create policy "variant_media_insert_members"
on public.variant_media
for insert
to authenticated
with check (
  exists (
    select 1
    from public.product_variants v
    join public.products p on p.id = v.product_id
    where v.id = variant_media.variant_id
      and public.is_business_member(p.business_id, array['owner','admin','staff'])
      and p.business_id = public.try_uuid(split_part(variant_media.storage_path,'/',1))
  )
);

-- Delete: member + same business
drop policy if exists "variant_media_delete_members" on public.variant_media;
create policy "variant_media_delete_members"
on public.variant_media
for delete
to authenticated
using (
  exists (
    select 1
    from public.product_variants v
    join public.products p on p.id = v.product_id
    where v.id = variant_media.variant_id
      and public.is_business_member(p.business_id, array['owner','admin','staff'])
  )
);

=============================================================================================

Business Member Management Functions

-- Add member by email (requires existing auth user)
create or replace function public.add_business_member_by_email(
  bid uuid,
  member_email text,
  new_role text default 'staff'
)
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  uid uuid;
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  select id into uid
  from auth.users
  where lower(email) = lower(member_email)
  limit 1;

  if uid is null then
    raise exception 'user_not_found';
  end if;

  insert into public.business_members(business_id, user_id, role)
  values (bid, uid, new_role)
  on conflict (business_id, user_id) do update
    set role = excluded.role;
end;
$$;

grant execute on function public.add_business_member_by_email(uuid, text, text) to authenticated;


-- Update role
create or replace function public.update_business_member_role(
  bid uuid,
  member_user_id uuid,
  new_role text
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  -- prevent changing owner here (optional safety)
  if exists (
    select 1 from public.business_members
    where business_id = bid and user_id = member_user_id and role = 'owner'
  ) then
    raise exception 'cannot_change_owner';
  end if;

  update public.business_members
  set role = new_role
  where business_id = bid and user_id = member_user_id;
end;
$$;

grant execute on function public.update_business_member_role(uuid, uuid, text) to authenticated;


-- Remove member
create or replace function public.remove_business_member(
  bid uuid,
  member_user_id uuid
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_business_member(bid, array['owner','admin']) then
    raise exception 'not_authorized';
  end if;

  -- prevent removing owner (optional safety)
  if exists (
    select 1 from public.business_members
    where business_id = bid and user_id = member_user_id and role = 'owner'
  ) then
    raise exception 'cannot_remove_owner';
  end if;

  delete from public.business_members
  where business_id = bid and user_id = member_user_id;
end;
$$;

grant execute on function public.remove_business_member(uuid, uuid) to authenticated;

=============================================================================================

Read access for profiles of same-business users


-- Allow reading profiles of users who share a business with me
drop policy if exists "profiles_select_same_business" on public.profiles;
create policy "profiles_select_same_business"
on public.profiles
for select
using (
  exists (
    select 1
    from public.business_members bm_me
    join public.business_members bm_other
      on bm_other.business_id = bm_me.business_id
    where bm_me.user_id = auth.uid()
      and bm_other.user_id = profiles.user_id
  )
);
-- Allow reading profiles of users who share a business with me
drop policy if exists "profiles_select_same_business" on public.profiles;
create policy "profiles_select_same_business"
on public.profiles
for select
using (
  exists (
    select 1
    from public.business_members bm_me
    join public.business_members bm_other
      on bm_other.business_id = bm_me.business_id
    where bm_me.user_id = auth.uid()
      and bm_other.user_id = profiles.user_id
  )
);

=============================================================================================

Members Read Own Membership

create policy "members_can_read_own_membership"
on public.business_members
for select
to authenticated
using (user_id = auth.uid());

=============================================================================================

Business Membership Role CheckBusiness Membership Role Check

create or replace function public.is_business_member(bid uuid, roles text[])
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.business_members bm
    where bm.business_id = bid
      and bm.user_id = auth.uid()
      and bm.role::text = any(roles)
  );
$$;

revoke all on function public.is_business_member(uuid, text[]) from public;
grant execute on function public.is_business_member(uuid, text[]) to anon, authenticated;

=============================================================================================


Business Member Authorization Function


create or replace function public.is_business_member(bid uuid, roles text[])
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.business_members bm
    where bm.business_id = bid
      and bm.user_id = auth.uid()
      and bm.role::text = any(roles)
  );
$$;

grant execute on function public.is_business_member(uuid, text[]) to authenticated;
grant execute on function public.is_business_member(uuid, text[]) to anon;


=============================================================================================


Safe UUID Parser

create or replace function public.try_uuid(p text)
returns uuid
language plpgsql
stable
as $$
begin
  return p::uuid;
exception when others then
  return null;
end;
$$;

grant execute on function public.try_uuid(text) to anon, authenticated;

=============================================================================================

Media bucket and RLS policies for business-owned objects


-- =========================
-- Ensure bucket exists (and make it public-read if you want getPublicUrl to work)
-- =========================
insert into storage.buckets (id, name, public)
values ('product_media', 'product_media', true)
on conflict (id) do update set public = excluded.public;

-- =========================
-- RLS on storage.objects
-- =========================
alter table storage.objects enable row level security;

-- =========================
-- Public read (so Explorer can display media)
-- =========================
drop policy if exists "public_read_public_buckets" on storage.objects;
create policy "public_read_public_buckets"
on storage.objects for select
using (bucket_id in ('business_logos','business_covers','post_media','product_media'));

-- =========================
-- Write only by business members
-- business_id MUST be the first path segment: "<business_uuid>/..."
-- =========================
drop policy if exists "write_public_buckets_by_member" on storage.objects;
create policy "write_public_buckets_by_member"
on storage.objects for insert to authenticated
with check (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
);

drop policy if exists "update_public_buckets_by_member" on storage.objects;
create policy "update_public_buckets_by_member"
on storage.objects for update to authenticated
using (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
)
with check (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
);

drop policy if exists "delete_public_buckets_by_member" on storage.objects;
create policy "delete_public_buckets_by_member"
on storage.objects for delete to authenticated
using (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
);

=============================================================================================



-- patch_2026_01_14_products_orders_rules.sql (Enforce active-product pricing and restrict order creation)

begin;

-- 1) Si produit actif => prix obligatoire
--    (on désactive d'abord ceux qui seraient actifs sans prix pour ne pas casser)
update public.products
set is_active = false
where is_active = true and price_amount is null;

alter table public.products
  drop constraint if exists products_active_requires_price;

alter table public.products
  add constraint products_active_requires_price
  check (not is_active or price_amount is not null);

-- 2) RLS: empêcher la création de commandes vers business non autorisé à recevoir des commandes
--    (tu as déjà un policy insert qui check auth.uid sur customer_user_id;
--     on le renforce en ajoutant entitlements.can_receive_orders = true)
drop policy if exists requests_insert_customer on public.service_requests;

create policy requests_insert_customer on public.service_requests
for insert
with check (
  customer_user_id = auth.uid()
  and exists (
    select 1
    from public.entitlements e
    where e.business_id = business_id
      and e.can_receive_orders = true
  )
  and exists (
    select 1
    from public.businesses b
    where b.id = business_id
      and b.is_active = true
  )
);

commit;

=============================================================================================
Normalize & Deduplicate Business Hours

sql

-- patch_2026_01_14_fix_hours_unique.sql
-- IMPORTANT: exécute ce script en une fois dans Supabase SQL Editor.

begin;

-- 0) enlever le check si existant (pour pouvoir normaliser sans bloquer)
alter table public.business_hours
  drop constraint if exists business_hours_day_of_week_check;

-- 1) normaliser: si tu avais encore des valeurs 0..6 (0=Dimanche),
--    conversion correcte vers 1..7 (1=Lun .. 7=Dim) :
--    0 -> 7, 1..6 restent identiques (PAS +1)
update public.business_hours
set day_of_week = case when day_of_week = 0 then 7 else day_of_week end
where day_of_week between 0 and 6;

-- 2) dédoublonnage: garder la ligne la plus récente par (business_id, day_of_week)
with ranked as (
  select
    ctid,
    business_id,
    day_of_week,
    row_number() over (
      partition by business_id, day_of_week
      order by updated_at desc nulls last, created_at desc, ctid desc
    ) as rn
  from public.business_hours
)
delete from public.business_hours bh
using ranked r
where bh.ctid = r.ctid
  and r.rn > 1;

-- 3) colonnes de compat (si tu utilises opens_at/closes_at côté app)
alter table public.business_hours
  add column if not exists opens_at time,
  add column if not exists closes_at time;

-- si tu as déjà open_time/close_time, on copie vers opens_at/closes_at si vides
update public.business_hours
set
  opens_at  = coalesce(opens_at,  open_time),
  closes_at = coalesce(closes_at, close_time)
where opens_at is null or closes_at is null;

commit;

-- 4) maintenant seulement, on peut créer l’unique index (ne rollback pas le dédoublonnage si souci)
create unique index if not exists ux_business_hours_business_day
  on public.business_hours(business_id, day_of_week);

-- 5) remettre le check (1..7)
alter table public.business_hours
  add constraint business_hours_day_of_week_check
  check (day_of_week between 1 and 7);

=============================================================================================
Row-Level Security for Posts and Post Media

-- POSTS
alter table public.posts enable row level security;

drop policy if exists posts_public_read on public.posts;
create policy posts_public_read
on public.posts
for select
to public
using (
  is_published = true
  and exists (
    select 1 from public.businesses b
    where b.id = posts.business_id
      and b.is_active = true
  )
);

drop policy if exists posts_write_by_member on public.posts;
create policy posts_write_by_member
on public.posts
for all
to public
using (is_business_member(business_id, array['owner','admin','staff']))
with check (
  is_business_member(business_id, array['owner','admin','staff'])
  and author_user_id = auth.uid()
);

-- POST_MEDIA
alter table public.post_media enable row level security;

drop policy if exists post_media_public_read on public.post_media;
create policy post_media_public_read
on public.post_media
for select
to public
using (
  exists (
    select 1
    from public.posts p
    join public.businesses b on b.id = p.business_id
    where p.id = post_media.post_id
      and p.is_published = true
      and b.is_active = true
  )
);

drop policy if exists post_media_write_by_member on public.post_media;
create policy post_media_write_by_member
on public.post_media
for all
to public
using (
  exists (
    select 1 from public.posts p
    where p.id = post_media.post_id
      and is_business_member(p.business_id, array['owner','admin','staff'])
  )
)
with check (
  exists (
    select 1 from public.posts p
    where p.id = post_media.post_id
      and is_business_member(p.business_id, array['owner','admin','staff'])
  )
);

=============================================================================================
Business hours deduplication & unique index

-- (Optionnel) dédoublonnage : garder la ligne la plus récente par (business_id, day_of_week)
delete from public.business_hours a
using public.business_hours b
where a.business_id = b.business_id
  and a.day_of_week = b.day_of_week
  and a.created_at < b.created_at;

-- Unique (business_id, day_of_week)
create unique index if not exists ux_business_hours_business_day
on public.business_hours (business_id, day_of_week);

=============================================================================================
Normalize day_of_week to 1-7

begin;

-- 1) Convertir les données existantes (0..6 -> 1..7)
update public.business_hours
set day_of_week = day_of_week + 1
where day_of_week between 0 and 6;

-- 2) Remplacer la contrainte
alter table public.business_hours
drop constraint if exists business_hours_day_of_week_check;

alter table public.business_hours
add constraint business_hours_day_of_week_check
check (day_of_week between 1 and 7);

commit;
=============================================================================================
Public Read Policies for Business Content

-- ========= BUSINESSES (public read si active) =========
drop policy if exists businesses_public_read on public.businesses;
create policy businesses_public_read
on public.businesses
for select
to public
using (is_active = true);

-- ========= HOURS =========
drop policy if exists business_hours_public_read on public.business_hours;
create policy business_hours_public_read
on public.business_hours
for select
to public
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_hours.business_id
      and b.is_active = true
  )
);

-- ========= SOCIAL LINKS =========
drop policy if exists business_social_links_public_read on public.business_social_links;
create policy business_social_links_public_read
on public.business_social_links
for select
to public
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_social_links.business_id
      and b.is_active = true
  )
);

-- ========= POSTS + MEDIA =========
drop policy if exists posts_public_read on public.posts;
create policy posts_public_read
on public.posts
for select
to public
using (
  is_published = true
  and exists (
    select 1 from public.businesses b
    where b.id = posts.business_id
      and b.is_active = true
  )
);

drop policy if exists post_media_public_read on public.post_media;
create policy post_media_public_read
on public.post_media
for select
to public
using (
  exists (
    select 1
    from public.posts p
    join public.businesses b on b.id = p.business_id
    where p.id = post_media.post_id
      and p.is_published = true
      and b.is_active = true
  )
);

-- ========= PRODUCTS + MEDIA + VARIANTS =========
drop policy if exists products_public_read on public.products;
create policy products_public_read
on public.products
for select
to public
using (
  is_active = true
  and exists (
    select 1 from public.businesses b
    where b.id = products.business_id
      and b.is_active = true
  )
);

drop policy if exists product_media_public_read on public.product_media;
create policy product_media_public_read
on public.product_media
for select
to public
using (
  exists (
    select 1
    from public.products pr
    join public.businesses b on b.id = pr.business_id
    where pr.id = product_media.product_id
      and pr.is_active = true
      and b.is_active = true
  )
);

drop policy if exists product_variants_public_read on public.product_variants;
create policy product_variants_public_read
on public.product_variants
for select
to public
using (
  is_active = true
  and exists (
    select 1
    from public.products pr
    join public.businesses b on b.id = pr.business_id
    where pr.id = product_variants.product_id
      and pr.is_active = true
      and b.is_active = true
  )
);
=============================================================================================
Schema migrations and sync triggers for business, domains, products

-- =========================
-- (1) BUSINESS HOURS: ajouter colonnes attendues par l'app
-- =========================
alter table public.business_hours
  add column if not exists opens_at time,
  add column if not exists closes_at time;

-- backfill depuis les colonnes existantes
update public.business_hours
set opens_at = coalesce(opens_at, open_time),
    closes_at = coalesce(closes_at, close_time)
where opens_at is null or closes_at is null;

-- contrainte unique nécessaire pour upsert(onConflict: business_id,day_of_week)
create unique index if not exists ux_business_hours_business_day
  on public.business_hours(business_id, day_of_week);

-- trigger pour garder open_time/close_time et opens_at/closes_at synchronisés
create or replace function public.sync_business_hours_times()
returns trigger language plpgsql as $$
begin
  -- si l'app écrit opens_at/closes_at
  if new.opens_at is not null then new.open_time := new.opens_at; end if;
  if new.closes_at is not null then new.close_time := new.closes_at; end if;

  -- si legacy écrit open_time/close_time
  if new.open_time is not null then new.opens_at := new.open_time; end if;
  if new.close_time is not null then new.closes_at := new.close_time; end if;

  return new;
end $$;

drop trigger if exists trg_sync_business_hours_times on public.business_hours;
create trigger trg_sync_business_hours_times
before insert or update on public.business_hours
for each row execute function public.sync_business_hours_times();


-- =========================
-- (2) BUSINESS SOCIAL LINKS: contrainte unique pour upsert
-- =========================
create unique index if not exists ux_business_social_links_business_platform
  on public.business_social_links(business_id, platform);


-- =========================
-- (3) BUSINESS DOMAINS: ajouter ssl_status + sécuriser verification_token
-- =========================
alter table public.business_domains
  add column if not exists ssl_status text;

-- default token (si tu as pgcrypto, gen_random_bytes est OK dans Supabase)
alter table public.business_domains
  alter column verification_token
  set default encode(gen_random_bytes(16), 'hex');

update public.business_domains
set verification_token = coalesce(nullif(trim(verification_token), ''), encode(gen_random_bytes(16), 'hex'))
where verification_token is null or length(trim(verification_token)) = 0;

update public.business_domains
set ssl_status = coalesce(ssl_status, 'pending')
where ssl_status is null;

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'business_domains_ssl_status_ck'
      and conrelid = 'public.business_domains'::regclass
  ) then
    alter table public.business_domains
      add constraint business_domains_ssl_status_ck
      check (ssl_status in ('pending','issued','failed'));
  end if;
end$$;


-- =========================
-- (4) PRODUCT VARIANTS: ajouter options (alias compatible avec l'app)
-- =========================
alter table public.product_variants
  add column if not exists options jsonb not null default '{}'::jsonb;

-- backfill: si attributes est rempli mais options vide
update public.product_variants
set options = attributes
where options = '{}'::jsonb and attributes <> '{}'::jsonb;

-- sync options <-> attributes
create or replace function public.sync_product_variant_options()
returns trigger language plpgsql as $$
begin
  -- priorité à options si renseigné
  if new.options is not null and new.options <> '{}'::jsonb then
    new.attributes := new.options;
  else
    new.options := coalesce(new.attributes, '{}'::jsonb);
  end if;
  return new;
end $$;

drop trigger if exists trg_sync_product_variant_options on public.product_variants;
create trigger trg_sync_product_variant_options
before insert or update on public.product_variants
for each row execute function public.sync_product_variant_options();


-- =========================
-- (5) INVENTORY ON HAND VIEW: créer la vue si absente
-- =========================
create or replace view public.inventory_on_hand as
select
  v.id as variant_id,
  v.product_id,
  coalesce(sum(m.delta_qty), 0) as on_hand
from public.product_variants v
left join public.inventory_movements m on m.variant_id = v.id
group by v.id, v.product_id;

-- Optionnel: grants (si besoin)
grant select on public.inventory_on_hand to anon, authenticated;
=============================================================================================
Business Hours, Social Links & Domains Tables

-- =========================
-- B1) business_hours
-- =========================
create table if not exists public.business_hours (
  business_id uuid not null references public.businesses(id) on delete cascade,
  day_of_week smallint not null check (day_of_week between 1 and 7),
  is_closed boolean not null default false,
  opens_at time,
  closes_at time,
  updated_at timestamptz not null default now(),
  primary key (business_id, day_of_week),
  constraint business_hours_valid check (
    (is_closed = true and opens_at is null and closes_at is null)
    or
    (is_closed = false and opens_at is not null and closes_at is not null and opens_at < closes_at)
  )
);

alter table public.business_hours enable row level security;

drop policy if exists bh_public_read on public.business_hours;
create policy bh_public_read
on public.business_hours
for select
to public
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_hours.business_id
      and b.is_active = true
  )
);

drop policy if exists bh_write_by_admin on public.business_hours;
create policy bh_write_by_admin
on public.business_hours
for all
to public
using (is_business_member(business_id, array['owner'::text,'admin'::text]))
with check (is_business_member(business_id, array['owner'::text,'admin'::text]));


-- =========================
-- B1) business_social_links
-- =========================
create table if not exists public.business_social_links (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  platform text not null,
  url text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint business_social_links_platform_ck check (
    platform = any(array['website','whatsapp','facebook','instagram','tiktok','x','youtube'])
  ),
  constraint business_social_links_unique unique (business_id, platform)
);

create index if not exists idx_bsl_business on public.business_social_links(business_id);

alter table public.business_social_links enable row level security;

drop policy if exists bsl_public_read on public.business_social_links;
create policy bsl_public_read
on public.business_social_links
for select
to public
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_social_links.business_id
      and b.is_active = true
  )
);

drop policy if exists bsl_write_by_admin on public.business_social_links;
create policy bsl_write_by_admin
on public.business_social_links
for all
to public
using (is_business_member(business_id, array['owner'::text,'admin'::text]))
with check (is_business_member(business_id, array['owner'::text,'admin'::text]));


-- =========================
-- B1) business_domains
-- =========================
create table if not exists public.business_domains (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  domain text not null,
  status text not null default 'pending' check (status in ('pending','verified','rejected')),
  verification_token text not null default encode(gen_random_bytes(16), 'hex'),
  verified_at timestamptz,
  ssl_status text not null default 'pending' check (ssl_status in ('pending','issued','failed')),
  last_checked_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint business_domains_domain_unique unique (domain)
);

create index if not exists idx_bd_business on public.business_domains(business_id);

alter table public.business_domains enable row level security;

-- Domain: pas public (par défaut), réservé aux admins business
drop policy if exists bd_read_by_admin on public.business_domains;
create policy bd_read_by_admin
on public.business_domains
for select
to public
using (is_business_member(business_id, array['owner'::text,'admin'::text]));

drop policy if exists bd_write_by_admin on public.business_domains;
create policy bd_write_by_admin
on public.business_domains
for all
to public
using (is_business_member(business_id, array['owner'::text,'admin'::text]))
with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
=============================================================================================
Service Request Assignments

drop table if exists public.service_request_assignments cascade;

create table public.service_request_assignments (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  staff_user_id uuid not null references auth.users(id),
  assigned_by_user_id uuid not null references auth.users(id),
  role text not null default 'primary' check (role in ('primary','secondary')),
  assigned_at timestamptz not null default now(),
  unassigned_at timestamptz
);

create index if not exists idx_sra_request on public.service_request_assignments(request_id);
create index if not exists idx_sra_staff on public.service_request_assignments(staff_user_id);

create unique index if not exists ux_sra_active
on public.service_request_assignments(request_id, staff_user_id)
where unassigned_at is null;

alter table public.service_request_assignments enable row level security;

drop policy if exists sra_read_participants on public.service_request_assignments;
create policy sra_read_participants
on public.service_request_assignments
for select
to public
using (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and (
        r.customer_user_id = auth.uid()
        or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

drop policy if exists sra_insert_by_admin on public.service_request_assignments;
create policy sra_insert_by_admin
on public.service_request_assignments
for insert
to public
with check (
  assigned_by_user_id = auth.uid()
  and exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and is_business_member(r.business_id, array['owner'::text,'admin'::text])
  )
);

drop policy if exists sra_update_by_admin on public.service_request_assignments;
create policy sra_update_by_admin
on public.service_request_assignments
for update
to public
using (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and is_business_member(r.business_id, array['owner'::text,'admin'::text])
  )
)
with check (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and is_business_member(r.business_id, array['owner'::text,'admin'::text])
  )
);

=============================================================================================
Inventory movements and on‑hand view

-- 1) Supprimer la vue qui dépend de la table
drop view if exists public.inventory_on_hand;

-- 2) Recréer la table avec la bonne colonne delta_qty
drop table if exists public.inventory_movements cascade;

create table public.inventory_movements (
  id uuid primary key default gen_random_uuid(),
  variant_id uuid not null references public.product_variants(id),
  delta_qty integer not null check (delta_qty <> 0),
  reason text,
  ref_type text,
  ref_id uuid,
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now()
);

create index if not exists idx_inventory_movements_variant on public.inventory_movements(variant_id);
create index if not exists idx_inventory_movements_created_at on public.inventory_movements(created_at);

alter table public.inventory_movements enable row level security;

drop policy if exists invmov_read_by_member on public.inventory_movements;
create policy invmov_read_by_member
on public.inventory_movements
for select
to public
using (
  exists (
    select 1
    from public.product_variants v
    join public.products pr on pr.id = v.product_id
    where v.id = inventory_movements.variant_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

drop policy if exists invmov_insert_by_member on public.inventory_movements;
create policy invmov_insert_by_member
on public.inventory_movements
for insert
to public
with check (
  created_by = auth.uid()
  and exists (
    select 1
    from public.product_variants v
    join public.products pr on pr.id = v.product_id
    where v.id = inventory_movements.variant_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- 3) Recréer la vue
create or replace view public.inventory_on_hand as
select
  v.id as variant_id,
  v.product_id,
  coalesce(sum(m.delta_qty), 0) as on_hand
from public.product_variants v
left join public.inventory_movements m on m.variant_id = v.id
group by v.id, v.product_id;

=============================================================================================
Service Request Lifecycle, Billing & Payments

-- ---------- B3.1: service_request_status_history ----------
create table if not exists public.service_request_status_history (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  from_status public.request_status,
  to_status public.request_status not null,
  actor_user_id uuid not null references auth.users(id),
  note text,
  created_at timestamptz not null default now()
);

create index if not exists idx_srh_request on public.service_request_status_history(request_id);
create index if not exists idx_srh_created_at on public.service_request_status_history(created_at);

alter table public.service_request_status_history enable row level security;

drop policy if exists srh_read_participants on public.service_request_status_history;
create policy srh_read_participants
on public.service_request_status_history
for select
to public
using (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_status_history.request_id
      and (
        r.customer_user_id = auth.uid()
        or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

drop policy if exists srh_insert_participants on public.service_request_status_history;
create policy srh_insert_participants
on public.service_request_status_history
for insert
to public
with check (
  actor_user_id = auth.uid()
  and exists (
    select 1
    from public.service_requests r
    where r.id = service_request_status_history.request_id
      and (
        r.customer_user_id = auth.uid()
        or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

-- ---------- B3.2: service_request_assignments ----------
create table if not exists public.service_request_assignments (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  staff_user_id uuid not null references auth.users(id),
  assigned_by_user_id uuid not null references auth.users(id),
  role text not null default 'primary' check (role in ('primary','secondary')),
  assigned_at timestamptz not null default now(),
  unassigned_at timestamptz
);

create index if not exists idx_sra_request on public.service_request_assignments(request_id);
create index if not exists idx_sra_staff on public.service_request_assignments(staff_user_id);

-- 1 staff ne peut être "actif" qu'une fois par request (unassigned_at null)
create unique index if not exists ux_sra_active
on public.service_request_assignments(request_id, staff_user_id)
where unassigned_at is null;

alter table public.service_request_assignments enable row level security;

drop policy if exists sra_read_participants on public.service_request_assignments;
create policy sra_read_participants
on public.service_request_assignments
for select
to public
using (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and (
        r.customer_user_id = auth.uid()
        or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

-- insert/update par admin/owner uniquement
drop policy if exists sra_insert_by_admin on public.service_request_assignments;
create policy sra_insert_by_admin
on public.service_request_assignments
for insert
to public
with check (
  assigned_by_user_id = auth.uid()
  and exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and is_business_member(r.business_id, array['owner'::text,'admin'::text])
  )
);

drop policy if exists sra_update_by_admin on public.service_request_assignments;
create policy sra_update_by_admin
on public.service_request_assignments
for update
to public
using (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and is_business_member(r.business_id, array['owner'::text,'admin'::text])
  )
)
with check (
  exists (
    select 1
    from public.service_requests r
    where r.id = service_request_assignments.request_id
      and is_business_member(r.business_id, array['owner'::text,'admin'::text])
  )
);

-- ---------- B3.3: quotes + quote_items ----------
create table if not exists public.quotes (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  business_id uuid not null references public.businesses(id),
  customer_user_id uuid not null references auth.users(id),
  status text not null default 'draft' check (status in ('draft','sent','accepted','rejected','expired','cancelled')),
  currency text not null default 'XOF',
  subtotal numeric not null default 0,
  tax numeric not null default 0,
  total numeric not null default 0,
  notes text,
  valid_until timestamptz,
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint quotes_request_business_match check (
    exists (
      select 1 from public.service_requests r
      where r.id = request_id and r.business_id = business_id and r.customer_user_id = customer_user_id
    )
  )
);

drop trigger if exists trg_quotes_updated_at on public.quotes;
create trigger trg_quotes_updated_at
before update on public.quotes
for each row execute function public.set_updated_at();

create index if not exists idx_quotes_request on public.quotes(request_id);
create index if not exists idx_quotes_business on public.quotes(business_id);

alter table public.quotes enable row level security;

drop policy if exists quotes_read_participants on public.quotes;
create policy quotes_read_participants
on public.quotes
for select
to public
using (
  customer_user_id = auth.uid()
  or is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

drop policy if exists quotes_insert_by_member on public.quotes;
create policy quotes_insert_by_member
on public.quotes
for insert
to public
with check (
  created_by = auth.uid()
  and is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

drop policy if exists quotes_update_by_member on public.quotes;
create policy quotes_update_by_member
on public.quotes
for update
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
)
with check (
  is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

create table if not exists public.quote_items (
  id uuid primary key default gen_random_uuid(),
  quote_id uuid not null references public.quotes(id) on delete cascade,
  title text not null,
  qty integer not null default 1 check (qty > 0),
  unit_price numeric not null default 0,
  created_at timestamptz not null default now()
);

create index if not exists idx_quote_items_quote on public.quote_items(quote_id);

alter table public.quote_items enable row level security;

drop policy if exists quote_items_read_participants on public.quote_items;
create policy quote_items_read_participants
on public.quote_items
for select
to public
using (
  exists (
    select 1 from public.quotes q
    where q.id = quote_items.quote_id
      and (
        q.customer_user_id = auth.uid()
        or is_business_member(q.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

drop policy if exists quote_items_write_by_member on public.quote_items;
create policy quote_items_write_by_member
on public.quote_items
for insert
to public
with check (
  exists (
    select 1 from public.quotes q
    where q.id = quote_items.quote_id
      and is_business_member(q.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

drop policy if exists quote_items_delete_by_member on public.quote_items;
create policy quote_items_delete_by_member
on public.quote_items
for delete
to public
using (
  exists (
    select 1 from public.quotes q
    where q.id = quote_items.quote_id
      and is_business_member(q.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- ---------- B3.4: invoices + invoice_items ----------
create table if not exists public.invoices (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  quote_id uuid references public.quotes(id),
  business_id uuid not null references public.businesses(id),
  customer_user_id uuid not null references auth.users(id),
  status text not null default 'draft' check (status in ('draft','issued','paid','void','overdue','cancelled')),
  currency text not null default 'XOF',
  subtotal numeric not null default 0,
  tax numeric not null default 0,
  total numeric not null default 0,
  due_at timestamptz,
  issued_at timestamptz,
  paid_at timestamptz,
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint invoices_request_business_match check (
    exists (
      select 1 from public.service_requests r
      where r.id = request_id and r.business_id = business_id and r.customer_user_id = customer_user_id
    )
  )
);

drop trigger if exists trg_invoices_updated_at on public.invoices;
create trigger trg_invoices_updated_at
before update on public.invoices
for each row execute function public.set_updated_at();

create index if not exists idx_invoices_request on public.invoices(request_id);
create index if not exists idx_invoices_business on public.invoices(business_id);

alter table public.invoices enable row level security;

drop policy if exists invoices_read_participants on public.invoices;
create policy invoices_read_participants
on public.invoices
for select
to public
using (
  customer_user_id = auth.uid()
  or is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

drop policy if exists invoices_insert_by_member on public.invoices;
create policy invoices_insert_by_member
on public.invoices
for insert
to public
with check (
  created_by = auth.uid()
  and is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

drop policy if exists invoices_update_by_member on public.invoices;
create policy invoices_update_by_member
on public.invoices
for update
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
)
with check (
  is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

create table if not exists public.invoice_items (
  id uuid primary key default gen_random_uuid(),
  invoice_id uuid not null references public.invoices(id) on delete cascade,
  title text not null,
  qty integer not null default 1 check (qty > 0),
  unit_price numeric not null default 0,
  created_at timestamptz not null default now()
);

create index if not exists idx_invoice_items_invoice on public.invoice_items(invoice_id);

alter table public.invoice_items enable row level security;

drop policy if exists invoice_items_read_participants on public.invoice_items;
create policy invoice_items_read_participants
on public.invoice_items
for select
to public
using (
  exists (
    select 1 from public.invoices i
    where i.id = invoice_items.invoice_id
      and (
        i.customer_user_id = auth.uid()
        or is_business_member(i.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

drop policy if exists invoice_items_write_by_member on public.invoice_items;
create policy invoice_items_write_by_member
on public.invoice_items
for insert
to public
with check (
  exists (
    select 1 from public.invoices i
    where i.id = invoice_items.invoice_id
      and is_business_member(i.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

drop policy if exists invoice_items_delete_by_member on public.invoice_items;
create policy invoice_items_delete_by_member
on public.invoice_items
for delete
to public
using (
  exists (
    select 1 from public.invoices i
    where i.id = invoice_items.invoice_id
      and is_business_member(i.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- ---------- B3.5: payment_intents + lien payments ----------
-- provider: je réutilise public.subscription_provider (car c’est l’enum que tu as déjà).
create table if not exists public.payment_intents (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id),
  request_id uuid references public.service_requests(id),
  invoice_id uuid references public.invoices(id),
  provider public.subscription_provider not null,
  amount numeric not null,
  currency text not null default 'XOF',
  status text not null default 'pending' check (status in ('pending','paid','failed','cancelled','refunded')),
  external_ref text,
  metadata jsonb not null default '{}'::jsonb,
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_payment_intents_updated_at on public.payment_intents;
create trigger trg_payment_intents_updated_at
before update on public.payment_intents
for each row execute function public.set_updated_at();

create index if not exists idx_payment_intents_business on public.payment_intents(business_id);
create index if not exists idx_payment_intents_invoice on public.payment_intents(invoice_id);

alter table public.payment_intents enable row level security;

drop policy if exists pi_read_participants on public.payment_intents;
create policy pi_read_participants
on public.payment_intents
for select
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
  or exists (
    select 1 from public.service_requests r
    where r.id = payment_intents.request_id and r.customer_user_id = auth.uid()
  )
  or exists (
    select 1 from public.invoices i
    where i.id = payment_intents.invoice_id and i.customer_user_id = auth.uid()
  )
);

drop policy if exists pi_insert_by_member on public.payment_intents;
create policy pi_insert_by_member
on public.payment_intents
for insert
to public
with check (
  created_by = auth.uid()
  and is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

drop policy if exists pi_update_by_admin on public.payment_intents;
create policy pi_update_by_admin
on public.payment_intents
for update
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text])
)
with check (
  is_business_member(business_id, array['owner'::text,'admin'::text])
);

-- (Optionnel mais utile) Lier payments -> payment_intents
alter table public.payments
add column if not exists payment_intent_id uuid references public.payment_intents(id);

create index if not exists idx_payments_intent on public.payments(payment_intent_id);

=============================================================================================
Product catalog — categories, variants & inventory

-- ---------- B2.1: product_categories_map ----------
create table if not exists public.product_categories_map (
  product_id uuid not null references public.products(id) on delete cascade,
  category_id uuid not null references public.categories(id),
  created_at timestamptz not null default now(),
  constraint product_categories_map_pkey primary key (product_id, category_id)
);

create index if not exists idx_pcm_category on public.product_categories_map(category_id);

alter table public.product_categories_map enable row level security;

-- lecture publique si produit actif, ou membre si produit inactif
drop policy if exists pcm_read_public_or_member on public.product_categories_map;
create policy pcm_read_public_or_member
on public.product_categories_map
for select
to public
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_categories_map.product_id
      and (
        pr.is_active = true
        or is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

-- write par membres business
drop policy if exists pcm_write_by_member on public.product_categories_map;
create policy pcm_write_by_member
on public.product_categories_map
for insert
to public
with check (
  exists (
    select 1
    from public.products pr
    where pr.id = product_categories_map.product_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

drop policy if exists pcm_delete_by_member on public.product_categories_map;
create policy pcm_delete_by_member
on public.product_categories_map
for delete
to public
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_categories_map.product_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- ---------- B2.2: product_variants ----------
create table if not exists public.product_variants (
  id uuid primary key default gen_random_uuid(),
  product_id uuid not null references public.products(id) on delete cascade,
  title text not null,
  sku text,
  options jsonb not null default '{}'::jsonb,
  price_amount numeric,
  currency text not null default 'XOF',
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_product_variants_updated_at on public.product_variants;
create trigger trg_product_variants_updated_at
before update on public.product_variants
for each row execute function public.set_updated_at();

create index if not exists idx_product_variants_product on public.product_variants(product_id);
create unique index if not exists ux_product_variants_sku_per_product
on public.product_variants(product_id, sku)
where sku is not null and sku <> '';

alter table public.product_variants enable row level security;

drop policy if exists variants_read_public_or_member on public.product_variants;
create policy variants_read_public_or_member
on public.product_variants
for select
to public
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_variants.product_id
      and (
        (pr.is_active = true and product_variants.is_active = true)
        or is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
      )
  )
);

drop policy if exists variants_write_by_member on public.product_variants;
create policy variants_write_by_member
on public.product_variants
for insert
to public
with check (
  exists (
    select 1
    from public.products pr
    where pr.id = product_variants.product_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

drop policy if exists variants_update_by_member on public.product_variants;
create policy variants_update_by_member
on public.product_variants
for update
to public
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_variants.product_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
)
with check (
  exists (
    select 1
    from public.products pr
    where pr.id = product_variants.product_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

drop policy if exists variants_delete_by_member on public.product_variants;
create policy variants_delete_by_member
on public.product_variants
for delete
to public
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_variants.product_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- ---------- B2.3: inventory_movements ----------
-- delta_qty: +N = entrée stock, -N = sortie stock, peut être ajustement manuel.
create table if not exists public.inventory_movements (
  id uuid primary key default gen_random_uuid(),
  variant_id uuid not null references public.product_variants(id),
  delta_qty integer not null check (delta_qty <> 0),
  reason text,
  ref_type text,
  ref_id uuid,
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now()
);

create index if not exists idx_inventory_movements_variant on public.inventory_movements(variant_id);
create index if not exists idx_inventory_movements_created_at on public.inventory_movements(created_at);

alter table public.inventory_movements enable row level security;

-- read: seulement business members
drop policy if exists invmov_read_by_member on public.inventory_movements;
create policy invmov_read_by_member
on public.inventory_movements
for select
to public
using (
  exists (
    select 1
    from public.product_variants v
    join public.products pr on pr.id = v.product_id
    where v.id = inventory_movements.variant_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- insert: seulement business members, created_by = auth.uid()
drop policy if exists invmov_insert_by_member on public.inventory_movements;
create policy invmov_insert_by_member
on public.inventory_movements
for insert
to public
with check (
  created_by = auth.uid()
  and exists (
    select 1
    from public.product_variants v
    join public.products pr on pr.id = v.product_id
    where v.id = inventory_movements.variant_id
      and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
  )
);

-- Optionnel (recommandé): vue pour stock actuel
create or replace view public.inventory_on_hand as
select
  v.id as variant_id,
  v.product_id,
  coalesce(sum(m.delta_qty), 0) as on_hand
from public.product_variants v
left join public.inventory_movements m on m.variant_id = v.id
group by v.id, v.product_id;

=============================================================================================
Business hours, social links & domains schema

-- ---------- Helper: updated_at trigger ----------
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- ---------- B1.1: business_hours ----------
-- Convention: day_of_week = 1..7 (1=Lundi ... 7=Dimanche)
create table if not exists public.business_hours (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  day_of_week smallint not null check (day_of_week between 1 and 7),
  is_closed boolean not null default false,
  open_time time,
  close_time time,
  note text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint business_hours_one_per_day unique (business_id, day_of_week),
  constraint business_hours_valid_times check (
    (is_closed = true and open_time is null and close_time is null)
    OR
    (is_closed = false and open_time is not null and close_time is not null and open_time < close_time)
  )
);

drop trigger if exists trg_business_hours_updated_at on public.business_hours;
create trigger trg_business_hours_updated_at
before update on public.business_hours
for each row execute function public.set_updated_at();

create index if not exists idx_business_hours_business on public.business_hours(business_id);

alter table public.business_hours enable row level security;

-- Public read si business active
drop policy if exists business_hours_public_read on public.business_hours;
create policy business_hours_public_read
on public.business_hours
for select
to public
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_hours.business_id
      and b.is_active = true
  )
);

-- Write par membres (owner/admin) uniquement
drop policy if exists business_hours_write_by_admin on public.business_hours;
create policy business_hours_write_by_admin
on public.business_hours
for insert
to public
with check (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
);

drop policy if exists business_hours_update_by_admin on public.business_hours;
create policy business_hours_update_by_admin
on public.business_hours
for update
to public
using (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
)
with check (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
);

drop policy if exists business_hours_delete_by_admin on public.business_hours;
create policy business_hours_delete_by_admin
on public.business_hours
for delete
to public
using (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
);

-- ---------- B1.2: business_social_links ----------
create table if not exists public.business_social_links (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  platform text not null check (platform in (
    'website','whatsapp','facebook','instagram','tiktok','x','linkedin','youtube'
  )),
  url text not null,
  label text,
  sort_order integer not null default 0,
  is_visible boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint business_social_links_unique unique (business_id, platform)
);

drop trigger if exists trg_business_social_links_updated_at on public.business_social_links;
create trigger trg_business_social_links_updated_at
before update on public.business_social_links
for each row execute function public.set_updated_at();

create index if not exists idx_business_social_links_business on public.business_social_links(business_id);

alter table public.business_social_links enable row level security;

drop policy if exists business_social_links_public_read on public.business_social_links;
create policy business_social_links_public_read
on public.business_social_links
for select
to public
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_social_links.business_id
      and b.is_active = true
  )
);

drop policy if exists business_social_links_write_by_admin on public.business_social_links;
create policy business_social_links_write_by_admin
on public.business_social_links
for insert
to public
with check (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
);

drop policy if exists business_social_links_update_by_admin on public.business_social_links;
create policy business_social_links_update_by_admin
on public.business_social_links
for update
to public
using (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
)
with check (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
);

drop policy if exists business_social_links_delete_by_admin on public.business_social_links;
create policy business_social_links_delete_by_admin
on public.business_social_links
for delete
to public
using (
  is_business_member(business_id, array['owner'::text, 'admin'::text])
);

-- ---------- B1.3: business_domains ----------
create table if not exists public.business_domains (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  domain text not null,
  status text not null default 'pending' check (status in (
    'pending','dns_pending','verified','ssl_pending','active','error'
  )),
  dns_record_type text,
  dns_record_name text,
  dns_record_value text,
  verified_at timestamptz,
  last_check_at timestamptz,
  error_message text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint business_domains_domain_unique unique (domain)
);

drop trigger if exists trg_business_domains_updated_at on public.business_domains;
create trigger trg_business_domains_updated_at
before update on public.business_domains
for each row execute function public.set_updated_at();

create index if not exists idx_business_domains_business on public.business_domains(business_id);
create index if not exists idx_business_domains_domain on public.business_domains(domain);

alter table public.business_domains enable row level security;

-- Read seulement par membres de la business (pas public)
drop policy if exists business_domains_read_by_member on public.business_domains;
create policy business_domains_read_by_member
on public.business_domains
for select
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
);

-- Write / update / delete par owner/admin
drop policy if exists business_domains_write_by_admin on public.business_domains;
create policy business_domains_write_by_admin
on public.business_domains
for insert
to public
with check (
  is_business_member(business_id, array['owner'::text,'admin'::text])
);

drop policy if exists business_domains_update_by_admin on public.business_domains;
create policy business_domains_update_by_admin
on public.business_domains
for update
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text])
)
with check (
  is_business_member(business_id, array['owner'::text,'admin'::text])
);

drop policy if exists business_domains_delete_by_admin on public.business_domains;
create policy business_domains_delete_by_admin
on public.business_domains
for delete
to public
using (
  is_business_member(business_id, array['owner'::text,'admin'::text])
);

=============================================================================================
Application Tables Existence Check

select table_name
from information_schema.tables
where table_schema='public'
  and table_name in (
    'business_hours','business_social_links','business_domains',
    'product_categories_map','product_variants','inventory_movements',
    'service_request_status_history','service_request_assignments',
    'quotes','quote_items','invoices','invoice_items','payment_intents'
  )
order by table_name;

=============================================================================================
Commerce schema — storefront, catalog & billing


-- =========================
-- 0) Helpers (updated_at)
-- =========================
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- =========================
-- 1) ENUMS (nouveaux)
-- =========================
do $$
begin
  create type public.domain_verification_status as enum ('pending','verified','failed');
exception when duplicate_object then null;
end $$;

do $$
begin
  create type public.social_platform as enum ('website','whatsapp','facebook','instagram','tiktok','youtube','x','linkedin');
exception when duplicate_object then null;
end $$;

do $$
begin
  create type public.inventory_movement_type as enum ('in','out','adjust','reserve','release');
exception when duplicate_object then null;
end $$;

do $$
begin
  create type public.assignment_role as enum ('primary','assistant');
exception when duplicate_object then null;
end $$;

do $$
begin
  create type public.quote_status as enum ('draft','sent','accepted','rejected','expired','cancelled');
exception when duplicate_object then null;
end $$;

do $$
begin
  create type public.invoice_status as enum ('draft','issued','paid','void','overdue','cancelled');
exception when duplicate_object then null;
end $$;

do $$
begin
  create type public.payment_intent_status as enum ('pending','paid','failed','cancelled');
exception when duplicate_object then null;
end $$;

-- =====================================================
-- B1) Boutique publique + paramètres avancés
--   - business_hours
--   - business_social_links
--   - business_domains
-- =====================================================

create table if not exists public.business_hours (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,

  -- 0=Dimanche ... 6=Samedi (standard)
  day_of_week smallint not null check (day_of_week between 0 and 6),

  is_closed boolean not null default false,
  open_time time,
  close_time time,
  timezone text not null default 'Africa/Lome',

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  -- si is_closed=false, open/close doivent être présents et cohérents
  constraint business_hours_time_check check (
    (is_closed = true and open_time is null and close_time is null)
    or
    (is_closed = false and open_time is not null and close_time is not null and open_time < close_time)
  )
);

create index if not exists idx_business_hours_business_day
  on public.business_hours (business_id, day_of_week);

drop trigger if exists trg_business_hours_updated_at on public.business_hours;
create trigger trg_business_hours_updated_at
before update on public.business_hours
for each row execute function public.set_updated_at();


create table if not exists public.business_social_links (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,

  platform public.social_platform not null,
  url text not null,
  label text,
  sort_order int not null default 0,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint business_social_links_url_nonempty check (length(trim(url)) > 0)
);

create index if not exists idx_business_social_links_business
  on public.business_social_links (business_id, sort_order);

-- option: éviter doublons exacts
create unique index if not exists uq_business_social_links_business_platform_url
  on public.business_social_links (business_id, platform, url);

drop trigger if exists trg_business_social_links_updated_at on public.business_social_links;
create trigger trg_business_social_links_updated_at
before update on public.business_social_links
for each row execute function public.set_updated_at();


create table if not exists public.business_domains (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,

  domain text not null,
  status public.domain_verification_status not null default 'pending',
  verification_token text,            -- token à poser en DNS/HTTP selon ton mécanisme
  verified_at timestamptz,
  last_checked_at timestamptz,

  dns_details jsonb not null default '{}'::jsonb,
  ssl_details jsonb not null default '{}'::jsonb,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint business_domains_domain_nonempty check (length(trim(domain)) > 0)
);

-- un domaine ne doit appartenir qu'à 1 business
create unique index if not exists uq_business_domains_domain
  on public.business_domains (lower(domain));

create index if not exists idx_business_domains_business
  on public.business_domains (business_id, status);

drop trigger if exists trg_business_domains_updated_at on public.business_domains;
create trigger trg_business_domains_updated_at
before update on public.business_domains
for each row execute function public.set_updated_at();


-- =====================================================
-- B2) Catalogue avancé
--   - product_categories_map
--   - product_variants
--   - inventory_movements
-- =====================================================

create table if not exists public.product_categories_map (
  product_id uuid not null references public.products(id) on delete cascade,
  category_id uuid not null references public.categories(id) on delete restrict,
  created_at timestamptz not null default now(),
  primary key (product_id, category_id)
);

create index if not exists idx_product_categories_map_category
  on public.product_categories_map (category_id);


create table if not exists public.product_variants (
  id uuid primary key default gen_random_uuid(),
  product_id uuid not null references public.products(id) on delete cascade,

  title text,
  sku text,
  attributes jsonb not null default '{}'::jsonb,  -- ex: {"size":"L","color":"red"}

  -- option: override prix du produit
  price_amount numeric,
  currency text default 'XOF',

  is_active boolean not null default true,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint product_variants_sku_nonempty check (sku is null or length(trim(sku)) > 0)
);

create index if not exists idx_product_variants_product
  on public.product_variants (product_id, is_active);

-- sku unique par produit (simple et robuste)
create unique index if not exists uq_product_variants_product_sku
  on public.product_variants (product_id, sku)
  where sku is not null;

drop trigger if exists trg_product_variants_updated_at on public.product_variants;
create trigger trg_product_variants_updated_at
before update on public.product_variants
for each row execute function public.set_updated_at();


create table if not exists public.inventory_movements (
  id uuid primary key default gen_random_uuid(),

  business_id uuid not null references public.businesses(id) on delete cascade,
  product_id uuid not null references public.products(id) on delete cascade,
  variant_id uuid references public.product_variants(id) on delete set null,

  movement_type public.inventory_movement_type not null,
  qty integer not null check (qty <> 0),

  unit_cost numeric,
  reason text,

  ref_type text,   -- ex: "purchase", "sale", "adjustment", "request"
  ref_id uuid,

  created_by uuid references auth.users(id),
  created_at timestamptz not null default now()
);

create index if not exists idx_inventory_movements_business_product
  on public.inventory_movements (business_id, product_id, created_at desc);

create index if not exists idx_inventory_movements_variant
  on public.inventory_movements (variant_id, created_at desc)
  where variant_id is not null;


-- =====================================================
-- B3) Workflow demande → devis/facture → paiement + staff
--   - service_request_status_history
--   - service_request_assignments
--   - quotes + quote_items
--   - invoices + invoice_items
--   - payment_intents (+ lien payments)
-- =====================================================

create table if not exists public.service_request_status_history (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,

  from_status public.request_status,
  to_status public.request_status not null,

  actor_user_id uuid references auth.users(id),
  note text,

  created_at timestamptz not null default now()
);

create index if not exists idx_req_status_history_request
  on public.service_request_status_history (request_id, created_at desc);


create table if not exists public.service_request_assignments (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  business_id uuid not null references public.businesses(id) on delete cascade,

  staff_user_id uuid not null references auth.users(id),
  role public.assignment_role not null default 'primary',

  assigned_by uuid references auth.users(id),
  assigned_at timestamptz not null default now(),
  unassigned_at timestamptz,
  note text,

  created_at timestamptz not null default now()
);

create index if not exists idx_req_assignments_request_active
  on public.service_request_assignments (request_id, assigned_at desc)
  where unassigned_at is null;

-- 1 seul "primary" actif par request
create unique index if not exists uq_req_assignments_one_primary_active
  on public.service_request_assignments (request_id)
  where unassigned_at is null and role = 'primary';


create table if not exists public.quotes (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  request_id uuid not null references public.service_requests(id) on delete cascade,
  customer_user_id uuid not null references auth.users(id),

  status public.quote_status not null default 'draft',

  currency text not null default 'XOF',
  subtotal numeric not null default 0,
  tax numeric not null default 0,
  total numeric not null default 0,

  notes text,
  issued_at timestamptz,
  expires_at timestamptz,

  created_by uuid references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_quotes_request
  on public.quotes (request_id, created_at desc);

create index if not exists idx_quotes_business_status
  on public.quotes (business_id, status, created_at desc);

drop trigger if exists trg_quotes_updated_at on public.quotes;
create trigger trg_quotes_updated_at
before update on public.quotes
for each row execute function public.set_updated_at();


create table if not exists public.quote_items (
  id uuid primary key default gen_random_uuid(),
  quote_id uuid not null references public.quotes(id) on delete cascade,

  product_id uuid references public.products(id) on delete set null,
  title text not null,
  description text,

  qty integer not null default 1 check (qty > 0),
  unit_price numeric not null default 0 check (unit_price >= 0),

  created_at timestamptz not null default now()
);

create index if not exists idx_quote_items_quote
  on public.quote_items (quote_id);


create table if not exists public.invoices (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  request_id uuid not null references public.service_requests(id) on delete cascade,
  quote_id uuid references public.quotes(id) on delete set null,
  customer_user_id uuid not null references auth.users(id),

  invoice_number text, -- unique par business (optionnel mais utile)
  status public.invoice_status not null default 'draft',

  currency text not null default 'XOF',
  subtotal numeric not null default 0,
  tax numeric not null default 0,
  total numeric not null default 0,

  issued_at timestamptz,
  due_at timestamptz,
  paid_at timestamptz,

  pdf_path text,

  created_by uuid references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create unique index if not exists uq_invoices_business_number
  on public.invoices (business_id, invoice_number)
  where invoice_number is not null;

create index if not exists idx_invoices_request
  on public.invoices (request_id, created_at desc);

create index if not exists idx_invoices_business_status
  on public.invoices (business_id, status, created_at desc);

drop trigger if exists trg_invoices_updated_at on public.invoices;
create trigger trg_invoices_updated_at
before update on public.invoices
for each row execute function public.set_updated_at();


create table if not exists public.invoice_items (
  id uuid primary key default gen_random_uuid(),
  invoice_id uuid not null references public.invoices(id) on delete cascade,

  product_id uuid references public.products(id) on delete set null,
  title text not null,
  description text,

  qty integer not null default 1 check (qty > 0),
  unit_price numeric not null default 0 check (unit_price >= 0),

  created_at timestamptz not null default now()
);

create index if not exists idx_invoice_items_invoice
  on public.invoice_items (invoice_id);


create table if not exists public.payment_intents (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,

  request_id uuid references public.service_requests(id) on delete set null,
  invoice_id uuid references public.invoices(id) on delete set null,

  status public.payment_intent_status not null default 'pending',
  provider text, -- cinetpay, fedapay, manual, etc (laisser text => flexible)

  amount numeric not null default 0,
  currency text not null default 'XOF',

  external_ref text, -- référence provider
  metadata jsonb not null default '{}'::jsonb,

  created_by uuid references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_payment_intents_business_status
  on public.payment_intents (business_id, status, created_at desc);

create index if not exists idx_payment_intents_invoice
  on public.payment_intents (invoice_id);

drop trigger if exists trg_payment_intents_updated_at on public.payment_intents;
create trigger trg_payment_intents_updated_at
before update on public.payment_intents
for each row execute function public.set_updated_at();


-- Lien "payments -> payment_intents" (petite migration)
do $$
begin
  if not exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='payments' and column_name='payment_intent_id'
  ) then
    alter table public.payments add column payment_intent_id uuid references public.payment_intents(id) on delete set null;
    create index if not exists idx_payments_intent on public.payments (payment_intent_id);
  end if;
end $$;


-- =====================================================
-- 2) Triggers utiles (auto status history sur update)
-- =====================================================

create or replace function public.log_service_request_status_change()
returns trigger
language plpgsql
as $$
begin
  if (new.status is distinct from old.status) then
    insert into public.service_request_status_history(
      request_id, from_status, to_status, actor_user_id, note
    ) values (
      new.id, old.status, new.status, auth.uid(), null
    );
  end if;
  return new;
end;
$$;

drop trigger if exists trg_service_requests_status_history on public.service_requests;
create trigger trg_service_requests_status_history
after update of status on public.service_requests
for each row execute function public.log_service_request_status_change();


-- =====================================================
-- 3) RLS + POLICIES (nouveaux objets)
--     Aligné avec ton style existant: TO public + auth.uid()
-- =====================================================

-- ---------- B1 RLS
alter table public.business_hours enable row level security;
alter table public.business_social_links enable row level security;
alter table public.business_domains enable row level security;

do $$
begin
  -- business_hours: lecture publique si business actif
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_hours' and policyname='business_hours_public_read') then
    execute $p$
      create policy business_hours_public_read
      on public.business_hours
      for select
      to public
      using (exists (select 1 from public.businesses b where b.id = business_hours.business_id and b.is_active = true));
    $p$;
  end if;

  -- business_hours: write admin
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_hours' and policyname='business_hours_write_by_admin') then
    execute $p$
      create policy business_hours_write_by_admin
      on public.business_hours
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_hours' and policyname='business_hours_update_by_admin') then
    execute $p$
      create policy business_hours_update_by_admin
      on public.business_hours
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_hours' and policyname='business_hours_delete_by_admin') then
    execute $p$
      create policy business_hours_delete_by_admin
      on public.business_hours
      for delete
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;


  -- social links: lecture publique si business actif
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_social_links' and policyname='business_social_public_read') then
    execute $p$
      create policy business_social_public_read
      on public.business_social_links
      for select
      to public
      using (exists (select 1 from public.businesses b where b.id = business_social_links.business_id and b.is_active = true));
    $p$;
  end if;

  -- social links: write admin
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_social_links' and policyname='business_social_write_by_admin') then
    execute $p$
      create policy business_social_write_by_admin
      on public.business_social_links
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_social_links' and policyname='business_social_update_by_admin') then
    execute $p$
      create policy business_social_update_by_admin
      on public.business_social_links
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_social_links' and policyname='business_social_delete_by_admin') then
    execute $p$
      create policy business_social_delete_by_admin
      on public.business_social_links
      for delete
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;


  -- domains: lecture uniquement membres business
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_domains' and policyname='business_domains_read_by_member') then
    execute $p$
      create policy business_domains_read_by_member
      on public.business_domains
      for select
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]));
    $p$;
  end if;

  -- domains: write admin
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_domains' and policyname='business_domains_write_by_admin') then
    execute $p$
      create policy business_domains_write_by_admin
      on public.business_domains
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_domains' and policyname='business_domains_update_by_admin') then
    execute $p$
      create policy business_domains_update_by_admin
      on public.business_domains
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='business_domains' and policyname='business_domains_delete_by_admin') then
    execute $p$
      create policy business_domains_delete_by_admin
      on public.business_domains
      for delete
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text]));
    $p$;
  end if;

end $$;


-- ---------- B2 RLS
alter table public.product_categories_map enable row level security;
alter table public.product_variants enable row level security;
alter table public.inventory_movements enable row level security;

do $$
begin
  -- product_categories_map: lecture publique si produit actif, sinon membres
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_categories_map' and policyname='prod_cat_map_read') then
    execute $p$
      create policy prod_cat_map_read
      on public.product_categories_map
      for select
      to public
      using (
        exists (
          select 1
          from public.products pr
          where pr.id = product_categories_map.product_id
            and (pr.is_active = true
                 or is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;

  -- write uniquement membres
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_categories_map' and policyname='prod_cat_map_write') then
    execute $p$
      create policy prod_cat_map_write
      on public.product_categories_map
      for insert
      to public
      with check (
        exists (
          select 1
          from public.products pr
          where pr.id = product_categories_map.product_id
            and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_categories_map' and policyname='prod_cat_map_delete') then
    execute $p$
      create policy prod_cat_map_delete
      on public.product_categories_map
      for delete
      to public
      using (
        exists (
          select 1
          from public.products pr
          where pr.id = product_categories_map.product_id
            and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;


  -- variants: lecture publique si produit actif, sinon membres
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_variants' and policyname='variants_read') then
    execute $p$
      create policy variants_read
      on public.product_variants
      for select
      to public
      using (
        exists (
          select 1 from public.products pr
          where pr.id = product_variants.product_id
            and (pr.is_active = true
                 or is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;

  -- variants: write membres
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_variants' and policyname='variants_write') then
    execute $p$
      create policy variants_write
      on public.product_variants
      for insert
      to public
      with check (
        exists (
          select 1 from public.products pr
          where pr.id = product_variants.product_id
            and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_variants' and policyname='variants_update') then
    execute $p$
      create policy variants_update
      on public.product_variants
      for update
      to public
      using (
        exists (
          select 1 from public.products pr
          where pr.id = product_variants.product_id
            and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      )
      with check (
        exists (
          select 1 from public.products pr
          where pr.id = product_variants.product_id
            and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='product_variants' and policyname='variants_delete') then
    execute $p$
      create policy variants_delete
      on public.product_variants
      for delete
      to public
      using (
        exists (
          select 1 from public.products pr
          where pr.id = product_variants.product_id
            and is_business_member(pr.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;


  -- inventory movements: lecture membres (stock = interne)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='inventory_movements' and policyname='inv_moves_read_by_member') then
    execute $p$
      create policy inv_moves_read_by_member
      on public.inventory_movements
      for select
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]));
    $p$;
  end if;

  -- inventory movements: write membres (tu peux durcir à owner/admin si tu veux)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='inventory_movements' and policyname='inv_moves_write_by_member') then
    execute $p$
      create policy inv_moves_write_by_member
      on public.inventory_movements
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]) and created_by = auth.uid());
    $p$;
  end if;

end $$;


-- ---------- B3 RLS
alter table public.service_request_status_history enable row level security;
alter table public.service_request_assignments enable row level security;
alter table public.quotes enable row level security;
alter table public.quote_items enable row level security;
alter table public.invoices enable row level security;
alter table public.invoice_items enable row level security;
alter table public.payment_intents enable row level security;

do $$
begin
  -- status history: read si participant (customer ou business member)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='service_request_status_history' and policyname='req_status_hist_read') then
    execute $p$
      create policy req_status_hist_read
      on public.service_request_status_history
      for select
      to public
      using (
        exists (
          select 1 from public.service_requests r
          where r.id = service_request_status_history.request_id
            and (r.customer_user_id = auth.uid()
                 or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;

  -- status history: insert par participant (actor = auth.uid)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='service_request_status_history' and policyname='req_status_hist_insert') then
    execute $p$
      create policy req_status_hist_insert
      on public.service_request_status_history
      for insert
      to public
      with check (
        actor_user_id = auth.uid()
        and exists (
          select 1 from public.service_requests r
          where r.id = service_request_status_history.request_id
            and (r.customer_user_id = auth.uid()
                 or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;


  -- assignments: read si participant
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='service_request_assignments' and policyname='req_assign_read') then
    execute $p$
      create policy req_assign_read
      on public.service_request_assignments
      for select
      to public
      using (
        exists (
          select 1 from public.service_requests r
          where r.id = service_request_assignments.request_id
            and (r.customer_user_id = auth.uid()
                 or is_business_member(r.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;

  -- assignments: write par membres business (assigned_by = auth.uid et staff appartient au business)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='service_request_assignments' and policyname='req_assign_write') then
    execute $p$
      create policy req_assign_write
      on public.service_request_assignments
      for insert
      to public
      with check (
        assigned_by = auth.uid()
        and is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
        and exists (select 1 from public.business_members bm where bm.business_id = service_request_assignments.business_id and bm.user_id = staff_user_id)
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='service_request_assignments' and policyname='req_assign_update') then
    execute $p$
      create policy req_assign_update
      on public.service_request_assignments
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]));
    $p$;
  end if;


  -- quotes: read si participant (customer ou business)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='quotes' and policyname='quotes_read_participant') then
    execute $p$
      create policy quotes_read_participant
      on public.quotes
      for select
      to public
      using (
        customer_user_id = auth.uid()
        or is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
      );
    $p$;
  end if;

  -- quotes: write business members
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='quotes' and policyname='quotes_write_by_member') then
    execute $p$
      create policy quotes_write_by_member
      on public.quotes
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]) and created_by = auth.uid());
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='quotes' and policyname='quotes_update_by_member') then
    execute $p$
      create policy quotes_update_by_member
      on public.quotes
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]));
    $p$;
  end if;


  -- quote_items: read/write via quote
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='quote_items' and policyname='quote_items_read') then
    execute $p$
      create policy quote_items_read
      on public.quote_items
      for select
      to public
      using (
        exists (
          select 1 from public.quotes q
          where q.id = quote_items.quote_id
            and (q.customer_user_id = auth.uid()
                 or is_business_member(q.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='quote_items' and policyname='quote_items_write') then
    execute $p$
      create policy quote_items_write
      on public.quote_items
      for insert
      to public
      with check (
        exists (
          select 1 from public.quotes q
          where q.id = quote_items.quote_id
            and is_business_member(q.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='quote_items' and policyname='quote_items_delete') then
    execute $p$
      create policy quote_items_delete
      on public.quote_items
      for delete
      to public
      using (
        exists (
          select 1 from public.quotes q
          where q.id = quote_items.quote_id
            and is_business_member(q.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;


  -- invoices: read participant
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='invoices' and policyname='invoices_read_participant') then
    execute $p$
      create policy invoices_read_participant
      on public.invoices
      for select
      to public
      using (
        customer_user_id = auth.uid()
        or is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
      );
    $p$;
  end if;

  -- invoices: write business members
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='invoices' and policyname='invoices_write_by_member') then
    execute $p$
      create policy invoices_write_by_member
      on public.invoices
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]) and created_by = auth.uid());
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='invoices' and policyname='invoices_update_by_member') then
    execute $p$
      create policy invoices_update_by_member
      on public.invoices
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]));
    $p$;
  end if;


  -- invoice_items: read/write via invoice
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='invoice_items' and policyname='invoice_items_read') then
    execute $p$
      create policy invoice_items_read
      on public.invoice_items
      for select
      to public
      using (
        exists (
          select 1 from public.invoices i
          where i.id = invoice_items.invoice_id
            and (i.customer_user_id = auth.uid()
                 or is_business_member(i.business_id, array['owner'::text,'admin'::text,'staff'::text]))
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='invoice_items' and policyname='invoice_items_write') then
    execute $p$
      create policy invoice_items_write
      on public.invoice_items
      for insert
      to public
      with check (
        exists (
          select 1 from public.invoices i
          where i.id = invoice_items.invoice_id
            and is_business_member(i.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='invoice_items' and policyname='invoice_items_delete') then
    execute $p$
      create policy invoice_items_delete
      on public.invoice_items
      for delete
      to public
      using (
        exists (
          select 1 from public.invoices i
          where i.id = invoice_items.invoice_id
            and is_business_member(i.business_id, array['owner'::text,'admin'::text,'staff'::text])
        )
      );
    $p$;
  end if;


  -- payment_intents: read participant (customer via invoice/request) + business members
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='payment_intents' and policyname='payment_intents_read') then
    execute $p$
      create policy payment_intents_read
      on public.payment_intents
      for select
      to public
      using (
        is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text])
        or exists (
          select 1 from public.invoices i
          where i.id = payment_intents.invoice_id and i.customer_user_id = auth.uid()
        )
        or exists (
          select 1 from public.service_requests r
          where r.id = payment_intents.request_id and r.customer_user_id = auth.uid()
        )
      );
    $p$;
  end if;

  -- payment_intents: insert/update par business members (évite que customer change amount/provider)
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='payment_intents' and policyname='payment_intents_write') then
    execute $p$
      create policy payment_intents_write
      on public.payment_intents
      for insert
      to public
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]) and created_by = auth.uid());
    $p$;
  end if;

  if not exists (select 1 from pg_policies where schemaname='public' and tablename='payment_intents' and policyname='payment_intents_update') then
    execute $p$
      create policy payment_intents_update
      on public.payment_intents
      for update
      to public
      using (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]))
      with check (is_business_member(business_id, array['owner'::text,'admin'::text,'staff'::text]));
    $p$;
  end if;

end $$;

=============================================================================================
Device token uniqueness and notification indexes

-- Un token FCM doit être unique (sinon doublons et spam).
ALTER TABLE public.device_tokens
  ADD CONSTRAINT device_tokens_token_unique UNIQUE (token);

CREATE INDEX IF NOT EXISTS idx_device_tokens_user_active
  ON public.device_tokens (user_id)
  WHERE revoked_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_notifications_user_created
  ON public.notifications (user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_notifications_status_created
  ON public.notifications (status, created_at);

=============================================================================================
Enable Row-Level Security for Application Tables

-- Ads
ALTER TABLE public.ad_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_stats_daily ENABLE ROW LEVEL SECURITY;

-- Business / catalogue
ALTER TABLE public.business_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.product_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.post_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.post_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.post_likes ENABLE ROW LEVEL SECURITY;

-- Paiements / abonnements
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.entitlements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;

-- Profil
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Requests
ALTER TABLE public.service_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_request_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_request_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_request_attachments ENABLE ROW LEVEL SECURITY;

-- Notifications (important)
ALTER TABLE public.device_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_deliveries ENABLE ROW LEVEL SECURITY;

-- Audit (idéalement service-role only)
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

=============================================================================================
Public schema RLS policies

select
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
from pg_policies
where schemaname = 'public'
order by tablename, policyname;
#pour lister toutes les polycies

=============================================================================================
Row-Level Security for Selected Public Tables

select
  schemaname,
  tablename,
  rowsecurity as rls_enabled
from pg_tables
where schemaname = 'public'
  and tablename in (
    'service_requests',
    'service_request_messages',
    'notifications',
    'device_tokens',
    'businesses',
    'business_members'
  )
order by tablename;

=============================================================================================
Untitled query

select
  n.nspname as schema,
  t.typname as enum_name,
  e.enumsortorder as sort_order,
  e.enumlabel as enum_value
from pg_type t
join pg_enum e on t.oid = e.enumtypid
join pg_namespace n on n.oid = t.typnamespace
where n.nspname in ('public', 'auth')
order by enum_name, sort_order;
#to get enums

=============================================================================================
Enforce Unique User–Token Pair

alter table public.device_tokens
add constraint device_tokens_user_token_uniq unique(user_id, token);

=============================================================================================
Request Message Notification Trigger

create or replace function public.trg_notify_request_message_created()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_req record;
  v_link text;
  v_sender_is_customer boolean;
begin
  select id, business_id, customer_user_id
  into v_req
  from public.service_requests
  where id = new.request_id;

  if v_req.id is null then
    return new;
  end if;

  v_link := '/requests/' || v_req.id::text;

  v_sender_is_customer := (new.sender_user_id = v_req.customer_user_id);

  if v_sender_is_customer then
    -- client -> boutique
    perform public.enqueue_notification_to_business_members(
      v_req.business_id,
      'request_message_received',
      'Nouveau message',
      'Un client a envoyé un message.',
      jsonb_build_object('request_id', v_req.id, 'business_id', v_req.business_id),
      v_link
    );
  else
    -- boutique -> client
    perform public.enqueue_notification(
      v_req.customer_user_id,
      v_req.business_id,
      'request_message_received',
      'Nouveau message',
      'La boutique vous a répondu.',
      jsonb_build_object('request_id', v_req.id, 'business_id', v_req.business_id),
      v_link
    );
  end if;

  return new;
end;
$$;

drop trigger if exists notify_request_message_created on public.service_request_messages;

create trigger notify_request_message_created
after insert on public.service_request_messages
for each row execute function public.trg_notify_request_message_created();

=============================================================================================
Request Status Change Notification

create or replace function public.trg_notify_request_status_changed()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_title text;
  v_body  text;
  v_link  text;
begin
  if (new.status is distinct from old.status) then
    v_title := 'Statut de demande mis à jour';
    v_body  := 'Le statut de votre demande a changé.';
    v_link  := '/requests/' || new.id::text;

    perform public.enqueue_notification(
      new.customer_user_id,
      new.business_id,
      'request_status_changed',
      v_title,
      v_body,
      jsonb_build_object(
        'request_id', new.id,
        'business_id', new.business_id,
        'old_status', old.status::text,
        'new_status', new.status::text
      ),
      v_link
    );
  end if;

  return new;
end;
$$;

drop trigger if exists notify_request_status_changed on public.service_requests;

create trigger notify_request_status_changed
after update of status on public.service_requests
for each row execute function public.trg_notify_request_status_changed();

=============================================================================================
Request Creation Notification Trigger

create or replace function public.trg_notify_request_created()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_title text;
  v_body  text;
  v_link  text;
begin
  v_title := 'Nouvelle demande';
  v_body  := 'Une nouvelle demande a été créée.';
  v_link  := '/requests/' || new.id::text;

  perform public.enqueue_notification_to_business_members(
    new.business_id,
    'request_created',
    v_title,
    v_body,
    jsonb_build_object('request_id', new.id, 'business_id', new.business_id),
    v_link
  );

  return new;
end;
$$;

drop trigger if exists notify_request_created on public.service_requests;

create trigger notify_request_created
after insert on public.service_requests
for each row execute function public.trg_notify_request_created();

=============================================================================================
Enqueue In‑App Notifications

-- 1) Notifier un user (création d’une notification in-app)
create or replace function public.enqueue_notification(
  p_user_id uuid,
  p_business_id uuid,
  p_type text,
  p_title text,
  p_body text,
  p_data jsonb default '{}'::jsonb,
  p_deep_link text default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_id uuid;
begin
  insert into public.notifications(user_id, business_id, type, title, body, data, deep_link, status)
  values (p_user_id, p_business_id, p_type, p_title, p_body, coalesce(p_data,'{}'::jsonb), p_deep_link, 'queued')
  returning id into v_id;

  return v_id;
end;
$$;

revoke all on function public.enqueue_notification(uuid, uuid, text, text, text, jsonb, text) from public;
grant execute on function public.enqueue_notification(uuid, uuid, text, text, text, jsonb, text) to authenticated;

-- 2) Notifier tous les membres d’une boutique
create or replace function public.enqueue_notification_to_business_members(
  p_business_id uuid,
  p_type text,
  p_title text,
  p_body text,
  p_data jsonb default '{}'::jsonb,
  p_deep_link text default null
)
returns int
language plpgsql
security definer
set search_path = public
as $$
declare
  r record;
  c int := 0;
begin
  for r in
    select user_id
    from public.business_members
    where business_id = p_business_id
  loop
    perform public.enqueue_notification(r.user_id, p_business_id, p_type, p_title, p_body, p_data, p_deep_link);
    c := c + 1;
  end loop;

  return c;
end;
$$;

revoke all on function public.enqueue_notification_to_business_members(uuid, text, text, text, jsonb, text) from public;
grant execute on function public.enqueue_notification_to_business_members(uuid, text, text, text, jsonb, text) to authenticated;

=============================================================================================
Mark Notification as Read

create or replace function public.mark_notification_read(p_id uuid)
returns void
language plpgsql
security definer
as $$
begin
  update public.notifications
  set read_at = now()
  where id = p_id and user_id = auth.uid();
end;
$$;

revoke all on function public.mark_notification_read(uuid) from public;
grant execute on function public.mark_notification_read(uuid) to authenticated;

=============================================================================================
Notification Deliveries

create type public.delivery_channel as enum ('push','email','sms');

create table if not exists public.notification_deliveries (
  id uuid primary key default gen_random_uuid(),
  notification_id uuid not null references public.notifications(id) on delete cascade,
  channel public.delivery_channel not null,
  provider text not null, -- ex: "fcm"
  provider_message_id text null,
  ok boolean not null default false,
  error text null,
  created_at timestamptz not null default now()
);

create index if not exists notif_deliveries_notification_idx
on public.notification_deliveries(notification_id);

alter table public.notification_deliveries enable row level security;

-- admin/service role only (Edge Functions). Pas d'accès client.

=============================================================================================
User notifications schema

create type public.notification_status as enum ('queued','sent','failed');

create table if not exists public.notifications (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  business_id uuid null, -- si lié à une boutique
  type text not null,    -- ex: "order_created", "message_received"
  title text not null,
  body text not null,
  data jsonb not null default '{}'::jsonb, -- payload (order_id, chat_id, etc.)
  deep_link text null,  -- ex: "pme://orders/123"
  status public.notification_status not null default 'queued',
  created_at timestamptz not null default now(),
  sent_at timestamptz null,
  read_at timestamptz null
);

create index if not exists notifications_user_created_idx
on public.notifications(user_id, created_at desc);

alter table public.notifications enable row level security;

create policy "notifications_select_own"
on public.notifications for select
using (auth.uid() = user_id);

create policy "notifications_update_read_own"
on public.notifications for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

=============================================================================================
User Notification Preferences

create table if not exists public.notification_preferences (
  user_id uuid primary key references auth.users(id) on delete cascade,
  push_enabled boolean not null default true,
  email_enabled boolean not null default true,
  sms_enabled boolean not null default false,
  marketing_enabled boolean not null default false,
  quiet_hours jsonb null, -- ex: {"start":"22:00","end":"07:00","tz":"Africa/Lome"}
  categories jsonb not null default '{}'::jsonb, -- ex: {"orders":true,"messages":true,"payments":true}
  updated_at timestamptz not null default now()
);

alter table public.notification_preferences enable row level security;

create policy "notif_prefs_select_own"
on public.notification_preferences for select
using (auth.uid() = user_id);

create policy "notif_prefs_upsert_own"
on public.notification_preferences for insert
with check (auth.uid() = user_id);

create policy "notif_prefs_update_own"
on public.notification_preferences for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

=============================================================================================
Device tokens table

create table if not exists public.device_tokens (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  token text not null,
  platform text not null check (platform in ('android','ios','web','windows','macos','linux')),
  app_id text null,
  app_version text null,
  device_id text null,
  created_at timestamptz not null default now(),
  last_seen_at timestamptz null,
  revoked_at timestamptz null,
  unique(user_id, token)
);

alter table public.device_tokens enable row level security;

create policy "device_tokens_select_own"
on public.device_tokens for select
using (auth.uid() = user_id);

create policy "device_tokens_upsert_own"
on public.device_tokens for insert
with check (auth.uid() = user_id);

create policy "device_tokens_update_own"
on public.device_tokens for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);
=============================================================================================
Row-level access policies for business members

-- =========================================================
-- 1) Durcissement: exécution de la fonction helper
-- =========================================================
revoke all on function public.is_business_member(uuid, text[]) from public;
grant execute on function public.is_business_member(uuid, text[]) to authenticated;

-- =========================================================
-- 2) businesses: les membres doivent pouvoir lire leur business
-- =========================================================
drop policy if exists "businesses_read_by_member" on public.businesses;
create policy "businesses_read_by_member"
on public.businesses for select
using (
  public.is_business_member(id, array['owner','admin','staff'])
);

-- =========================================================
-- 3) posts: les membres doivent voir aussi les non-publiés
-- =========================================================
drop policy if exists "posts_read_by_member" on public.posts;
create policy "posts_read_by_member"
on public.posts for select
using (
  public.is_business_member(business_id, array['owner','admin','staff'])
);

-- (Optionnel mais utile) permettre update/delete des medias de posts
drop policy if exists "post_media_delete_by_member" on public.post_media;
create policy "post_media_delete_by_member"
on public.post_media for delete
using (
  exists (
    select 1 from public.posts p
    where p.id = post_id
      and public.is_business_member(p.business_id, array['owner','admin','staff'])
  )
);

-- =========================================================
-- 4) products: les membres doivent voir aussi les inactifs
-- =========================================================
drop policy if exists "products_read_by_member" on public.products;
create policy "products_read_by_member"
on public.products for select
using (
  public.is_business_member(business_id, array['owner','admin','staff'])
);

-- =========================================================
-- 5) product_media: policies manquantes (bloquant actuellement)
-- =========================================================
drop policy if exists "product_media_read_public_or_member" on public.product_media;
create policy "product_media_read_public_or_member"
on public.product_media for select
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_id
      and (
        pr.is_active = true
        or public.is_business_member(pr.business_id, array['owner','admin','staff'])
      )
  )
);

drop policy if exists "product_media_insert_by_member" on public.product_media;
create policy "product_media_insert_by_member"
on public.product_media for insert
with check (
  exists (
    select 1
    from public.products pr
    where pr.id = product_id
      and public.is_business_member(pr.business_id, array['owner','admin','staff'])
  )
);

drop policy if exists "product_media_delete_by_member" on public.product_media;
create policy "product_media_delete_by_member"
on public.product_media for delete
using (
  exists (
    select 1
    from public.products pr
    where pr.id = product_id
      and public.is_business_member(pr.business_id, array['owner','admin','staff'])
  )
);

-- =========================================================
-- 6) business_categories: policies manquantes
-- =========================================================
drop policy if exists "business_categories_public_read" on public.business_categories;
create policy "business_categories_public_read"
on public.business_categories for select
using (
  exists (
    select 1 from public.businesses b
    where b.id = business_id and b.is_active = true
  )
);

drop policy if exists "business_categories_write_by_admin" on public.business_categories;
create policy "business_categories_write_by_admin"
on public.business_categories for insert
with check (
  public.is_business_member(business_id, array['owner','admin'])
);

drop policy if exists "business_categories_delete_by_admin" on public.business_categories;
create policy "business_categories_delete_by_admin"
on public.business_categories for delete
using (
  public.is_business_member(business_id, array['owner','admin'])
);

=============================================================================================
Business row-level security and helper functions

-- 1) Extrait le business_id du chemin storage "<business_uuid>/fichier.png"
create or replace function public.object_business_id(object_name text)
returns uuid
language sql
stable
as $$
  select nullif(split_part(object_name, '/', 1), '')::uuid
$$;

-- 2) Vérifie si l'utilisateur courant est owner/admin de ce business
create or replace function public.is_business_owner(biz_id uuid)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.business_members bm
    where bm.business_id = biz_id
      and bm.user_id = auth.uid()
      and bm.role in ('owner','admin')
  )
$$;

-- 3) RLS business_members: l'utilisateur peut lire ses memberships (utile pour is_business_owner)
alter table public.business_members enable row level security;

drop policy if exists "members_select_own" on public.business_members;
create policy "members_select_own"
on public.business_members for select
to authenticated
using (user_id = auth.uid());

-- 4) RLS businesses: owner/admin peut UPDATE (logo_path, cover_path, infos)
alter table public.businesses enable row level security;

drop policy if exists "businesses_select_member" on public.businesses;
create policy "businesses_select_member"
on public.businesses for select
to authenticated
using (
  exists (
    select 1
    from public.business_members bm
    where bm.business_id = businesses.id
      and bm.user_id = auth.uid()
  )
);

drop policy if exists "businesses_update_owner" on public.businesses;
create policy "businesses_update_owner"
on public.businesses for update
to authenticated
using (public.is_business_owner(businesses.id))
with check (public.is_business_owner(businesses.id));

=============================================================================================
Business owner RLS for storage objects and businesses

create or replace function public.try_uuid(p text)
returns uuid
language plpgsql
stable
as $$
begin
  return p::uuid;
exception when others then
  return null;
end;
$$;

create or replace function public.object_business_id(object_name text)
returns uuid
language sql
stable
as $$
  select public.try_uuid(split_part(object_name, '/', 1));
$$;

create or replace function public.is_business_owner(biz_id uuid)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.business_members bm
    where bm.business_id = biz_id
      and bm.user_id = auth.uid()
      and bm.role = 'owner'
  );
$$;

-- Important: autoriser l'exécution des fonctions dans les policies
grant execute on function public.try_uuid(text) to anon, authenticated;
grant execute on function public.object_business_id(text) to anon, authenticated;
grant execute on function public.is_business_owner(uuid) to anon, authenticated;

alter table storage.objects enable row level security;

drop policy if exists "read business_logos" on storage.objects;
create policy "read business_logos"
on storage.objects for select to anon, authenticated
using (bucket_id = 'business_logos');

drop policy if exists "read business_covers" on storage.objects;
create policy "read business_covers"
on storage.objects for select to anon, authenticated
using (bucket_id = 'business_covers');

drop policy if exists "insert business_logos" on storage.objects;
create policy "insert business_logos"
on storage.objects for insert to authenticated
with check (
  bucket_id = 'business_logos'
  and public.is_business_owner(public.object_business_id(name))
);

drop policy if exists "insert business_covers" on storage.objects;
create policy "insert business_covers"
on storage.objects for insert to authenticated
with check (
  bucket_id = 'business_covers'
  and public.is_business_owner(public.object_business_id(name))
);

drop policy if exists "update business_logos" on storage.objects;
create policy "update business_logos"
on storage.objects for update to authenticated
using (
  bucket_id = 'business_logos'
  and public.is_business_owner(public.object_business_id(name))
)
with check (
  bucket_id = 'business_logos'
  and public.is_business_owner(public.object_business_id(name))
);

drop policy if exists "update business_covers" on storage.objects;
create policy "update business_covers"
on storage.objects for update to authenticated
using (
  bucket_id = 'business_covers'
  and public.is_business_owner(public.object_business_id(name))
)
with check (
  bucket_id = 'business_covers'
  and public.is_business_owner(public.object_business_id(name))
);

drop policy if exists "delete business_logos" on storage.objects;
create policy "delete business_logos"
on storage.objects for delete to authenticated
using (
  bucket_id = 'business_logos'
  and public.is_business_owner(public.object_business_id(name))
);

drop policy if exists "delete business_covers" on storage.objects;
create policy "delete business_covers"
on storage.objects for delete to authenticated
using (
  bucket_id = 'business_covers'
  and public.is_business_owner(public.object_business_id(name))
);

alter table public.businesses enable row level security;

drop policy if exists "business owners select" on public.businesses;
create policy "business owners select"
on public.businesses for select to authenticated
using (public.is_business_owner(id));

drop policy if exists "business owners update" on public.businesses;
create policy "business owners update"
on public.businesses for update to authenticated
using (public.is_business_owner(id))
with check (public.is_business_owner(id));

=============================================================================================
pmetpe_storage_policies

-- Ensure RLS enabled (usually already)
alter table storage.objects enable row level security;

-- Helper: access check for request attachments
create or replace function public.can_access_request(rid uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.service_requests r
    where r.id = rid
      and (
        r.customer_user_id = auth.uid()
        or public.is_business_member(r.business_id, array['owner','admin','staff'])
      )
  );
$$;

-- 1) Public read for public buckets
drop policy if exists "public_read_public_buckets" on storage.objects;
create policy "public_read_public_buckets"
on storage.objects for select
using (bucket_id in ('business_logos','business_covers','post_media','product_media'));

-- 2) Write to public buckets only by business members (business_id must be first path segment)
drop policy if exists "write_public_buckets_by_member" on storage.objects;
create policy "write_public_buckets_by_member"
on storage.objects for insert to authenticated
with check (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
);

drop policy if exists "update_public_buckets_by_member" on storage.objects;
create policy "update_public_buckets_by_member"
on storage.objects for update to authenticated
using (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
)
with check (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
);

drop policy if exists "delete_public_buckets_by_member" on storage.objects;
create policy "delete_public_buckets_by_member"
on storage.objects for delete to authenticated
using (
  bucket_id in ('business_logos','business_covers','post_media','product_media')
  and public.is_business_member(
    public.try_uuid(split_part(name,'/',1)),
    array['owner','admin','staff']
  )
);

-- 3) request_attachments: private, only request participants (customer or business members)
drop policy if exists "read_request_attachments" on storage.objects;
create policy "read_request_attachments"
on storage.objects for select to authenticated
using (
  bucket_id = 'request_attachments'
  and public.can_access_request(public.try_uuid(split_part(name,'/',1)))
);

drop policy if exists "write_request_attachments" on storage.objects;
create policy "write_request_attachments"
on storage.objects for insert to authenticated
with check (
  bucket_id = 'request_attachments'
  and public.can_access_request(public.try_uuid(split_part(name,'/',1)))
);

drop policy if exists "update_request_attachments" on storage.objects;
create policy "update_request_attachments"
on storage.objects for update to authenticated
using (
  bucket_id = 'request_attachments'
  and public.can_access_request(public.try_uuid(split_part(name,'/',1)))
)
with check (
  bucket_id = 'request_attachments'
  and public.can_access_request(public.try_uuid(split_part(name,'/',1)))
);

drop policy if exists "delete_request_attachments" on storage.objects;
create policy "delete_request_attachments"
on storage.objects for delete to authenticated
using (
  bucket_id = 'request_attachments'
  and public.can_access_request(public.try_uuid(split_part(name,'/',1)))
);

=============================================================================================
pmetpe_supab

-- =========================
-- Extensions
-- =========================
create extension if not exists "pgcrypto";
create extension if not exists "postgis";

-- =========================
-- Helper: updated_at trigger
-- =========================
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- =========================
-- Enums
-- =========================
do $$ begin
  create type public.member_role as enum ('owner','admin','staff');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.request_type as enum ('catalog','freeform');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.request_status as enum ('new','accepted','rejected','in_progress','delivered','closed','cancelled');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.subscription_provider as enum ('google_play','cinetpay','fedapay','manual');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.subscription_status as enum ('active','past_due','cancelled','expired','trialing');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.campaign_status as enum ('draft','running','paused','ended','rejected');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.campaign_objective as enum ('boost_post','promote_business','promote_product');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.report_status as enum ('open','reviewing','resolved','rejected');
exception when duplicate_object then null; end $$;

-- =========================
-- Profiles (linked to auth.users)
-- =========================
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  phone text,
  photo_url text,
  locale text default 'fr',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

-- =========================
-- Categories
-- =========================
create table if not exists public.categories (
  id uuid primary key default gen_random_uuid(),
  name text not null unique,
  created_at timestamptz not null default now()
);

-- =========================
-- Businesses (mini-site entreprise)
-- =========================
create table if not exists public.businesses (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  slug text not null unique,
  description text,
  logo_path text,
  cover_path text,

  whatsapp_phone text,        -- lien WhatsApp / numéro
  address_text text,
  location geography(point, 4326), -- maps / proximité

  is_active boolean not null default true,
  is_verified boolean not null default false,

  created_by uuid not null references auth.users(id) on delete restrict,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_businesses_active on public.businesses(is_active);
create index if not exists idx_businesses_location on public.businesses using gist(location);

drop trigger if exists trg_businesses_updated_at on public.businesses;
create trigger trg_businesses_updated_at
before update on public.businesses
for each row execute function public.set_updated_at();

-- Businesses ↔ Categories (many-to-many)
create table if not exists public.business_categories (
  business_id uuid not null references public.businesses(id) on delete cascade,
  category_id uuid not null references public.categories(id) on delete restrict,
  primary key (business_id, category_id)
);

-- Members (who can manage a business)
create table if not exists public.business_members (
  business_id uuid not null references public.businesses(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role public.member_role not null default 'staff',
  created_at timestamptz not null default now(),
  primary key (business_id, user_id)
);

create index if not exists idx_business_members_user on public.business_members(user_id);

-- =========================
-- Posts (social feed)
-- =========================
create table if not exists public.posts (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  author_user_id uuid not null references auth.users(id) on delete restrict,

  title text,
  content text,
  is_published boolean not null default true,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_posts_business_created on public.posts(business_id, created_at desc);
create index if not exists idx_posts_published_created on public.posts(is_published, created_at desc);

drop trigger if exists trg_posts_updated_at on public.posts;
create trigger trg_posts_updated_at
before update on public.posts
for each row execute function public.set_updated_at();

create table if not exists public.post_media (
  id uuid primary key default gen_random_uuid(),
  post_id uuid not null references public.posts(id) on delete cascade,
  media_type text not null check (media_type in ('image','video','pdf')),
  storage_path text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_post_media_post on public.post_media(post_id);

create table if not exists public.post_likes (
  post_id uuid not null references public.posts(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (post_id, user_id)
);

create table if not exists public.post_comments (
  id uuid primary key default gen_random_uuid(),
  post_id uuid not null references public.posts(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  parent_id uuid references public.post_comments(id) on delete cascade,
  content text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_post_comments_post_created on public.post_comments(post_id, created_at);

-- =========================
-- Products/Services (catalog)
-- =========================
create table if not exists public.products (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,

  title text not null,
  description text,
  price_amount numeric(12,2),
  currency text default 'XOF',
  is_active boolean not null default true,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_products_business_active on public.products(business_id, is_active);

drop trigger if exists trg_products_updated_at on public.products;
create trigger trg_products_updated_at
before update on public.products
for each row execute function public.set_updated_at();

create table if not exists public.product_media (
  id uuid primary key default gen_random_uuid(),
  product_id uuid not null references public.products(id) on delete cascade,
  media_type text not null check (media_type in ('image','video','pdf')),
  storage_path text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_product_media_product on public.product_media(product_id);

-- =========================
-- Service Requests / Orders (demandes livrables)
-- =========================
create table if not exists public.service_requests (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  customer_user_id uuid not null references auth.users(id) on delete restrict,

  type public.request_type not null default 'freeform',
  status public.request_status not null default 'new',

  address_text text,
  location geography(point, 4326),
  notes text,

  total_estimate numeric(12,2),
  currency text default 'XOF',

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_requests_business_created on public.service_requests(business_id, created_at desc);
create index if not exists idx_requests_customer_created on public.service_requests(customer_user_id, created_at desc);
create index if not exists idx_requests_location on public.service_requests using gist(location);

drop trigger if exists trg_requests_updated_at on public.service_requests;
create trigger trg_requests_updated_at
before update on public.service_requests
for each row execute function public.set_updated_at();

create table if not exists public.service_request_items (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  product_id uuid references public.products(id) on delete set null,
  title_snapshot text,
  qty int not null default 1 check (qty > 0),
  unit_price_snapshot numeric(12,2),
  created_at timestamptz not null default now()
);

create index if not exists idx_request_items_request on public.service_request_items(request_id);

create table if not exists public.service_request_messages (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  sender_user_id uuid not null references auth.users(id) on delete cascade,
  message text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_request_messages_request_created on public.service_request_messages(request_id, created_at);

create table if not exists public.service_request_attachments (
  id uuid primary key default gen_random_uuid(),
  request_id uuid not null references public.service_requests(id) on delete cascade,
  storage_path text not null,
  created_at timestamptz not null default now()
);

-- =========================
-- Plans / Entitlements / Subscriptions / Payments
-- =========================
create table if not exists public.plans (
  id uuid primary key default gen_random_uuid(),
  code text not null unique check (code in ('free','pro','premium')),
  name text not null,
  description text,
  monthly_price_amount numeric(12,2),
  currency text default 'XOF',
  created_at timestamptz not null default now()
);

-- Entitlements are the source of truth for feature access.
create table if not exists public.entitlements (
  business_id uuid primary key references public.businesses(id) on delete cascade,
  plan_id uuid not null references public.plans(id) on delete restrict,

  visibility_multiplier numeric(6,2) not null default 1.00,
  can_receive_orders boolean not null default false,
  can_run_ads boolean not null default false,

  monthly_order_limit int,
  monthly_ad_budget_limit numeric(12,2),

  boosted_until timestamptz,

  updated_at timestamptz not null default now()
);

drop trigger if exists trg_entitlements_updated_at on public.entitlements;
create trigger trg_entitlements_updated_at
before update on public.entitlements
for each row execute function public.set_updated_at();

create table if not exists public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  provider public.subscription_provider not null,
  status public.subscription_status not null default 'active',

  provider_customer_id text,
  provider_subscription_id text,
  product_id text, -- e.g. Play Billing productId / offerId

  current_period_start timestamptz,
  current_period_end timestamptz,

  last_verified_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_subscriptions_business on public.subscriptions(business_id, status);

drop trigger if exists trg_subscriptions_updated_at on public.subscriptions;
create trigger trg_subscriptions_updated_at
before update on public.subscriptions
for each row execute function public.set_updated_at();

create table if not exists public.payments (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,
  provider public.subscription_provider not null,

  amount numeric(12,2) not null,
  currency text not null default 'XOF',
  status text not null check (status in ('pending','paid','failed','refunded')),

  external_ref text, -- transaction id from PSP
  metadata jsonb not null default '{}'::jsonb,

  created_at timestamptz not null default now()
);

create index if not exists idx_payments_business_created on public.payments(business_id, created_at desc);

-- =========================
-- Ads (campaigns + creatives + daily stats)
-- =========================
create table if not exists public.ad_campaigns (
  id uuid primary key default gen_random_uuid(),
  business_id uuid not null references public.businesses(id) on delete cascade,

  objective public.campaign_objective not null,
  status public.campaign_status not null default 'draft',

  daily_budget numeric(12,2) not null default 0,
  currency text not null default 'XOF',

  start_at timestamptz,
  end_at timestamptz,

  -- targeting (MVP)
  target_category_id uuid references public.categories(id) on delete set null,
  target_radius_km int,
  target_center geography(point, 4326),

  -- creative reference (MVP)
  post_id uuid references public.posts(id) on delete set null,
  product_id uuid references public.products(id) on delete set null,
  headline text,
  call_to_action text,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_campaigns_business_status on public.ad_campaigns(business_id, status);
create index if not exists idx_campaigns_target_center on public.ad_campaigns using gist(target_center);

drop trigger if exists trg_campaigns_updated_at on public.ad_campaigns;
create trigger trg_campaigns_updated_at
before update on public.ad_campaigns
for each row execute function public.set_updated_at();

create table if not exists public.ad_stats_daily (
  campaign_id uuid not null references public.ad_campaigns(id) on delete cascade,
  day date not null,
  impressions int not null default 0,
  clicks int not null default 0,
  spend numeric(12,2) not null default 0,
  primary key (campaign_id, day)
);

-- =========================
-- Moderation / Reports / Audit
-- =========================
create table if not exists public.reports (
  id uuid primary key default gen_random_uuid(),
  reporter_user_id uuid not null references auth.users(id) on delete cascade,

  content_type text not null check (content_type in ('business','post','comment')),
  content_id uuid not null,

  reason text,
  status public.report_status not null default 'open',

  created_at timestamptz not null default now()
);

create index if not exists idx_reports_status_created on public.reports(status, created_at desc);

create table if not exists public.audit_logs (
  id uuid primary key default gen_random_uuid(),
  actor_user_id uuid references auth.users(id) on delete set null,
  action text not null,
  entity_type text not null,
  entity_id uuid,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index if not exists idx_audit_created on public.audit_logs(created_at desc);

-- =========================
-- RLS Enable
-- =========================
alter table public.profiles enable row level security;
alter table public.categories enable row level security;
alter table public.businesses enable row level security;
alter table public.business_categories enable row level security;
alter table public.business_members enable row level security;
alter table public.posts enable row level security;
alter table public.post_media enable row level security;
alter table public.post_likes enable row level security;
alter table public.post_comments enable row level security;
alter table public.products enable row level security;
alter table public.product_media enable row level security;
alter table public.service_requests enable row level security;
alter table public.service_request_items enable row level security;
alter table public.service_request_messages enable row level security;
alter table public.service_request_attachments enable row level security;
alter table public.plans enable row level security;
alter table public.entitlements enable row level security;
alter table public.subscriptions enable row level security;
alter table public.payments enable row level security;
alter table public.ad_campaigns enable row level security;
alter table public.ad_stats_daily enable row level security;
alter table public.reports enable row level security;
alter table public.audit_logs enable row level security;

-- =========================
-- RLS helper: is_member(business_id, roles[])
-- Security definer so it can read membership table safely.
-- =========================
create or replace function public.is_business_member(bid uuid, roles text[])
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.business_members bm
    where bm.business_id = bid
      and bm.user_id = auth.uid()
      and bm.role::text = any(roles)
  );
$$;

-- =========================
-- RLS Policies
-- =========================

-- profiles: each user reads/updates own profile
drop policy if exists "profiles_select_own" on public.profiles;
create policy "profiles_select_own"
on public.profiles for select
using (user_id = auth.uid());

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles for update
using (user_id = auth.uid())
with check (user_id = auth.uid());

drop policy if exists "profiles_insert_own" on public.profiles;
create policy "profiles_insert_own"
on public.profiles for insert
with check (user_id = auth.uid());

-- categories: readable by everyone (public), writable only by service role/admin (MVP: disable writes)
drop policy if exists "categories_public_read" on public.categories;
create policy "categories_public_read"
on public.categories for select
using (true);

-- businesses: public read if active; write if member owner/admin
drop policy if exists "businesses_public_read" on public.businesses;
create policy "businesses_public_read"
on public.businesses for select
using (is_active = true);

drop policy if exists "businesses_insert_owner" on public.businesses;
create policy "businesses_insert_owner"
on public.businesses for insert
with check (created_by = auth.uid());

drop policy if exists "businesses_update_by_member" on public.businesses;
create policy "businesses_update_by_member"
on public.businesses for update
using (public.is_business_member(id, array['owner','admin']))
with check (public.is_business_member(id, array['owner','admin']));

-- business_members: member can read members of a business; only owner/admin can manage
drop policy if exists "members_read_by_member" on public.business_members;
create policy "members_read_by_member"
on public.business_members for select
using (public.is_business_member(business_id, array['owner','admin','staff']));

drop policy if exists "members_write_by_admin" on public.business_members;
create policy "members_write_by_admin"
on public.business_members for insert
with check (public.is_business_member(business_id, array['owner','admin']));

drop policy if exists "members_update_by_admin" on public.business_members;
create policy "members_update_by_admin"
on public.business_members for update
using (public.is_business_member(business_id, array['owner']))
with check (public.is_business_member(business_id, array['owner']));

drop policy if exists "members_delete_by_owner" on public.business_members;
create policy "members_delete_by_owner"
on public.business_members for delete
using (public.is_business_member(business_id, array['owner']));

-- posts: public read if published; create/update only by business member
drop policy if exists "posts_public_read" on public.posts;
create policy "posts_public_read"
on public.posts for select
using (is_published = true);

drop policy if exists "posts_insert_by_member" on public.posts;
create policy "posts_insert_by_member"
on public.posts for insert
with check (
  public.is_business_member(business_id, array['owner','admin','staff'])
  and author_user_id = auth.uid()
);

drop policy if exists "posts_update_by_member" on public.posts;
create policy "posts_update_by_member"
on public.posts for update
using (public.is_business_member(business_id, array['owner','admin','staff']))
with check (public.is_business_member(business_id, array['owner','admin','staff']));

-- post_media: readable if parent post readable; writable by members
drop policy if exists "post_media_read_if_post_public" on public.post_media;
create policy "post_media_read_if_post_public"
on public.post_media for select
using (
  exists (
    select 1 from public.posts p
    where p.id = post_id and p.is_published = true
  )
);

drop policy if exists "post_media_write_by_member" on public.post_media;
create policy "post_media_write_by_member"
on public.post_media for insert
with check (
  exists (
    select 1 from public.posts p
    where p.id = post_id
      and public.is_business_member(p.business_id, array['owner','admin','staff'])
  )
);

-- likes/comments: public read; write by authenticated users
drop policy if exists "likes_public_read" on public.post_likes;
create policy "likes_public_read"
on public.post_likes for select
using (true);

drop policy if exists "likes_insert_auth" on public.post_likes;
create policy "likes_insert_auth"
on public.post_likes for insert
with check (user_id = auth.uid());

drop policy if exists "likes_delete_own" on public.post_likes;
create policy "likes_delete_own"
on public.post_likes for delete
using (user_id = auth.uid());

drop policy if exists "comments_public_read" on public.post_comments;
create policy "comments_public_read"
on public.post_comments for select
using (true);

drop policy if exists "comments_insert_auth" on public.post_comments;
create policy "comments_insert_auth"
on public.post_comments for insert
with check (user_id = auth.uid());

drop policy if exists "comments_delete_own" on public.post_comments;
create policy "comments_delete_own"
on public.post_comments for delete
using (user_id = auth.uid());

-- products: public read if active; write by business member
drop policy if exists "products_public_read" on public.products;
create policy "products_public_read"
on public.products for select
using (is_active = true);

drop policy if exists "products_write_by_member" on public.products;
create policy "products_write_by_member"
on public.products for insert
with check (public.is_business_member(business_id, array['owner','admin','staff']));

drop policy if exists "products_update_by_member" on public.products;
create policy "products_update_by_member"
on public.products for update
using (public.is_business_member(business_id, array['owner','admin','staff']))
with check (public.is_business_member(business_id, array['owner','admin','staff']));

-- service_requests:
-- - customer can create and read own
-- - business members can read and update requests for their business
drop policy if exists "requests_insert_customer" on public.service_requests;
create policy "requests_insert_customer"
on public.service_requests for insert
with check (customer_user_id = auth.uid());

drop policy if exists "requests_read_customer_or_business" on public.service_requests;
create policy "requests_read_customer_or_business"
on public.service_requests for select
using (
  customer_user_id = auth.uid()
  or public.is_business_member(business_id, array['owner','admin','staff'])
);

drop policy if exists "requests_update_business_only" on public.service_requests;
create policy "requests_update_business_only"
on public.service_requests for update
using (public.is_business_member(business_id, array['owner','admin','staff']))
with check (public.is_business_member(business_id, array['owner','admin','staff']));

-- request items/messages/attachments: inherit access from request
drop policy if exists "req_items_read" on public.service_request_items;
create policy "req_items_read"
on public.service_request_items for select
using (
  exists (
    select 1 from public.service_requests r
    where r.id = request_id
      and (r.customer_user_id = auth.uid()
           or public.is_business_member(r.business_id, array['owner','admin','staff']))
  )
);

drop policy if exists "req_items_insert" on public.service_request_items;
create policy "req_items_insert"
on public.service_request_items for insert
with check (
  exists (
    select 1 from public.service_requests r
    where r.id = request_id
      and r.customer_user_id = auth.uid()
  )
);

drop policy if exists "req_msgs_read" on public.service_request_messages;
create policy "req_msgs_read"
on public.service_request_messages for select
using (
  exists (
    select 1 from public.service_requests r
    where r.id = request_id
      and (r.customer_user_id = auth.uid()
           or public.is_business_member(r.business_id, array['owner','admin','staff']))
  )
);

drop policy if exists "req_msgs_insert" on public.service_request_messages;
create policy "req_msgs_insert"
on public.service_request_messages for insert
with check (
  sender_user_id = auth.uid()
  and exists (
    select 1 from public.service_requests r
    where r.id = request_id
      and (r.customer_user_id = auth.uid()
           or public.is_business_member(r.business_id, array['owner','admin','staff']))
  )
);

drop policy if exists "req_att_read" on public.service_request_attachments;
create policy "req_att_read"
on public.service_request_attachments for select
using (
  exists (
    select 1 from public.service_requests r
    where r.id = request_id
      and (r.customer_user_id = auth.uid()
           or public.is_business_member(r.business_id, array['owner','admin','staff']))
  )
);

drop policy if exists "req_att_insert" on public.service_request_attachments;
create policy "req_att_insert"
on public.service_request_attachments for insert
with check (
  exists (
    select 1 from public.service_requests r
    where r.id = request_id
      and r.customer_user_id = auth.uid()
  )
);

-- plans: public read
drop policy if exists "plans_public_read" on public.plans;
create policy "plans_public_read"
on public.plans for select
using (true);

-- entitlements/subscriptions/payments/campaigns/stats: business members read; writes only by admin processes (service role) or business admin
-- MVP: allow business owner/admin to read; writes to be done via Edge Functions
drop policy if exists "entitlements_read_by_business" on public.entitlements;
create policy "entitlements_read_by_business"
on public.entitlements for select
using (public.is_business_member(business_id, array['owner','admin','staff']));

drop policy if exists "subs_read_by_business" on public.subscriptions;
create policy "subs_read_by_business"
on public.subscriptions for select
using (public.is_business_member(business_id, array['owner','admin']));

drop policy if exists "payments_read_by_business" on public.payments;
create policy "payments_read_by_business"
on public.payments for select
using (public.is_business_member(business_id, array['owner','admin']));

drop policy if exists "campaigns_read_by_business" on public.ad_campaigns;
create policy "campaigns_read_by_business"
on public.ad_campaigns for select
using (public.is_business_member(business_id, array['owner','admin','staff']));

drop policy if exists "campaigns_write_by_admin" on public.ad_campaigns;
create policy "campaigns_write_by_admin"
on public.ad_campaigns for insert
with check (public.is_business_member(business_id, array['owner','admin']));

drop policy if exists "campaigns_update_by_admin" on public.ad_campaigns;
create policy "campaigns_update_by_admin"
on public.ad_campaigns for update
using (public.is_business_member(business_id, array['owner','admin']))
with check (public.is_business_member(business_id, array['owner','admin']));

drop policy if exists "ad_stats_read_by_business" on public.ad_stats_daily;
create policy "ad_stats_read_by_business"
on public.ad_stats_daily for select
using (
  exists (
    select 1 from public.ad_campaigns c
    where c.id = campaign_id
      and public.is_business_member(c.business_id, array['owner','admin','staff'])
  )
);

-- reports: authenticated users can create; only admins resolve (MVP: create only)
drop policy if exists "reports_insert_auth" on public.reports;
create policy "reports_insert_auth"
on public.reports for insert
with check (reporter_user_id = auth.uid());

drop policy if exists "reports_read_own" on public.reports;
create policy "reports_read_own"
on public.reports for select
using (reporter_user_id = auth.uid());

-- audit_logs: not readable by clients (MVP)
insert into public.plans (code, name, description, monthly_price_amount, currency)
values
('free','Free','Profil entreprise + posts', 0, 'XOF'),
('pro','Pro','Visibilité accrue + commandes/demandes', null, 'XOF'),
('premium','Premium','Ads + maximum visibilité', null, 'XOF')
on conflict (code) do nothing;
=============================================================================================
C'est fini avec les SQL (Ils sont rangé du plus recemment exécuté jusqu'au plus nouvellement exécuté)

=============================================================================================
Les Codes (Dans VScode)
=============================================================================================

D:\Dev\PME_TPE\PME_TPE\lib\core\auth\google_oauth_io.dart

import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

const int _loopbackPort = 3000;
const String _callbackPath = '/auth/callback';

Future<void> signInWithGoogleUnified() async {
  if (!(Platform.isWindows || Platform.isMacOS || Platform.isLinux)) {
    // Pour Android/iOS on fera un flow deep-link (différent).
    throw UnsupportedError('OAuth desktop uniquement (Windows/macOS/Linux).');
  }

  final sb = Supabase.instance.client;

  // Important: 127.0.0.1 évite les soucis IPv6 (localhost -> ::1)
  final redirectTo = 'http://127.0.0.1:$_loopbackPort$_callbackPath';

  HttpServer? server;
  final completer = Completer<Uri>();

  try {
    server = await HttpServer.bind(InternetAddress.loopbackIPv4, _loopbackPort);

    server.listen((HttpRequest req) async {
      try {
        if (req.uri.path != _callbackPath) {
          req.response.statusCode = 404;
          await req.response.close();
          return;
        }

        // Reconstituer une URI complète (host/scheme/port)
        final fullUri = Uri(
          scheme: 'http',
          host: '127.0.0.1',
          port: _loopbackPort,
          path: req.uri.path,
          query: req.uri.query,
        );

        // Répondre au navigateur (page simple)
        req.response.headers.contentType = ContentType.html;
        req.response.write('''
<!doctype html>
<html>
  <body>
    <h3>Connexion terminée.</h3>
    <p>Tu peux fermer cet onglet et revenir à l’application.</p>
  </body>
</html>
''');
        await req.response.close();

        if (!completer.isCompleted) completer.complete(fullUri);
      } catch (e) {
        if (!completer.isCompleted) completer.completeError(e);
      }
    });

    // Lance OAuth
    await sb.auth.signInWithOAuth(OAuthProvider.google, redirectTo: redirectTo);

    // Attendre le retour navigateur
    final callbackUri = await completer.future.timeout(
      const Duration(minutes: 2),
      onTimeout: () =>
          throw TimeoutException('OAuth timeout (pas de callback).'),
    );

    debugPrint('OAuth callback: $callbackUri');

    // Échange + création session
    await sb.auth.getSessionFromUrl(callbackUri);

    // À partir d’ici, session disponible -> ton GoRouter redirige vers /home
  } finally {
    try {
      await server?.close(force: true);
    } catch (_) {
      // ignore
    }
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\auth\google_oauth_stub.dart

Future<void> signInWithGoogleUnified() async {
  throw UnsupportedError('Plateforme non supportée pour OAuth.');
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\auth\google_oauth_web.dart

import 'package:supabase_flutter/supabase_flutter.dart';

Future<void> signInWithGoogleUnified() async {
  // Web: retourne sur /auth/callback (ta page AuthCallbackPage)
  final redirectTo = '${Uri.base.origin}/auth/callback';

  await Supabase.instance.client.auth.signInWithOAuth(
    OAuthProvider.google,
    redirectTo: redirectTo,
  );
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\auth\google_oauth.dart

export 'google_oauth_stub.dart'
    if (dart.library.html) 'google_oauth_web.dart'
    if (dart.library.io) 'google_oauth_io.dart';

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\data\data_exceptions.dart

import 'package:supabase_flutter/supabase_flutter.dart';

class DataException implements Exception {
  final String message;
  final Object? raw;
  DataException(this.message, {this.raw});

  @override
  String toString() => 'DataException(message: $message, raw: $raw)';
}

DataException mapSupabaseError(Object e) {
  if (e is PostgrestException) return DataException(e.message, raw: e);
  if (e is AuthException) return DataException(e.message, raw: e);
  return DataException(e.toString(), raw: e);
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\data\providers.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/business/data/business_repository.dart';

final businessRepositoryProvider = Provider<BusinessRepository>((ref) {
  return BusinessRepository();
});
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\notifications\push_service.dart

import 'dart:io' show Platform;
import 'package:device_info_plus/device_info_plus.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../env.dart';

class NotificationService {
  NotificationService._();

  static final FlutterLocalNotificationsPlugin _local =
      FlutterLocalNotificationsPlugin();

  // Web VAPID key: use value from compile-time defines if present.
  // Keep non-const so we can read from `Env`.
  static String webVapidKey = Env.fcmVapidKey;

  /// Handler background: doit être top-level / static.
  @pragma('vm:entry-point')
  static Future<void> firebaseMessagingBackgroundHandler(
      RemoteMessage message) async {
    // Initialiser Firebase dans l’isolate background
    await Firebase.initializeApp();

    // Optionnel: si tu veux logger dans Supabase via HTTP/Edge Function (éviter supabase client direct ici)
    // Ici on ne fait que laisser FCM afficher (ou service worker côté Web).
  }

  static Future<void> init() async {
    // 1) Local notifications init
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosInit = DarwinInitializationSettings();

    const initSettings = InitializationSettings(
      android: androidInit,
      iOS: iosInit,
    );

    await _local.initialize(
      initSettings,
      onDidReceiveNotificationResponse: (resp) {
        // payload optionnel
      },
    );

    // 2) Background handler
    FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

    // 3) iOS: comment afficher en foreground (sinon silence)
    await FirebaseMessaging.instance.setForegroundNotificationPresentationOptions(
      alert: true,
      badge: true,
      sound: true,
    ); // :contentReference[oaicite:7]{index=7}

    // 4) Listeners runtime
    FirebaseMessaging.onMessage.listen(_onForegroundMessage); // :contentReference[oaicite:8]{index=8}
    FirebaseMessaging.onMessageOpenedApp.listen(_onMessageOpenedApp); // :contentReference[oaicite:9]{index=9}

    // 5) Cold start: app ouverte depuis notif
    final initialMsg = await FirebaseMessaging.instance.getInitialMessage();
    if (initialMsg != null) {
      _handleDeepLinkFromMessage(initialMsg);
    }

    // 6) Token refresh
    FirebaseMessaging.instance.onTokenRefresh.listen((token) async {
      await upsertCurrentUserToken(token: token);
    });
  }

  static Future<void> requestPermissionAndSyncToken() async {
    final settings = await FirebaseMessaging.instance.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    ); // :contentReference[oaicite:10]{index=10}

    // Même si refus, on sort proprement
    if (settings.authorizationStatus == AuthorizationStatus.denied) return;

    String? token;
    if (kIsWeb) {
      try {
        if (webVapidKey.isEmpty) {
          // No VAPID key configured for web; skip requesting a token.
          debugPrint('FCM web VAPID key not provided; skipping getToken.');
          token = null;
        } else {
          token = await FirebaseMessaging.instance.getToken(vapidKey: webVapidKey);
        }
      } catch (e) {
        debugPrint('Failed to get web token with provided VAPID key: $e');
        token = null;
      }
      // Web: VAPID nécessaire :contentReference[oaicite:11]{index=11}
    } else {
      token = await FirebaseMessaging.instance.getToken();
    }

    if (token != null) {
      await upsertCurrentUserToken(token: token);
    }
  }

  static Future<void> upsertCurrentUserToken({required String token}) async {
    final user = Supabase.instance.client.auth.currentUser;
    if (user == null) return;

    final platform = _platformString();
    final pkg = await PackageInfo.fromPlatform();
    final deviceId = await _deviceIdSafe();

    await Supabase.instance.client.from('device_tokens').upsert(
      {
        'user_id': user.id,
        'token': token,
        'platform': platform,
        'app_id': pkg.packageName,
        'app_version': pkg.version,
        'device_id': deviceId,
        'last_seen_at': DateTime.now().toIso8601String(),
        'revoked_at': null,
      },
      // Requiert UNIQUE(token) côté DB
      onConflict: 'token',
    );
  }

  static Future<void> revokeCurrentToken() async {
    final user = Supabase.instance.client.auth.currentUser;
    if (user == null) return;

    final token = await FirebaseMessaging.instance.getToken(
      vapidKey: kIsWeb ? webVapidKey : null,
    );

    if (token == null) return;

    await Supabase.instance.client
        .from('device_tokens')
        .update({'revoked_at': DateTime.now().toIso8601String()})
        .eq('user_id', user.id)
        .eq('token', token);
  }

  static Future<void> _onForegroundMessage(RemoteMessage msg) async {
    // En foreground, Android ne montre pas toujours la notif système => on force une notif locale.
    final title = msg.notification?.title ?? 'Notification';
    final body = msg.notification?.body ?? '';

    const androidDetails = AndroidNotificationDetails(
      'default_channel',
      'General',
      importance: Importance.max,
      priority: Priority.high,
    );

    const details = NotificationDetails(android: androidDetails);

    await _local.show(
      DateTime.now().millisecondsSinceEpoch ~/ 1000,
      title,
      body,
      details,
      payload: msg.data['deep_link'] as String?,
    );
  }

  static Future<void> _onMessageOpenedApp(RemoteMessage msg) async {
    _handleDeepLinkFromMessage(msg);
  }

  static void _handleDeepLinkFromMessage(RemoteMessage msg) {
    final deepLink = msg.data['deep_link']?.toString();
    if (deepLink == null || deepLink.isEmpty) return;

    // Ici: branche sur ton routeur (go_router, Navigator, etc.)
    // Exemple: app://notifications/123  ou  /notifications/123
    // TODO: implémenter navigation
  }

  static String _platformString() {
    if (kIsWeb) return 'web';
    if (Platform.isAndroid) return 'android';
    if (Platform.isIOS) return 'ios';
    if (Platform.isWindows) return 'windows';
    if (Platform.isMacOS) return 'macos';
    if (Platform.isLinux) return 'linux';
    return 'web';
  }

  static Future<String?> _deviceIdSafe() async {
    try {
      final di = DeviceInfoPlugin();
      if (kIsWeb) {
        final web = await di.webBrowserInfo;
        return '${web.vendor}-${web.userAgent}';
      }
      if (Platform.isAndroid) {
        final a = await di.androidInfo;
        return a.id; // ou a.androidId selon besoin
      }
      if (Platform.isIOS) {
        final i = await di.iosInfo;
        return i.identifierForVendor;
      }
      if (Platform.isWindows) {
        final w = await di.windowsInfo;
        return w.deviceId;
      }
      if (Platform.isMacOS) {
        final m = await di.macOsInfo;
        return m.systemGUID;
      }
      if (Platform.isLinux) {
        final l = await di.linuxInfo;
        return l.machineId;
      }
    } catch (_) {}
    return null;
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\supabase\supabase_client.dart

import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseX {
  static SupabaseClient get client => Supabase.instance.client;

  static String? get userId => client.auth.currentUser?.id;
  static bool get isAuthenticated => userId != null;
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\env.dart

class Env {
  static const supabaseUrl = String.fromEnvironment('SUPABASE_URL', defaultValue: 'https://yvvtlcwnayuvtkcxnktl.supabase.co');
  static const supabaseAnonKey = String.fromEnvironment('SUPABASE_ANON_KEY', defaultValue: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl2dnRsY3duYXl1dnRrY3hua3RsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5NDUxNzksImV4cCI6MjA4MjUyMTE3OX0.d9YgxCTdC2-MUjw25ae2TyIei_iwiaK_tFwBwarzzSU');
  static const fcmVapidKey = String.fromEnvironment('FCM_VAPID_KEY', defaultValue: '');

  static void validate() {
    if (supabaseUrl.isEmpty || !supabaseUrl.startsWith('http')) {
      throw StateError('SUPABASE_URL manquant ou invalide. Lance avec --dart-define=SUPABASE_URL=...');
    }
    if (supabaseAnonKey.isEmpty) {
      throw StateError('SUPABASE_ANON_KEY manquant. Lance avec --dart-define=SUPABASE_ANON_KEY=...');
    }
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\google_oauth_io.dart

import 'dart:io';
import 'package:supabase_flutter/supabase_flutter.dart';

Future<void> signInWithGoogleImpl() async {
  final sb = Supabase.instance.client;

  // IMPORTANT: doit matcher ce que tu as autorisé dans Supabase
  const redirectTo = 'http://localhost:3000/auth/callback';

  // Démarre un petit serveur local pour recevoir ?code=...
  final server = await HttpServer.bind(InternetAddress.loopbackIPv4, 3000);

  try {
    await sb.auth.signInWithOAuth(OAuthProvider.google, redirectTo: redirectTo);

    // Attend le callback
    final req = await server.first;

    final error = req.uri.queryParameters['error'];
    final errorDesc = req.uri.queryParameters['error_description'];
    final code = req.uri.queryParameters['code'];

    // Répond au navigateur
    req.response.statusCode = 200;
    req.response.headers.contentType = ContentType.html;
    if (error != null) {
      req.response.write('<h3>Erreur: $error</h3><p>$errorDesc</p>');
    } else {
      req.response.write('<h3>OK. Tu peux fermer cette fenêtre.</h3>');
    }
    await req.response.close();

    if (error != null) {
      throw Exception('OAuth error: $error ($errorDesc)');
    }
    if (code == null || code.isEmpty) {
      throw Exception('Code OAuth manquant dans le callback.');
    }

    // Échange le code contre une session
    await sb.auth.exchangeCodeForSession(code);
  } finally {
    await server.close(force: true);
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\google_oauth_web.dart

import 'package:supabase_flutter/supabase_flutter.dart';

Future<void> signInWithGoogleImpl() async {
  final sb = Supabase.instance.client;

  // Route web de callback (doit exister dans ton router)
  final redirectTo = '${Uri.base.origin}/auth/callback';

  await sb.auth.signInWithOAuth(OAuthProvider.google, redirectTo: redirectTo);
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\google_oauth.dart

import 'google_oauth_web.dart' if (dart.library.io) 'google_oauth_io.dart';

Future<void> signInWithGoogleUnified() => signInWithGoogleImpl();
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\router_refresh.dart

import 'dart:async';
import 'package:flutter/foundation.dart';

class GoRouterRefreshStream extends ChangeNotifier {
  GoRouterRefreshStream(Stream<dynamic> stream) {
    _sub = stream.asBroadcastStream().listen((_) => notifyListeners());
  }

  late final StreamSubscription<dynamic> _sub;

  @override
  void dispose() {
    _sub.cancel();
    super.dispose();
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\router.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'router_refresh.dart';

// Auth
import '../features/auth/login_page.dart';
import '../features/auth/auth_callback_page.dart';

// Public
import '../features/public/landing_page.dart';
import '../features/explore/explore_page.dart';
import '../features/business/public_business_page.dart';
import '../features/products/public_product_page.dart';

// App
import '../features/home/home_page.dart';
import '../features/business/create_business_page.dart';
import '../features/business/business_settings_page.dart';
import '../features/business/business_hours_page.dart';
import '../features/business/business_links_page.dart';
import '../features/business/business_domains_page.dart';

// NEW (Enterprise Center)
import '../features/business/business_members_page.dart';
import '../features/business/business_billing_page.dart';
import '../features/business/business_ads_page.dart';

import '../features/products/business_products_page.dart';
import '../features/products/product_detail_page.dart';

import '../features/requests/business_requests_page.dart';
import '../features/requests/request_detail_page.dart';

import '../features/posts/business_posts_page.dart';
import '../features/posts/post_detail_page.dart';

// Cart
import '../features/cart/cart_page.dart';
import '../features/cart/checkout_page.dart';

import 'route_observer.dart';

final _authRefresh = GoRouterRefreshStream(
  Supabase.instance.client.auth.onAuthStateChange,
);

final appRouter = GoRouter(
  refreshListenable: _authRefresh,
  initialLocation: '/explore',

  redirect: (context, state) {
    final uri = state.uri;
    final path = uri.path;

    final session = Supabase.instance.client.auth.currentSession;
    final loggedIn = session != null;

    final isLogin = path == '/login';
    final isCallback = path == '/auth/callback';

    // Public routes (sans login)
    final isLanding = path == '/';
    final isExplore = path == '/explore';
    final isPublicBusiness = path.startsWith('/b/');
    final isPublicProduct = path.startsWith('/p/');
    final isCart = path == '/cart';

    // Checkout = public URL mais protégé (doit être loggé)
    final isCheckout = path == '/checkout';

    final isPublic = isLanding ||
        isExplore ||
        isPublicBusiness ||
        isPublicProduct ||
        isCart ||
        isLogin ||
        isCallback;

    if (!loggedIn) {
      if (isCheckout) {
        final full = Uri.encodeComponent(uri.toString());
        return '/login?next=$full';
      }
      if (isPublic) return null;

      final full = Uri.encodeComponent(uri.toString());
      return '/login?next=$full';
    }

    // Logged-in: empêcher de rester sur /login et /auth/callback
    if (isLogin || isCallback) {
      final next = uri.queryParameters['next'];
      if (next != null && next.trim().isNotEmpty) {
        return Uri.decodeComponent(next);
      }
      return '/home';
    }

    return null;
  },

  routes: [
    // ========== PUBLIC ==========
    GoRoute(
      path: '/',
      builder: (context, state) => const LandingPage(),
    ),
    GoRoute(
      path: '/explore',
      builder: (context, state) => const ExplorePage(),
    ),
    GoRoute(
      path: '/b/:slug',
      builder: (context, state) =>
          PublicBusinessPage(slug: state.pathParameters['slug']!),
    ),
    GoRoute(
      path: '/p/:pid',
      builder: (context, state) =>
          PublicProductPage(productId: state.pathParameters['pid']!),
    ),

    // Cart public
    GoRoute(
      path: '/cart',
      builder: (context, state) => const CartPage(),
    ),
    GoRoute(
      path: '/checkout',
      builder: (context, state) => const CheckoutPage(),
    ),

    // ========== AUTH ==========
    GoRoute(
      path: '/login',
      builder: (context, state) => const LoginPage(),
    ),
    GoRoute(
      path: '/auth/callback',
      builder: (context, state) => const AuthCallbackPage(),
    ),

    // ========== APP (protégé) ==========
    GoRoute(
      path: '/home',
      builder: (context, state) => const HomePage(),
    ),

    GoRoute(
      path: '/business/create',
      builder: (context, state) => const CreateBusinessPage(),
    ),

    GoRoute(
      path: '/business/:id/settings',
      builder: (context, state) =>
          BusinessSettingsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: 'hours',
          builder: (context, state) =>
              BusinessHoursPage(businessId: state.pathParameters['id']!),
        ),
        GoRoute(
          path: 'links',
          builder: (context, state) =>
              BusinessLinksPage(businessId: state.pathParameters['id']!),
        ),
        GoRoute(
          path: 'domains',
          builder: (context, state) =>
              BusinessDomainsPage(businessId: state.pathParameters['id']!),
        ),

        // NEW: members / billing / ads (sous settings pour UX cohérente)
        GoRoute(
          path: 'members',
          builder: (context, state) =>
              BusinessMembersPage(businessId: state.pathParameters['id']!),
        ),
        GoRoute(
          path: 'billing',
          builder: (context, state) =>
              BusinessBillingPage(businessId: state.pathParameters['id']!),
        ),
        GoRoute(
          path: 'ads',
          builder: (context, state) =>
              BusinessAdsPage(businessId: state.pathParameters['id']!),
        ),
      ],
    ),

    GoRoute(
      path: '/business/:id/products',
      builder: (context, state) =>
          BusinessProductsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: ':pid',
          builder: (context, state) => ProductDetailPage(
            businessId: state.pathParameters['id']!,
            productId: state.pathParameters['pid']!,
          ),
        ),
      ],
    ),

    GoRoute(
      path: '/business/:id/requests',
      builder: (context, state) =>
          BusinessRequestsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: ':rid',
          builder: (context, state) => RequestDetailPage(
            businessId: state.pathParameters['id']!,
            requestId: state.pathParameters['rid']!,
          ),
        ),
      ],
    ),

    // Posts
    GoRoute(
      path: '/business/:id/posts',
      builder: (context, state) =>
          BusinessPostsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: ':postId',
          builder: (context, state) => BusinessPostDetailPage(
            businessId: state.pathParameters['id']!,
            postId: state.pathParameters['postId']!,
          ),
        ),
      ],
    ),
  ],

  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: const Text('Erreur')),
    body: Center(child: Text(state.error.toString())),
  ),
  observers: [routeObserver],
);
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\auth\auth_callback_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class AuthCallbackPage extends StatefulWidget {
  const AuthCallbackPage({super.key});

  @override
  State<AuthCallbackPage> createState() => _AuthCallbackPageState();
}

class _AuthCallbackPageState extends State<AuthCallbackPage> {
  String? _error;

  @override
  void initState() {
    super.initState();
    _handle();
  }

  Future<void> _handle() async {
    try {
      final uri = Uri.base;

      // Si OAuth renvoie une erreur
      final err = uri.queryParameters['error'];
      final errDesc = uri.queryParameters['error_description'];
      if (err != null) {
        setState(() => _error = 'OAuth error: $err ${errDesc ?? ""}');
        return;
      }

      final sb = Supabase.instance.client;

      // Supabase web: récupère la session depuis l’URL (code PKCE)
      await sb.auth.getSessionFromUrl(uri);

      final session = sb.auth.currentSession;
      if (session == null) {
        setState(() => _error = 'Session non créée. Réessaie la connexion.');
        return;
      }

      if (!mounted) return;
      context.push('/home');
    } catch (e) {
      setState(() => _error = e.toString());
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_error == null) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Text(_error!, style: const TextStyle(color: Colors.red)),
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\auth\login_page.dart

import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../core/auth/google_oauth.dart';

// <-- vérifie le chemin

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});
  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage>
    with SingleTickerProviderStateMixin {
  late final TabController _tabs;

  final _email = TextEditingController();
  final _pass = TextEditingController();

  bool _loading = false;
  String? _error;
  String? _info;

  @override
  void initState() {
    super.initState();
    _tabs = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabs.dispose();
    _email.dispose();
    _pass.dispose();
    super.dispose();
  }

  void _setLoading(bool v) {
    if (!mounted) return;
    setState(() => _loading = v);
  }

  void _setError(String? msg) {
    if (!mounted) return;
    setState(() => _error = msg);
  }

  void _setInfo(String? msg) {
    if (!mounted) return;
    setState(() => _info = msg);
  }

  Future<void> _signInPassword() async {
    _setLoading(true);
    _setError(null);
    _setInfo(null);

    try {
      await Supabase.instance.client.auth.signInWithPassword(
        email: _email.text.trim(),
        password: _pass.text,
      );
    } on AuthException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  Future<void> _signUpPassword() async {
    _setLoading(true);
    _setError(null);
    _setInfo(null);

    try {
      await Supabase.instance.client.auth.signUp(
        email: _email.text.trim(),
        password: _pass.text,
      );

      _setInfo(
        "Compte créé. Vérifie ta boîte mail si la confirmation email est activée.",
      );
    } on AuthException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  Future<void> _sendMagicLink() async {
    _setLoading(true);
    _setError(null);
    _setInfo(null);

    try {
      // Web: vers /auth/callback (plus propre que origin seul)
      final redirectTo = kIsWeb ? '${Uri.base.origin}/auth/callback' : null;

      await Supabase.instance.client.auth.signInWithOtp(
        email: _email.text.trim(),
        emailRedirectTo: redirectTo,
      );

      _setInfo(
        "Lien envoyé. Ouvre ton email et clique sur le lien pour te connecter.",
      );
    } on AuthException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  Future<void> _signInGoogle() async {
    _setLoading(true);
    _setError(null);
    _setInfo(null);

    try {
      // Web -> redirect /auth/callback
      // Windows -> loopback http://localhost:3000/auth/callback + exchangeCodeForSession
      await signInWithGoogleUnified();
    } on AuthException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      resizeToAvoidBottomInset: true,
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            return SingleChildScrollView(
              padding: EdgeInsets.only(
                left: 16,
                right: 16,
                top: 16,
                bottom: 16 + MediaQuery.viewInsetsOf(context).bottom,
              ),
              child: Center(
                child: ConstrainedBox(
                  constraints: const BoxConstraints(maxWidth: 520),
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Text(
                            'Connexion',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 12),

                          TabBar(
                            controller: _tabs,
                            tabs: const [
                              Tab(text: 'Mot de passe'),
                              Tab(text: 'Magic link'),
                            ],
                          ),

                          const SizedBox(height: 12),

                          TextField(
                            controller: _email,
                            decoration: const InputDecoration(
                              labelText: 'Email',
                            ),
                            keyboardType: TextInputType.emailAddress,
                          ),
                          const SizedBox(height: 10),

                          SizedBox(
                            height: 190,
                            child: TabBarView(
                              controller: _tabs,
                              children: [
                                Column(
                                  children: [
                                    TextField(
                                      controller: _pass,
                                      decoration: const InputDecoration(
                                        labelText: 'Mot de passe',
                                      ),
                                      obscureText: true,
                                    ),
                                    const SizedBox(height: 12),
                                    Row(
                                      children: [
                                        Expanded(
                                          child: ElevatedButton(
                                            onPressed: _loading
                                                ? null
                                                : _signInPassword,
                                            child: Text(
                                              _loading ? '...' : 'Se connecter',
                                            ),
                                          ),
                                        ),
                                        const SizedBox(width: 8),
                                        Expanded(
                                          child: OutlinedButton(
                                            onPressed: _loading
                                                ? null
                                                : _signUpPassword,
                                            child: const Text(
                                              'Créer un compte',
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ],
                                ),

                                Column(
                                  children: [
                                    const Text(
                                      "Saisis ton email et reçois un lien de connexion.",
                                      textAlign: TextAlign.center,
                                    ),
                                    const SizedBox(height: 12),
                                    SizedBox(
                                      width: double.infinity,
                                      child: ElevatedButton(
                                        onPressed: _loading
                                            ? null
                                            : _sendMagicLink,
                                        child: Text(
                                          _loading ? '...' : 'Envoyer le lien',
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),

                          const SizedBox(height: 8),

                          SizedBox(
                            width: double.infinity,
                            child: OutlinedButton.icon(
                              onPressed: _loading ? null : _signInGoogle,
                              icon: const Icon(Icons.login),
                              label: const Text('Continuer avec Google'),
                            ),
                          ),

                          if (_error != null) ...[
                            const SizedBox(height: 10),
                            Text(
                              _error!,
                              style: const TextStyle(color: Colors.red),
                            ),
                          ],
                          if (_info != null) ...[
                            const SizedBox(height: 10),
                            Text(
                              _info!,
                              style: const TextStyle(color: Colors.green),
                            ),
                          ],
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\data\business_repository.dart

import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../core/data/data_exceptions.dart';
import '../../../core/supabase/supabase_client.dart';

class BusinessRepository {
  BusinessRepository({SupabaseClient? client}) : _client = client ?? SupabaseX.client;
  final SupabaseClient _client;

  // ---------------- B1: business_hours ----------------
  Future<List<Map<String, dynamic>>> fetchBusinessHours(String businessId) async {
    try {
      final res = await _client
          .from('business_hours')
          .select()
          .eq('business_id', businessId)
          .order('day_of_week', ascending: true);
      return (res as List).cast<Map<String, dynamic>>();
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }

  /// Remplace toutes les lignes (simple et robuste).
  Future<void> replaceBusinessHours(String businessId, List<Map<String, dynamic>> rows) async {
    try {
      await _client.from('business_hours').delete().eq('business_id', businessId);
      if (rows.isEmpty) return;

      final payload = rows.map((r) => {...r, 'business_id': businessId}).toList();
      await _client.from('business_hours').insert(payload);
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }

  // ---------------- B1: business_social_links ----------------
  Future<List<Map<String, dynamic>>> fetchSocialLinks(String businessId) async {
    try {
      final res = await _client
          .from('business_social_links')
          .select()
          .eq('business_id', businessId)
          .order('sort_order', ascending: true);
      return (res as List).cast<Map<String, dynamic>>();
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }

  Future<void> upsertSocialLinks(String businessId, List<Map<String, dynamic>> rows) async {
    try {
      if (rows.isEmpty) return;
      final payload = rows.map((r) => {...r, 'business_id': businessId}).toList();

      // OnConflict correspondra à la contrainte UNIQUE (business_id, platform)
      await _client.from('business_social_links').upsert(payload, onConflict: 'business_id,platform');
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }

  // ---------------- B1: business_domains ----------------
  Future<List<Map<String, dynamic>>> fetchDomains(String businessId) async {
    try {
      final res = await _client
          .from('business_domains')
          .select()
          .eq('business_id', businessId)
          .order('created_at', ascending: false);
      return (res as List).cast<Map<String, dynamic>>();
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }

  Future<Map<String, dynamic>> createDomain({required String businessId, required String domain}) async {
    try {
      final res = await _client
          .from('business_domains')
          .insert({
            'business_id': businessId,
            'domain': domain.trim().toLowerCase(),
          })
          .select()
          .single();
      return (res as Map).cast<String, dynamic>();
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }

  Future<void> deleteDomain({required String businessId, required String domainId}) async {
    try {
      await _client.from('business_domains').delete().eq('business_id', businessId).eq('id', domainId);
    } catch (e) {
      throw mapSupabaseError(e);
    }
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_domains_page.dart

// ignore_for_file: control_flow_in_finally

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessDomainsPage extends StatefulWidget {
  final String businessId;
  const BusinessDomainsPage({super.key, required this.businessId});

  @override
  State<BusinessDomainsPage> createState() => _BusinessDomainsPageState();
}

class _BusinessDomainsPageState extends State<BusinessDomainsPage> {
  bool _loading = true;
  bool _saving = false;
  String? _error;

  final _domainCtrl = TextEditingController();
  List<Map<String, dynamic>> _domains = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    _domainCtrl.dispose();
    super.dispose();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;
      final rows = await sb
          .from('business_domains')
          .select('id,domain,status,ssl_status,verification_token,created_at,updated_at')
          .eq('business_id', widget.businessId)
          .order('created_at', ascending: false);

      _domains = (rows as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _addDomain() async {
    final d = _domainCtrl.text.trim().toLowerCase();
    if (d.isEmpty) return;

    setState(() {
      _saving = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;
      await sb.from('business_domains').insert({
        'business_id': widget.businessId,
        'domain': d,
        'updated_at': DateTime.now().toIso8601String(),
      });

      _domainCtrl.clear();
      await _load();
    } on PostgrestException catch (e) {
      _error = 'DB error: ${e.message}';
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _saving = false);
    }
  }

  Future<void> _deleteDomain(String id) async {
    setState(() {
      _saving = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;
      await sb.from('business_domains').delete().eq('id', id);
      await _load();
    } on PostgrestException catch (e) {
      _error = 'DB error: ${e.message}';
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Domaines'),
        actions: [
          IconButton(
            tooltip: 'Rafraîchir',
            onPressed: _loading ? null : _load,
            icon: const Icon(Icons.refresh),
          ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              padding: const EdgeInsets.all(16),
              children: [
                if (_error != null) ...[
                  Text(_error!, style: const TextStyle(color: Colors.red)),
                  const SizedBox(height: 10),
                ],

                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text('Ajouter un domaine', style: TextStyle(fontWeight: FontWeight.w700)),
                        const SizedBox(height: 10),
                        TextField(
                          controller: _domainCtrl,
                          decoration: const InputDecoration(
                            labelText: 'Domaine',
                            hintText: 'ex: boutique.monsite.com',
                          ),
                        ),
                        const SizedBox(height: 10),
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton(
                            onPressed: _saving ? null : _addDomain,
                            child: Text(_saving ? '...' : 'Ajouter'),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 12),
                const Text('Domaines existants', style: TextStyle(fontWeight: FontWeight.w700)),
                const SizedBox(height: 8),

                if (_domains.isEmpty)
                  const Text('Aucun domaine.')
                else
                  ..._domains.map((d) {
                    return Card(
                      child: ListTile(
                        title: Text(d['domain']?.toString() ?? ''),
                        subtitle: Text(
                          'status=${d['status']} • ssl=${d['ssl_status']}\n'
                          'token=${d['verification_token']}',
                        ),
                        isThreeLine: true,
                        trailing: IconButton(
                          tooltip: 'Supprimer',
                          onPressed: _saving ? null : () => _deleteDomain(d['id'].toString()),
                          icon: const Icon(Icons.delete),
                        ),
                      ),
                    );
                  }),
              ],
            ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_hours_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessHoursPage extends StatefulWidget {
  final String businessId;
  const BusinessHoursPage({super.key, required this.businessId});

  @override
  State<BusinessHoursPage> createState() => _BusinessHoursPageState();
}

class _BusinessHoursPageState extends State<BusinessHoursPage> {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  bool _saving = false;
  String? _error;

  // dow 1..7
  final Map<int, _DayState> _days = {
    for (int d = 1; d <= 7; d++) d: _DayState(),
  };

  static const _tzDefault = 'Africa/Lome';

  @override
  void initState() {
    super.initState();
    _load();
  }

  String _dowLabel(int d) {
    const labels = {
      1: 'Lun',
      2: 'Mar',
      3: 'Mer',
      4: 'Jeu',
      5: 'Ven',
      6: 'Sam',
      7: 'Dim',
    };
    return labels[d] ?? '?';
  }

  TimeOfDay? _parsePgTime(dynamic v) {
    final s = v?.toString();
    if (s == null || s.isEmpty) return null;
    // "09:30:00" => 09:30
    final parts = s.split(':');
    if (parts.length < 2) return null;
    final h = int.tryParse(parts[0]) ?? 0;
    final m = int.tryParse(parts[1]) ?? 0;
    return TimeOfDay(hour: h, minute: m);
  }

  String? _toPgTime(TimeOfDay? t) {
    if (t == null) return null;
    final hh = t.hour.toString().padLeft(2, '0');
    final mm = t.minute.toString().padLeft(2, '0');
    return '$hh:$mm:00';
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final rows = await _sb
          .from('business_hours')
          .select('day_of_week,is_closed,open_time,close_time,opens_at,closes_at,timezone')
          .eq('business_id', widget.businessId)
          .order('day_of_week', ascending: true);

      final list = (rows as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      for (final r in list) {
        final dow = (r['day_of_week'] as num?)?.toInt();
        if (dow == null || dow < 1 || dow > 7) continue;

        final st = _days[dow]!;
        st.closed = r['is_closed'] == true;

        // priorité opens_at/closes_at, fallback open_time/close_time
        st.open = _parsePgTime(r['opens_at'] ?? r['open_time']);
        st.close = _parsePgTime(r['closes_at'] ?? r['close_time']);
        st.timezone = (r['timezone'] ?? _tzDefault).toString();
      }
    } catch (e) {
      _error = e.toString();
    } finally {
      // ignore: control_flow_in_finally
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _pickTime({
    required int dow,
    required bool isOpen,
  }) async {
    final current = isOpen ? _days[dow]!.open : _days[dow]!.close;

    final picked = await showTimePicker(
      context: context,
      initialTime: current ?? const TimeOfDay(hour: 9, minute: 0),
    );
    if (picked == null) return;

    setState(() {
      if (isOpen) {
        _days[dow]!.open = picked;
      } else {
        _days[dow]!.close = picked;
      }
    });
  }

  Future<void> _save() async {
    setState(() {
      _saving = true;
      _error = null;
    });

    try {
      final payload = <Map<String, dynamic>>[];

      for (int dow = 1; dow <= 7; dow++) {
        final st = _days[dow]!;
        payload.add({
          'business_id': widget.businessId,
          'day_of_week': dow, // ✅ 1..7
          'is_closed': st.closed,
          'timezone': st.timezone.isEmpty ? _tzDefault : st.timezone,
          // on écrit opens_at/closes_at (trigger sync les champs legacy)
          'opens_at': st.closed ? null : _toPgTime(st.open),
          'closes_at': st.closed ? null : _toPgTime(st.close),
        });
      }

      await _sb.from('business_hours').upsert(
            payload,
            onConflict: 'business_id,day_of_week',
          );

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Horaires enregistrés.')));
      context.pop();
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (mounted) setState(() => _saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.canPop() ? context.pop() : context.push('/home'),
        ),
        title: const Text('Horaires'),
        actions: [
          TextButton(
            onPressed: _saving ? null : _save,
            child: _saving ? const Text('...') : const Text('Enregistrer'),
          ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : (_error != null)
              ? Center(child: Padding(padding: const EdgeInsets.all(16), child: Text(_error!, style: const TextStyle(color: Colors.red))))
              : ListView.builder(
                  padding: const EdgeInsets.all(16),
                  itemCount: 7,
                  itemBuilder: (context, i) {
                    final dow = i + 1;
                    final st = _days[dow]!;
                    return Card(
                      child: Padding(
                        padding: const EdgeInsets.all(12),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Text(_dowLabel(dow), style: const TextStyle(fontWeight: FontWeight.w800)),
                                const Spacer(),
                                Switch(
                                  value: st.closed,
                                  onChanged: (v) => setState(() => st.closed = v),
                                ),
                                const SizedBox(width: 6),
                                Text(st.closed ? 'Fermé' : 'Ouvert'),
                              ],
                            ),
                            const SizedBox(height: 8),
                            if (!st.closed)
                              Row(
                                children: [
                                  Expanded(
                                    child: OutlinedButton(
                                      onPressed: () => _pickTime(dow: dow, isOpen: true),
                                      child: Text(st.open == null ? 'Ouverture' : st.open!.format(context)),
                                    ),
                                  ),
                                  const SizedBox(width: 10),
                                  Expanded(
                                    child: OutlinedButton(
                                      onPressed: () => _pickTime(dow: dow, isOpen: false),
                                      child: Text(st.close == null ? 'Fermeture' : st.close!.format(context)),
                                    ),
                                  ),
                                ],
                              ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
    );
  }
}

class _DayState {
  bool closed = false;
  TimeOfDay? open;
  TimeOfDay? close;
  String timezone = 'Africa/Lome';
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_links_page.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessLinksPage extends StatefulWidget {
  final String businessId;
  const BusinessLinksPage({super.key, required this.businessId});

  @override
  State<BusinessLinksPage> createState() => _BusinessLinksPageState();
}

class _BusinessLinksPageState extends State<BusinessLinksPage> {
  bool _loading = true;
  bool _saving = false;
  String? _error;

  static const _platforms = <String>[
    'website',
    'whatsapp',
    'facebook',
    'instagram',
    'tiktok',
    'x',
    'youtube',
  ];

  final Map<String, TextEditingController> _ctrl = {
    for (final p in _platforms) p: TextEditingController(),
  };

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    for (final c in _ctrl.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;
      final rows = await sb
          .from('business_social_links')
          .select('platform,url')
          .eq('business_id', widget.businessId);

      for (final r in (rows as List)) {
        final m = Map<String, dynamic>.from(r as Map);
        final p = (m['platform'] ?? '').toString();
        final u = (m['url'] ?? '').toString();
        if (_ctrl.containsKey(p)) _ctrl[p]!.text = u;
      }
    } catch (e) {
      _error = e.toString();
    } finally {
      // ignore: control_flow_in_finally
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _save() async {
    setState(() {
      _saving = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;

      // Upsert non-empty
      final upserts = <Map<String, dynamic>>[];
      for (final p in _platforms) {
        final url = _ctrl[p]!.text.trim();
        if (url.isEmpty) continue;

        upserts.add({
          'business_id': widget.businessId,
          'platform': p,
          'url': url,
          'updated_at': DateTime.now().toIso8601String(),
        });
      }

      if (upserts.isNotEmpty) {
        await sb.from('business_social_links').upsert(
              upserts,
              onConflict: 'business_id,platform',
            );
      }

      // Delete empty
      for (final p in _platforms) {
        final url = _ctrl[p]!.text.trim();
        if (url.isNotEmpty) continue;

        await sb
            .from('business_social_links')
            .delete()
            .eq('business_id', widget.businessId)
            .eq('platform', p);
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Liens enregistrés.')),
      );
    } on PostgrestException catch (e) {
      _error = 'DB error: ${e.message}';
    } catch (e) {
      _error = e.toString();
    } finally {
      // ignore: control_flow_in_finally
      if (!mounted) return;
      setState(() => _saving = false);
    }
  }

  String _label(String p) {
    switch (p) {
      case 'website':
        return 'Site web';
      case 'whatsapp':
        return 'WhatsApp';
      case 'facebook':
        return 'Facebook';
      case 'instagram':
        return 'Instagram';
      case 'tiktok':
        return 'TikTok';
      case 'x':
        return 'X';
      case 'youtube':
        return 'YouTube';
      default:
        return p;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Liens & réseaux'),
        actions: [
          TextButton(
            onPressed: _saving ? null : _save,
            child: Text(_saving ? '...' : 'Enregistrer'),
          ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              padding: const EdgeInsets.all(16),
              children: [
                if (_error != null) ...[
                  Text(_error!, style: const TextStyle(color: Colors.red)),
                  const SizedBox(height: 10),
                ],
                ..._platforms.map((p) {
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 10),
                    child: TextField(
                      controller: _ctrl[p],
                      decoration: InputDecoration(
                        labelText: _label(p),
                        hintText: 'https://...',
                      ),
                    ),
                  );
                }),
              ],
            ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_posts_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessPostsPage extends StatefulWidget {
  final String businessId;
  const BusinessPostsPage({super.key, required this.businessId});

  @override
  State<BusinessPostsPage> createState() => _BusinessPostsPageState();
}

class _BusinessPostsPageState extends State<BusinessPostsPage> {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;
  List<Map<String, dynamic>> _posts = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final resp = await _sb
          .from('posts')
          .select('id,title,content,created_at,is_published')
          .eq('business_id', widget.businessId)
          .order('created_at', ascending: false);

      setState(() {
        _posts = (resp as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
      });
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.canPop() ? context.pop() : context.push('/home'),
        ),
        title: const Text('Posts'),
        actions: [
          IconButton(
            tooltip: 'Rafraîchir',
            onPressed: _load,
            icon: const Icon(Icons.refresh),
          ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : (_error != null)
              ? Center(child: Padding(padding: const EdgeInsets.all(16), child: Text(_error!, style: const TextStyle(color: Colors.red))))
              : ListView.separated(
                  padding: const EdgeInsets.all(16),
                  itemCount: _posts.length,
                  separatorBuilder: (_, __) => const SizedBox(height: 10),
                  itemBuilder: (context, i) {
                    final p = _posts[i];
                    final id = (p['id'] ?? '').toString();
                    final title = (p['title'] ?? 'Sans titre').toString();
                    final published = p['is_published'] == true;

                    return Card(
                      child: ListTile(
                        title: Text(title),
                        subtitle: Text(published ? 'Publié' : 'Brouillon'),
                        onTap: () => context.push('/business/${widget.businessId}/posts/$id'),
                      ),
                    );
                  },
                ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_settings_page.dart

import 'dart:ui' show ImageFilter;

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessSettingsPage extends StatefulWidget {
  final String businessId;
  const BusinessSettingsPage({super.key, required this.businessId});

  @override
  State<BusinessSettingsPage> createState() => _BusinessSettingsPageState();
}

class _BusinessSettingsPageState extends State<BusinessSettingsPage> {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  bool _saving = false;
  bool _uploadingLogo = false;
  bool _uploadingCover = false;

  String? _error;
  Map<String, dynamic>? business;
  Map<String, dynamic>? _entitlements;

  final _whatsapp = TextEditingController();
  final _address = TextEditingController();
  final _desc = TextEditingController();

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    _whatsapp.dispose();
    _address.dispose();
    _desc.dispose();
    super.dispose();
  }

  Future<void> _ensureAuthenticated() async {
    await _sb.auth.refreshSession();
    final session = _sb.auth.currentSession;
    final user = _sb.auth.currentUser;
    if (session == null || user == null) {
      throw Exception('Session manquante. Déconnecte-toi puis reconnecte-toi.');
    }
  }

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      await _ensureAuthenticated();

      final row = await _sb
          .from('businesses')
          .select('id,name,slug,description,whatsapp_phone,address_text,logo_path,cover_path')
          .eq('id', widget.businessId)
          .single();

      business = Map<String, dynamic>.from(row as Map);

      _whatsapp.text = (business?['whatsapp_phone'] ?? '').toString();
      _address.text = (business?['address_text'] ?? '').toString();
      _desc.text = (business?['description'] ?? '').toString();

      final ent = await _sb
          .from('entitlements')
          .select('can_receive_orders, can_run_ads, visibility_multiplier, plans:plans(code,name)')
          .eq('business_id', widget.businessId)
          .single();

      _entitlements = Map<String, dynamic>.from(ent as Map);
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  String _contentTypeFromExt(String? ext) {
    final e = (ext ?? '').toLowerCase();
    if (e == 'png') return 'image/png';
    if (e == 'jpg' || e == 'jpeg') return 'image/jpeg';
    if (e == 'webp') return 'image/webp';
    return 'application/octet-stream';
  }

  Future<void> _uploadImage({
    required String bucket,
    required String column, // 'logo_path' ou 'cover_path'
  }) async {
    if (column != 'logo_path' && column != 'cover_path') {
      setState(() => _error = 'Colonne invalide: $column');
      return;
    }

    setState(() {
      _error = null;
      if (column == 'logo_path') {
        _uploadingLogo = true;
      } else {
        _uploadingCover = true;
      }
    });

    try {
      await _ensureAuthenticated();

      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        withData: true,
      );
      if (result == null || result.files.isEmpty) return;

      final file = result.files.first;
      final bytes = file.bytes;
      if (bytes == null || bytes.isEmpty) {
        throw Exception('Impossible de lire le fichier (bytes null).');
      }

      final ext = (file.extension ?? 'png').toLowerCase();
      final objectPath =
          '${widget.businessId}/${column}_${DateTime.now().millisecondsSinceEpoch}.$ext';

      await _sb.storage.from(bucket).uploadBinary(
            objectPath,
            bytes,
            fileOptions: FileOptions(
              upsert: true,
              contentType: _contentTypeFromExt(ext),
            ),
          );

      await _sb.from('businesses').update({column: objectPath}).eq('id', widget.businessId);

      await _load();
    } on StorageException catch (e) {
      setState(() => _error = 'Storage error: ${e.message}');
    } on PostgrestException catch (e) {
      setState(() => _error = 'DB error: ${e.message}');
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (!mounted) return;
      setState(() {
        if (column == 'logo_path') {
          _uploadingLogo = false;
        } else {
          _uploadingCover = false;
        }
      });
    }
  }

  Future<void> _saveText() async {
    setState(() {
      _error = null;
      _saving = true;
    });

    try {
      await _ensureAuthenticated();

      await _sb.from('businesses').update({
        'whatsapp_phone': _whatsapp.text.trim().isEmpty ? null : _whatsapp.text.trim(),
        'address_text': _address.text.trim().isEmpty ? null : _address.text.trim(),
        'description': _desc.text.trim().isEmpty ? null : _desc.text.trim(),
      }).eq('id', widget.businessId);

      await _load();
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Enregistré')),
      );
    } on PostgrestException catch (e) {
      setState(() => _error = 'DB error: ${e.message}');
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (!mounted) return;
      setState(() => _saving = false);
    }
  }

  String? _publicUrl(String bucket, String? path) {
    if (path == null || path.isEmpty) return null;
    return _sb.storage.from(bucket).getPublicUrl(path);
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    final name = (business?['name'] ?? '').toString();
    final slug = (business?['slug'] ?? '').toString();

    final logoUrl = _publicUrl('business_logos', business?['logo_path']?.toString());
    final coverUrl = _publicUrl('business_covers', business?['cover_path']?.toString());

    final planCode = _entitlements?['plans']?['code']?.toString() ?? 'free';
    final planName = _entitlements?['plans']?['name']?.toString() ?? 'Free';
    final canOrders = _entitlements?['can_receive_orders'] == true;
    final canAds = _entitlements?['can_run_ads'] == true;

    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            pinned: true,
            expandedHeight: 220,
            title: Text('Paramètres • $name'),
            leading: IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: () => context.canPop() ? context.pop() : context.go('/home'),
            ),
            flexibleSpace: FlexibleSpaceBar(
              background: Stack(
                fit: StackFit.expand,
                children: [
                  if (coverUrl != null)
                    Image.network(coverUrl, fit: BoxFit.cover)
                  else
                    Container(color: Theme.of(context).colorScheme.surfaceContainerHighest),
                  BackdropFilter(
                    filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10),
                    child: Container(color: Colors.black.withOpacity(0.15)),
                  ),
                  Align(
                    alignment: Alignment.bottomLeft,
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          CircleAvatar(
                            radius: 34,
                            backgroundColor: Colors.white,
                            child: CircleAvatar(
                              radius: 32,
                              backgroundImage: (logoUrl != null) ? NetworkImage(logoUrl) : null,
                              child: logoUrl == null ? const Icon(Icons.storefront_outlined, size: 28) : null,
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(name,
                                    maxLines: 1,
                                    overflow: TextOverflow.ellipsis,
                                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w900, color: Colors.white)),
                                const SizedBox(height: 3),
                                Text('@$slug • $planName ($planCode)',
                                    maxLines: 1,
                                    overflow: TextOverflow.ellipsis,
                                    style: const TextStyle(color: Colors.white70)),
                              ],
                            ),
                          ),
                          const SizedBox(width: 10),
                          IconButton.filledTonal(
                            tooltip: 'Voir mini-site',
                            onPressed: slug.isEmpty ? null : () => context.push('/b/$slug'),
                            icon: const Icon(Icons.public),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),

          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 14, 16, 20),
            sliver: SliverList(
              delegate: SliverChildListDelegate([
                if (_error != null) ...[
                  Text(_error!, style: const TextStyle(color: Colors.red)),
                  const SizedBox(height: 12),
                ],

                _SectionHeader('Médias'),
                const SizedBox(height: 10),
                Row(
                  children: [
                    Expanded(
                      child: _MediaCard(
                        title: 'Logo',
                        imageUrl: logoUrl,
                        height: 120,
                        fit: BoxFit.contain,
                        busy: _uploadingLogo,
                        buttonText: 'Uploader logo',
                        onPressed: _uploadingLogo
                            ? null
                            : () => _uploadImage(bucket: 'business_logos', column: 'logo_path'),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: _MediaCard(
                        title: 'Couverture',
                        imageUrl: coverUrl,
                        height: 120,
                        fit: BoxFit.cover,
                        busy: _uploadingCover,
                        buttonText: 'Uploader couverture',
                        onPressed: _uploadingCover
                            ? null
                            : () => _uploadImage(bucket: 'business_covers', column: 'cover_path'),
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 18),
                _SectionHeader('Infos mini-site'),
                const SizedBox(height: 10),

                TextField(
                  controller: _whatsapp,
                  decoration: const InputDecoration(
                    labelText: 'WhatsApp',
                    prefixIcon: Icon(Icons.chat),
                  ),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _address,
                  decoration: const InputDecoration(
                    labelText: 'Adresse',
                    prefixIcon: Icon(Icons.location_on_outlined),
                  ),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _desc,
                  decoration: const InputDecoration(
                    labelText: 'Description',
                    prefixIcon: Icon(Icons.description_outlined),
                  ),
                  maxLines: 4,
                ),

                const SizedBox(height: 18),
                _SectionHeader('Entreprise'),
                const SizedBox(height: 10),

                _NavCard(
                  title: 'Membres',
                  subtitle: 'Gérer les rôles et accès (owner/admin)',
                  icon: Icons.group,
                  onTap: () => context.push('/business/${widget.businessId}/settings/members'),
                ),
                const SizedBox(height: 10),
                _NavCard(
                  title: 'Monétisation',
                  subtitle: canOrders ? 'Commandes activées' : 'Activer la réception des commandes',
                  icon: Icons.payments,
                  onTap: () => context.push('/business/${widget.businessId}/settings/billing'),
                ),
                const SizedBox(height: 10),
                _NavCard(
                  title: 'Publicités',
                  subtitle: canAds ? 'Créer / gérer campagnes' : 'Bloqué par le plan',
                  icon: Icons.campaign,
                  onTap: () => context.push('/business/${widget.businessId}/settings/ads'),
                  enabled: true, // tu peux mettre canAds si tu veux bloquer
                ),

                const SizedBox(height: 18),
                _SectionHeader('Mini-site avancé'),
                const SizedBox(height: 10),

                Wrap(
                  spacing: 10,
                  runSpacing: 10,
                  children: [
                    OutlinedButton.icon(
                      onPressed: slug.isEmpty ? null : () => context.push('/b/$slug'),
                      icon: const Icon(Icons.public),
                      label: const Text('Ouvrir boutique publique'),
                    ),
                    OutlinedButton.icon(
                      onPressed: () => context.push('/business/${widget.businessId}/settings/hours'),
                      icon: const Icon(Icons.access_time),
                      label: const Text('Horaires'),
                    ),
                    OutlinedButton.icon(
                      onPressed: () => context.push('/business/${widget.businessId}/settings/links'),
                      icon: const Icon(Icons.link),
                      label: const Text('Liens'),
                    ),
                    OutlinedButton.icon(
                      onPressed: () => context.push('/business/${widget.businessId}/settings/domains'),
                      icon: const Icon(Icons.domain),
                      label: const Text('Domaines'),
                    ),
                  ],
                ),

                const SizedBox(height: 18),
                SizedBox(
                  width: double.infinity,
                  child: FilledButton.icon(
                    onPressed: _saving ? null : _saveText,
                    icon: const Icon(Icons.save),
                    label: Text(_saving ? '...' : 'Enregistrer'),
                  ),
                ),
              ]),
            ),
          ),
        ],
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final String title;
  const _SectionHeader(this.title);

  @override
  Widget build(BuildContext context) {
    return Text(
      title,
      style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w900),
    );
  }
}

class _MediaCard extends StatelessWidget {
  final String title;
  final String? imageUrl;
  final double height;
  final BoxFit fit;
  final bool busy;
  final String buttonText;
  final VoidCallback? onPressed;

  const _MediaCard({
    required this.title,
    required this.imageUrl,
    required this.height,
    required this.fit,
    required this.busy,
    required this.buttonText,
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          children: [
            Text(title, style: const TextStyle(fontWeight: FontWeight.w800)),
            const SizedBox(height: 10),
            SizedBox(
              height: height,
              child: (imageUrl == null)
                  ? const Center(child: Text('Aucun'))
                  : ClipRRect(
                      borderRadius: BorderRadius.circular(12),
                      child: Image.network(imageUrl!, fit: fit, width: double.infinity),
                    ),
            ),
            const SizedBox(height: 10),
            SizedBox(
              width: double.infinity,
              child: FilledButton.tonal(
                onPressed: onPressed,
                child: Text(busy ? '...' : buttonText),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _NavCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback onTap;
  final bool enabled;

  const _NavCard({
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.onTap,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    return Opacity(
      opacity: enabled ? 1 : 0.5,
      child: Card(
        child: ListTile(
          leading: Icon(icon),
          title: Text(title, style: const TextStyle(fontWeight: FontWeight.w800)),
          subtitle: Text(subtitle),
          trailing: Icon(enabled ? Icons.arrow_forward : Icons.lock),
          onTap: enabled ? onTap : null,
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_social_links_page.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessSocialLinksPage extends StatefulWidget {
  final String businessId;
  const BusinessSocialLinksPage({super.key, required this.businessId});

  @override
  State<BusinessSocialLinksPage> createState() => _BusinessSocialLinksPageState();
}

class _BusinessSocialLinksPageState extends State<BusinessSocialLinksPage> {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;

  final _controllers = <String, TextEditingController>{
    'website': TextEditingController(),
    'whatsapp': TextEditingController(),
    'facebook': TextEditingController(),
    'instagram': TextEditingController(),
    'tiktok': TextEditingController(),
    'x': TextEditingController(),
    'youtube': TextEditingController(),
  };

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    for (final c in _controllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final rows = await _sb
          .from('business_social_links')
          .select('platform,url')
          .eq('business_id', widget.businessId);

      for (final r in rows) {
        final platform = r['platform'] as String;
        final url = r['url'] as String? ?? '';
        if (_controllers.containsKey(platform)) {
          _controllers[platform]!.text = url;
        }
      }
    } catch (e) {
      _error = e.toString();
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  Future<void> _save() async {
    setState(() => _loading = true);
    try {
      final payload = <Map<String, dynamic>>[];

      _controllers.forEach((platform, controller) {
        final url = controller.text.trim();
        if (url.isEmpty) return;
        payload.add({
          'business_id': widget.businessId,
          'platform': platform,
          'url': url,
          'updated_at': DateTime.now().toIso8601String(),
        });
      });

      if (payload.isNotEmpty) {
        await _sb.from('business_social_links').upsert(
              payload,
              onConflict: 'business_id,platform',
            );
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Liens enregistrés.')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: $e')),
      );
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  Widget _field(String label, String key, {String? hint}) {
    return TextField(
      controller: _controllers[key],
      decoration: InputDecoration(
        labelText: label,
        hintText: hint,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Liens & Réseaux'),
        actions: [
          TextButton(
            onPressed: _loading ? null : _save,
            child: const Text('Enregistrer'),
          ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
              ? Center(child: Text(_error!))
              : ListView(
                  padding: const EdgeInsets.all(16),
                  children: [
                    _field('Site web', 'website', hint: 'https://...'),
                    const SizedBox(height: 12),
                    _field('WhatsApp', 'whatsapp', hint: '+228... ou lien wa.me'),
                    const SizedBox(height: 12),
                    _field('Facebook', 'facebook'),
                    const SizedBox(height: 12),
                    _field('Instagram', 'instagram'),
                    const SizedBox(height: 12),
                    _field('TikTok', 'tiktok'),
                    const SizedBox(height: 12),
                    _field('X (Twitter)', 'x'),
                    const SizedBox(height: 12),
                    _field('YouTube', 'youtube'),
                  ],
                ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\create_business_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class CreateBusinessPage extends StatefulWidget {
  const CreateBusinessPage({super.key});

  @override
  State<CreateBusinessPage> createState() => _CreateBusinessPageState();
}

class _CreateBusinessPageState extends State<CreateBusinessPage> {
  final _name = TextEditingController();
  final _slug = TextEditingController();
  final _desc = TextEditingController();
  final _whatsapp = TextEditingController();
  final _address = TextEditingController();

  bool _loading = false;
  String? _error;

  @override
  void dispose() {
    _name.dispose();
    _slug.dispose();
    _desc.dispose();
    _whatsapp.dispose();
    _address.dispose();
    super.dispose();
  }

  String _slugify(String input) {
    var s = input.trim().toLowerCase();
    s = s
        .replaceAll('à', 'a')
        .replaceAll('â', 'a')
        .replaceAll('ä', 'a')
        .replaceAll('é', 'e')
        .replaceAll('è', 'e')
        .replaceAll('ê', 'e')
        .replaceAll('ë', 'e')
        .replaceAll('î', 'i')
        .replaceAll('ï', 'i')
        .replaceAll('ô', 'o')
        .replaceAll('ö', 'o')
        .replaceAll('ù', 'u')
        .replaceAll('û', 'u')
        .replaceAll('ü', 'u')
        .replaceAll('ç', 'c');
    s = s.replaceAll(RegExp(r'[^a-z0-9]+'), '-');
    s = s.replaceAll(RegExp(r'-+'), '-');
    s = s.replaceAll(RegExp(r'^-|-$'), '');
    if (s.length > 50) s = s.substring(0, 50).replaceAll(RegExp(r'-$'), '');
    return s;
  }

  Future<void> _create() async {
    final name = _name.text.trim();
    final slug = _slug.text.trim();

    if (name.isEmpty) {
      setState(() => _error = 'Nom requis.');
      return;
    }
    if (slug.isEmpty) {
      setState(() => _error = 'Slug requis (ex: mon-boutique).');
      return;
    }

    setState(() {
      _loading = true;
      _error = null;
    });

    final sb = Supabase.instance.client;

    try {
      // 1) Vérifier session
      final session = sb.auth.currentSession;
      if (session == null) {
        throw Exception('Session manquante. Reconnecte-toi.');
      }

      // 2) Appeler la function
      final res = await sb.functions.invoke(
        'create_business',
        body: {
          'name': name,
          'slug': slug,
          'description': _desc.text.trim().isEmpty ? null : _desc.text.trim(),
          'whatsapp_phone': _whatsapp.text.trim().isEmpty
              ? null
              : _whatsapp.text.trim(),
          'address_text': _address.text.trim().isEmpty
              ? null
              : _address.text.trim(),
          'lat': null,
          'lng': null,
        },
      );

      final data = res.data;
      if (data is! Map) {
        throw Exception('Réponse invalide (format inattendu).');
      }

      final businessId = data['business_id'] as String?;
      if (businessId == null || businessId.isEmpty) {
        throw Exception('Réponse invalide (business_id manquant).');
      }

      if (!mounted) return;
      context.pushReplacement('/business/$businessId/settings');
    } on FunctionException catch (e) {
      // Erreur renvoyée par Edge Functions (401/500 etc.)
      setState(() => _error = 'Function error (${e.status}): ${e.details}');
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (mounted) {
        setState(() => _loading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Créer une entreprise'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            if (context.canPop()) {
              context.pop();
            } else {
              context.push('/home');
            }
          },
        ),
      ),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                TextField(
                  controller: _name,
                  decoration: const InputDecoration(
                    labelText: 'Nom entreprise',
                  ),
                  onChanged: (v) {
                    if (_slug.text.isEmpty) {
                      _slug.text = _slugify(v);
                    }
                  },
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _slug,
                  decoration: const InputDecoration(
                    labelText: 'Slug (unique) ex: mon-boutique',
                  ),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _whatsapp,
                  decoration: const InputDecoration(
                    labelText: 'WhatsApp (ex: +228XXXXXXXX)',
                  ),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _address,
                  decoration: const InputDecoration(labelText: 'Adresse'),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _desc,
                  decoration: const InputDecoration(labelText: 'Description'),
                  maxLines: 3,
                ),
                if (_error != null) ...[
                  const SizedBox(height: 10),
                  Text(_error!, style: const TextStyle(color: Colors.red)),
                ],
                const SizedBox(height: 16),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _loading ? null : _create,
                    child: Text(_loading ? '...' : 'Créer'),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\business\public_business_page.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../cart/cart_scope.dart';
import '../cart/cart_service.dart';

class PublicBusinessPage extends StatefulWidget {
  final String slug;
  const PublicBusinessPage({super.key, required this.slug});

  @override
  State<PublicBusinessPage> createState() => _PublicBusinessPageState();
}

class _PublicBusinessPageState extends State<PublicBusinessPage> {
  static const _logoBucket = 'business_logos';
  static const _coverBucket = 'business_covers';

  // Ajuste si besoin
  static const _postMediaBucket = 'post_media';
  static const _productMediaBucket = 'product_media';

  bool _loading = true;
  String? _error;

  Map<String, dynamic>? _biz;
  List<Map<String, dynamic>> _links = [];
  List<Map<String, dynamic>> _hours = [];
  List<Map<String, dynamic>> _posts = [];
  List<Map<String, dynamic>> _products = [];

  bool get _loggedIn => Supabase.instance.client.auth.currentSession != null;

  String? _publicUrl(String bucket, String? path) {
    if (path == null || path.isEmpty) return null;
    return Supabase.instance.client.storage.from(bucket).getPublicUrl(path);
  }

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;

      final biz = await sb
          .from('businesses')
          .select('id,name,slug,description,logo_path,cover_path,whatsapp_phone,address_text,is_active,is_verified')
          .eq('slug', widget.slug)
          .maybeSingle();

      if (biz == null) {
        throw Exception("Boutique introuvable.");
      }

      if (biz['is_active'] != true) {
        throw Exception("Cette boutique n'est pas active.");
      }

      final bizId = (biz['id'] as String);

      final links = await sb
          .from('business_social_links')
          .select('platform,url,label,sort_order')
          .eq('business_id', bizId)
          .order('sort_order', ascending: true);

      final hours = await sb
          .from('business_hours')
          .select('day_of_week,is_closed,open_time,close_time,timezone')
          .eq('business_id', bizId)
          .order('day_of_week', ascending: true);

      final posts = await sb
          .from('posts')
          .select('id,title,content,created_at,is_published,post_media(id,media_type,storage_path)')
          .eq('business_id', bizId)
          .eq('is_published', true)
          .order('created_at', ascending: false)
          .limit(30);

      final products = await sb
          .from('products')
          .select('id,title,description,price_amount,currency,created_at,is_active,product_media(id,media_type,storage_path)')
          .eq('business_id', bizId)
          .eq('is_active', true)
          .order('created_at', ascending: false)
          .limit(30);

      if (!mounted) return;

      setState(() {
        _biz = Map<String, dynamic>.from(biz as Map);
        _links = (links as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
        _hours = (hours as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
        _posts = (posts as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
        _products = (products as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
      });
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  String _dowLabel(int dow1to7) {
    const labels = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
    if (dow1to7 < 1 || dow1to7 > 7) return '?';
    return labels[dow1to7];
  }

  String _formatHours(Map<String, dynamic> row) {
    final isClosed = row['is_closed'] == true;
    if (isClosed) return 'Fermé';

    final open = row['open_time']?.toString();
    final close = row['close_time']?.toString();
    if (open == null || close == null) return '—';
    return '${open.substring(0, 5)} – ${close.substring(0, 5)}';
  }

  Future<void> _copy(String text, {String? okMsg}) async {
    await Clipboard.setData(ClipboardData(text: text));
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(okMsg ?? 'Copié')),
    );
  }

  Widget _pill(String text) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(999),
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
      ),
      child: Text(text, style: const TextStyle(fontWeight: FontWeight.w600)),
    );
  }

  String _currency(String? c) => (c == null || c.isEmpty) ? 'XOF' : c;

  Widget _cartIcon(BuildContext context) {
    final cart = CartScope.of(context);

    return AnimatedBuilder(
      animation: cart,
      builder: (context, child) {
        final qty = cart.totalQty;
        return Stack(
          clipBehavior: Clip.none,
          children: [
            IconButton(
              tooltip: 'Panier',
              onPressed: () => context.push('/cart'),
              icon: const Icon(Icons.shopping_cart_outlined),
            ),
            if (qty > 0)
              Positioned(
                right: 6,
                top: 6,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.redAccent,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '$qty',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  void _openBusinessSpace() {
    if (_loggedIn) {
      context.go('/home');
    } else {
      context.push('/login?next=/home');
    }
  }

  String? _productThumb(Map<String, dynamic> pr) {
    final media = (pr['product_media'] as List?)?.cast<Map>() ?? [];
    if (media.isEmpty) return null;
    final first = Map<String, dynamic>.from(media.first);
    final path = first['storage_path']?.toString();
    return _publicUrl(_productMediaBucket, path);
  }

  Future<void> _quickAddToCart(Map<String, dynamic> pr) async {
    final messenger = ScaffoldMessenger.of(context);
    final cart = CartScope.of(context);

    final productId = (pr['id'] ?? '').toString();
    final title = (pr['title'] ?? '').toString();
    final price = pr['price_amount'];
    final cur = _currency(pr['currency']?.toString());
    final thumb = _productThumb(pr);

    if (price is! num || price <= 0) {
      messenger.showSnackBar(const SnackBar(content: Text('Prix indisponible.')));
      return;
    }

    final bizId = (_biz?['id'] ?? '').toString();
    if (bizId.isEmpty) return;

    try {
      cart.add(
        productId: productId,
        businessId: bizId,
        title: title,
        unitPrice: price,
        currency: cur,
        mediaUrl: thumb,
        qty: 1,
      );
      messenger.showSnackBar(const SnackBar(content: Text('Ajouté au panier')));
    } on CartBusinessMismatch {
      final ok = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text('Panier d’une autre boutique'),
          content: const Text(
            'Votre panier contient déjà des produits d’une autre boutique. Voulez-vous vider le panier ?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text('Annuler'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: const Text('Vider'),
            ),
          ],
        ),
      );

      if (ok == true) {
        cart.clear();
        cart.add(
          productId: productId,
          businessId: bizId,
          title: title,
          unitPrice: price,
          currency: cur,
          mediaUrl: thumb,
          qty: 1,
        );
        messenger.showSnackBar(const SnackBar(content: Text('Ajouté au panier')));
      }
    } catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Erreur panier: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    if (_error != null) {
      return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () => context.canPop() ? context.pop() : context.go('/explore'),
          ),
          title: const Text('Boutique'),
          actions: [
            TextButton.icon(
              onPressed: _openBusinessSpace,
              icon: const Icon(Icons.storefront),
              label: const Text('Espace'),
            ),
            _cartIcon(context),
          ],
        ),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Text(_error!, style: const TextStyle(color: Colors.red)),
          ),
        ),
      );
    }

    final biz = _biz!;
    final name = (biz['name'] ?? '').toString();
    final slug = (biz['slug'] ?? '').toString();
    final desc = (biz['description'] ?? '').toString();
    final whatsapp = (biz['whatsapp_phone'] ?? '').toString();
    final address = (biz['address_text'] ?? '').toString();
    final verified = biz['is_verified'] == true;

    final logoUrl = _publicUrl(_logoBucket, biz['logo_path'] as String?);
    final coverUrl = _publicUrl(_coverBucket, biz['cover_path'] as String?);

    return DefaultTabController(
      length: 3,
      child: Scaffold(
        body: CustomScrollView(
          slivers: [
            SliverAppBar(
              pinned: true,
              expandedHeight: 260,
              leading: IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () => context.canPop() ? context.pop() : context.go('/explore'),
              ),
              actions: [
                TextButton.icon(
                  onPressed: _openBusinessSpace,
                  icon: const Icon(Icons.storefront),
                  label: const Text('Espace'),
                ),
                _cartIcon(context),
                IconButton(
                  tooltip: 'Copier le lien',
                  onPressed: () => _copy('/b/$slug', okMsg: 'Chemin copié: /b/$slug'),
                  icon: const Icon(Icons.link),
                ),
              ],
              flexibleSpace: FlexibleSpaceBar(
                background: Stack(
                  fit: StackFit.expand,
                  children: [
                    if (coverUrl != null)
                      Image.network(coverUrl, fit: BoxFit.cover)
                    else
                      Container(color: Theme.of(context).colorScheme.surfaceContainerHighest),
                    Container(
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topCenter,
                          end: Alignment.bottomCenter,
                          colors: [
                            Colors.black.withValues(alpha: 0.25),
                            Colors.black.withValues(alpha: 0.55),
                          ],
                        ),
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 90, 16, 16),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Container(
                            width: 86,
                            height: 86,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              color: Theme.of(context).colorScheme.surface,
                              border: Border.all(
                                color: Theme.of(context).colorScheme.surface,
                                width: 3,
                              ),
                            ),
                            child: ClipOval(
                              child: logoUrl == null
                                  ? const Icon(Icons.store, size: 40)
                                  : Image.network(logoUrl, fit: BoxFit.cover),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  children: [
                                    Flexible(
                                      child: Text(
                                        name,
                                        maxLines: 1,
                                        overflow: TextOverflow.ellipsis,
                                        style: const TextStyle(
                                          fontSize: 20,
                                          fontWeight: FontWeight.w800,
                                          color: Colors.white,
                                        ),
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    if (verified) _pill('Vérifié'),
                                  ],
                                ),
                                const SizedBox(height: 6),
                                Text(
                                  '@$slug',
                                  style: TextStyle(
                                    color: Colors.white.withValues(alpha: 0.9),
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              bottom: const TabBar(
                tabs: [
                  Tab(text: 'Posts'),
                  Tab(text: 'Produits'),
                  Tab(text: 'Infos'),
                ],
              ),
            ),

            SliverFillRemaining(
              child: TabBarView(
                children: [
                  _PostsTab(
                    posts: _posts,
                    mediaBucket: _postMediaBucket,
                  ),
                  _ProductsTab(
                    products: _products,
                    mediaBucket: _productMediaBucket,
                    currency: _currency,
                    onOpenProduct: (productId) => context.push('/p/$productId'),
                    onQuickAdd: _quickAddToCart,
                  ),
                  _InfosTab(
                    desc: desc,
                    address: address,
                    whatsapp: whatsapp,
                    links: _links,
                    hours: _hours,
                    dowLabel: _dowLabel,
                    formatHours: _formatHours,
                    onCopy: _copy,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _PostsTab extends StatelessWidget {
  final List<Map<String, dynamic>> posts;
  final String mediaBucket;
  const _PostsTab({required this.posts, required this.mediaBucket});

  String? _mediaUrl(String bucket, String? path) {
    if (path == null || path.isEmpty) return null;
    return Supabase.instance.client.storage.from(bucket).getPublicUrl(path);
  }

  @override
  Widget build(BuildContext context) {
    if (posts.isEmpty) {
      return const Center(child: Text('Aucun post pour le moment.'));
    }

    return ListView.separated(
      padding: const EdgeInsets.all(12),
      itemCount: posts.length,
      separatorBuilder: (context, index) => const SizedBox(height: 10),
      itemBuilder: (context, i) {
        final p = posts[i];
        final title = (p['title'] ?? '').toString();
        final content = (p['content'] ?? '').toString();

        final media = (p['post_media'] as List?)?.cast<Map>() ?? [];
        String? thumb;
        if (media.isNotEmpty) {
          final first = Map<String, dynamic>.from(media.first);
          thumb = _mediaUrl(mediaBucket, first['storage_path']?.toString());
        }

        return Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Row(
              children: [
                Container(
                  width: 86,
                  height: 86,
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(14),
                    color: Theme.of(context).colorScheme.surfaceContainerHighest,
                  ),
                  child: thumb == null
                      ? const Icon(Icons.play_circle_outline)
                      : ClipRRect(
                          borderRadius: BorderRadius.circular(14),
                          child: Image.network(thumb, fit: BoxFit.cover),
                        ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title.isEmpty ? 'Post' : title,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: const TextStyle(fontWeight: FontWeight.w700),
                      ),
                      const SizedBox(height: 6),
                      Text(
                        content.isEmpty ? '—' : content,
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

class _ProductsTab extends StatelessWidget {
  final List<Map<String, dynamic>> products;
  final String mediaBucket;
  final String Function(String?) currency;
  final void Function(String productId) onOpenProduct;
  final Future<void> Function(Map<String, dynamic> pr) onQuickAdd;

  const _ProductsTab({
    required this.products,
    required this.mediaBucket,
    required this.currency,
    required this.onOpenProduct,
    required this.onQuickAdd,
  });

  String? _mediaUrl(String bucket, String? path) {
    if (path == null || path.isEmpty) return null;
    return Supabase.instance.client.storage.from(bucket).getPublicUrl(path);
  }

  @override
  Widget build(BuildContext context) {
    if (products.isEmpty) {
      return const Center(child: Text('Aucun produit pour le moment.'));
    }

    return GridView.builder(
      padding: const EdgeInsets.all(12),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        childAspectRatio: 0.92,
        crossAxisSpacing: 12,
        mainAxisSpacing: 12,
      ),
      itemCount: products.length,
      itemBuilder: (context, i) {
        final pr = products[i];
        final id = (pr['id'] ?? '').toString();
        final title = (pr['title'] ?? '').toString();
        final price = pr['price_amount'];
        final cur = currency(pr['currency']?.toString());

        final media = (pr['product_media'] as List?)?.cast<Map>() ?? [];
        String? thumb;
        if (media.isNotEmpty) {
          final first = Map<String, dynamic>.from(media.first);
          thumb = _mediaUrl(mediaBucket, first['storage_path']?.toString());
        }

        return Card(
          child: InkWell(
            borderRadius: BorderRadius.circular(16),
            onTap: () => onOpenProduct(id),
            child: Padding(
              padding: const EdgeInsets.all(10),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Stack(
                      children: [
                        Container(
                          width: double.infinity,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(14),
                            color: Theme.of(context).colorScheme.surfaceContainerHighest,
                          ),
                          child: thumb == null
                              ? const Icon(Icons.inventory_2_outlined)
                              : ClipRRect(
                                  borderRadius: BorderRadius.circular(14),
                                  child: Image.network(thumb, fit: BoxFit.cover),
                                ),
                        ),
                        Positioned(
                          right: 6,
                          bottom: 6,
                          child: Material(
                            color: Colors.black.withValues(alpha: 0.55),
                            borderRadius: BorderRadius.circular(999),
                            child: IconButton(
                              tooltip: 'Ajouter au panier',
                              icon: const Icon(Icons.add_shopping_cart, color: Colors.white),
                              onPressed: () => onQuickAdd(pr),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 10),
                  Text(
                    title,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(fontWeight: FontWeight.w700),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    price == null ? 'Prix: —' : 'Prix: $price $cur',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

class _InfosTab extends StatelessWidget {
  final String desc;
  final String address;
  final String whatsapp;
  final List<Map<String, dynamic>> links;
  final List<Map<String, dynamic>> hours;
  final String Function(int) dowLabel;
  final String Function(Map<String, dynamic>) formatHours;
  final Future<void> Function(String, {String? okMsg}) onCopy;

  const _InfosTab({
    required this.desc,
    required this.address,
    required this.whatsapp,
    required this.links,
    required this.hours,
    required this.dowLabel,
    required this.formatHours,
    required this.onCopy,
  });

  @override
  Widget build(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(12),
      children: [
        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('À propos', style: TextStyle(fontWeight: FontWeight.w800)),
                const SizedBox(height: 8),
                Text(desc.isEmpty ? '—' : desc),
              ],
            ),
          ),
        ),
        const SizedBox(height: 10),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('Contact', style: TextStyle(fontWeight: FontWeight.w800)),
                const SizedBox(height: 8),
                if (address.isNotEmpty) Text('Adresse: $address'),
                const SizedBox(height: 6),
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        whatsapp.isEmpty ? 'WhatsApp: —' : 'WhatsApp: $whatsapp',
                      ),
                    ),
                    if (whatsapp.isNotEmpty)
                      TextButton(
                        onPressed: () => onCopy(whatsapp, okMsg: 'WhatsApp copié'),
                        child: const Text('Copier'),
                      ),
                  ],
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 10),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('Horaires', style: TextStyle(fontWeight: FontWeight.w800)),
                const SizedBox(height: 8),
                if (hours.isEmpty)
                  const Text('—')
                else
                  ...hours.map((h) {
                    final day = (h['day_of_week'] as int?) ?? -1;
                    return Padding(
                      padding: const EdgeInsets.symmetric(vertical: 4),
                      child: Row(
                        children: [
                          SizedBox(width: 46, child: Text(dowLabel(day))),
                          Expanded(child: Text(formatHours(h))),
                        ],
                      ),
                    );
                  }),
              ],
            ),
          ),
        ),
        const SizedBox(height: 10),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('Liens', style: TextStyle(fontWeight: FontWeight.w800)),
                const SizedBox(height: 8),
                if (links.isEmpty)
                  const Text('—')
                else
                  ...links.map((l) {
                    final platform = (l['platform'] ?? '').toString();
                    final url = (l['url'] ?? '').toString();
                    final label = (l['label'] ?? '').toString();
                    final line = label.isNotEmpty ? '$platform: $label' : '$platform: $url';

                    return ListTile(
                      dense: true,
                      contentPadding: EdgeInsets.zero,
                      title: Text(line, maxLines: 1, overflow: TextOverflow.ellipsis),
                      trailing: url.isEmpty
                          ? null
                          : TextButton(
                              onPressed: () => onCopy(url, okMsg: 'Lien copié'),
                              child: const Text('Copier'),
                            ),
                    );
                  }),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\home\home_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  bool _loading = true;
  String? _error;

  List<Map<String, dynamic>> _businesses = [];
  String? _selectedBusinessId;
  Map<String, dynamic>? _entitlements;

  final _sb = Supabase.instance.client;

  Map<String, dynamic>? get _selectedBusiness {
    if (_selectedBusinessId == null) return null;
    for (final b in _businesses) {
      if ((b['id'] ?? '').toString() == _selectedBusinessId) return b;
    }
    return null;
  }

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final user = _sb.auth.currentUser;
      if (user == null) {
        throw Exception('Session manquante. Reconnecte-toi.');
      }

      // businesses where I'm a member
      final rows = await _sb
          .from('business_members')
          .select('business_id, role, businesses:businesses(id,name,slug,logo_path,cover_path)')
          .eq('user_id', user.id);

      final list = (rows as List).map((e) {
        final biz = Map<String, dynamic>.from(e['businesses'] as Map);
        biz['role'] = e['role'];
        return biz;
      }).toList()
        ..sort((a, b) =>
            (a['name'] as String).toLowerCase().compareTo((b['name'] as String).toLowerCase()));

      _businesses = list;

      if (_businesses.isEmpty) {
        _selectedBusinessId = null;
        _entitlements = null;
      } else {
        _selectedBusinessId ??= (_businesses.first['id'] ?? '').toString();
        if (_selectedBusiness == null) {
          _selectedBusinessId = (_businesses.first['id'] ?? '').toString();
        }

        final bid = _selectedBusinessId!;
        final ent = await _sb
            .from('entitlements')
            .select('can_receive_orders, can_run_ads, visibility_multiplier, plans:plans(code,name)')
            .eq('business_id', bid)
            .single();

        _entitlements = Map<String, dynamic>.from(ent as Map);
      }
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _signOut() async {
    try {
      await _sb.auth.signOut();
    } catch (_) {
      // ignore
    }
  }

  String _roleLabel(String role) {
    switch (role) {
      case 'owner':
        return 'Owner';
      case 'admin':
        return 'Admin';
      default:
        return 'Staff';
    }
  }

  String _planName() {
    final planCode = _entitlements?['plans']?['code']?.toString() ?? 'free';
    final planName = _entitlements?['plans']?['name']?.toString() ?? 'Free';
    return '$planName ($planCode)';
  }

  bool get _canOrders => _entitlements?['can_receive_orders'] == true;
  bool get _canAds => _entitlements?['can_run_ads'] == true;

  Future<void> _pickBusiness() async {
    if (_businesses.isEmpty) return;

    final picked = await showModalBottomSheet<String>(
      context: context,
      showDragHandle: true,
      isScrollControlled: true,
      builder: (ctx) {
        final theme = Theme.of(ctx);
        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text('Choisir une entreprise', style: theme.textTheme.titleMedium),
                const SizedBox(height: 12),
                ConstrainedBox(
                  constraints: const BoxConstraints(maxHeight: 520),
                  child: ListView.separated(
                    shrinkWrap: true,
                    itemCount: _businesses.length,
                    separatorBuilder: (_, __) => const Divider(height: 1),
                    itemBuilder: (_, i) {
                      final b = _businesses[i];
                      final id = (b['id'] ?? '').toString();
                      final name = (b['name'] ?? '').toString();
                      final slug = (b['slug'] ?? '').toString();
                      final role = (b['role'] ?? 'staff').toString();
                      final selected = id == _selectedBusinessId;

                      return ListTile(
                        leading: Icon(selected ? Icons.check_circle : Icons.storefront_outlined),
                        title: Text(name, maxLines: 1, overflow: TextOverflow.ellipsis),
                        subtitle: Text('@$slug • ${_roleLabel(role)}'),
                        onTap: () => Navigator.of(ctx).pop(id),
                      );
                    },
                  ),
                ),
                const SizedBox(height: 10),
                SizedBox(
                  width: double.infinity,
                  child: FilledButton.icon(
                    onPressed: () => Navigator.of(ctx).pop('__create__'),
                    icon: const Icon(Icons.add),
                    label: const Text('Créer une entreprise'),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );

    if (!mounted) return;
    if (picked == null) return;

    if (picked == '__create__') {
      context.push('/business/create');
      return;
    }

    setState(() => _selectedBusinessId = picked);
    await _load();
  }

  @override
  Widget build(BuildContext context) {
    final selected = _selectedBusiness;

    return Scaffold(
      body: SafeArea(
        child: _loading
            ? const Center(child: CircularProgressIndicator())
            : RefreshIndicator(
                onRefresh: _load,
                child: CustomScrollView(
                  slivers: [
                    SliverAppBar(
                      pinned: true,
                      floating: true,
                      title: const Text('Dashboard'),
                      actions: [
                        IconButton(
                          tooltip: 'Rafraîchir',
                          onPressed: _load,
                          icon: const Icon(Icons.refresh),
                        ),
                        IconButton(
                          tooltip: 'Déconnexion',
                          onPressed: _signOut,
                          icon: const Icon(Icons.logout),
                        ),
                        const SizedBox(width: 6),
                      ],
                    ),

                    SliverPadding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      sliver: SliverList(
                        delegate: SliverChildListDelegate([
                          if (_error != null)
                            _ErrorBanner(message: _error!, onRetry: _load)
                          else if (_businesses.isEmpty)
                            _EmptyState(onCreate: () => context.push('/business/create'))
                          else ...[
                            _BusinessHeaderCard(
                              business: selected!,
                              planLabel: _planName(),
                              canOrders: _canOrders,
                              canAds: _canAds,
                              onPickBusiness: _pickBusiness,
                              onOpenPublic: () {
                                final slug = (selected['slug'] ?? '').toString();
                                if (slug.isEmpty) return;
                                context.push('/b/$slug');
                              },
                              onOpenSettings: () {
                                final id = (selected['id'] ?? '').toString();
                                if (id.isEmpty) return;
                                context.push('/business/$id/settings');
                              },
                            ),
                            const SizedBox(height: 14),

                            _SectionTitle('Actions rapides'),
                            const SizedBox(height: 10),

                            LayoutBuilder(
                              builder: (context, c) {
                                final w = c.maxWidth;
                                final crossAxisCount = w >= 980
                                    ? 4
                                    : w >= 640
                                        ? 2
                                        : 1;

                                return GridView.count(
                                  crossAxisCount: crossAxisCount,
                                  crossAxisSpacing: 12,
                                  mainAxisSpacing: 12,
                                  childAspectRatio: crossAxisCount == 1 ? 2.4 : 2.0,
                                  shrinkWrap: true,
                                  physics: const NeverScrollableScrollPhysics(),
                                  children: [
                                    _DashTile(
                                      title: 'Mini-site public',
                                      subtitle: 'Voir la boutique publique',
                                      icon: Icons.public,
                                      enabled: true,
                                      onTap: () {
                                        final slug = (selected['slug'] ?? '').toString();
                                        if (slug.isEmpty) return;
                                        context.push('/b/$slug');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Paramètres mini-site',
                                      subtitle: 'Logo, couverture, infos',
                                      icon: Icons.tune,
                                      enabled: true,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/settings');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Membres',
                                      subtitle: 'Roles, accès, staff',
                                      icon: Icons.group,
                                      enabled: true,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/settings/members');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Monétisation',
                                      subtitle: _canOrders ? 'Commandes activées' : 'Activer commandes',
                                      icon: Icons.payments,
                                      enabled: true,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/settings/billing');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Produits',
                                      subtitle: 'Catalogue (variants, stock)',
                                      icon: Icons.inventory_2_outlined,
                                      enabled: true,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/products');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Posts',
                                      subtitle: 'Feed / médias',
                                      icon: Icons.post_add,
                                      enabled: true,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/posts');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Demandes / Commandes',
                                      subtitle: _canOrders ? 'Workflow' : 'Bloqué par le plan',
                                      icon: Icons.receipt_long,
                                      enabled: _canOrders,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/requests');
                                      },
                                    ),
                                    _DashTile(
                                      title: 'Publicités',
                                      subtitle: _canAds ? 'Créer une campagne' : 'Bloqué par le plan',
                                      icon: Icons.campaign,
                                      enabled: _canAds,
                                      onTap: () {
                                        final id = (selected['id'] ?? '').toString();
                                        context.push('/business/$id/settings/ads');
                                      },
                                    ),
                                  ],
                                );
                              },
                            ),

                            const SizedBox(height: 18),
                            _SectionTitle('Qualité & préparation'),
                            const SizedBox(height: 10),
                            _ReadinessCard(business: selected, canOrders: _canOrders),
                            const SizedBox(height: 12),
                          ],
                        ]),
                      ),
                    ),
                  ],
                ),
              ),
      ),
    );
  }
}

class _SectionTitle extends StatelessWidget {
  final String text;
  const _SectionTitle(this.text);

  @override
  Widget build(BuildContext context) {
    return Text(
      text,
      style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w800),
    );
  }
}

class _ErrorBanner extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;
  const _ErrorBanner({required this.message, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Erreur', style: TextStyle(fontWeight: FontWeight.w800)),
            const SizedBox(height: 8),
            Text(message, style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 10),
            FilledButton.icon(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              label: const Text('Réessayer'),
            ),
          ],
        ),
      ),
    );
  }
}

class _EmptyState extends StatelessWidget {
  final VoidCallback onCreate;
  const _EmptyState({required this.onCreate});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Aucune entreprise', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w800)),
            const SizedBox(height: 8),
            const Text(
              "Crée ta première entreprise pour activer le mini-site, les posts, le catalogue et les demandes.",
            ),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: onCreate,
                icon: const Icon(Icons.add_business),
                label: const Text('Créer une entreprise'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _BusinessHeaderCard extends StatelessWidget {
  final Map<String, dynamic> business;
  final String planLabel;
  final bool canOrders;
  final bool canAds;

  final VoidCallback onPickBusiness;
  final VoidCallback onOpenPublic;
  final VoidCallback onOpenSettings;

  const _BusinessHeaderCard({
    required this.business,
    required this.planLabel,
    required this.canOrders,
    required this.canAds,
    required this.onPickBusiness,
    required this.onOpenPublic,
    required this.onOpenSettings,
  });

  @override
  Widget build(BuildContext context) {
    final name = (business['name'] ?? '').toString();
    final slug = (business['slug'] ?? '').toString();
    final role = (business['role'] ?? 'staff').toString();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          children: [
            Row(
              children: [
                const Icon(Icons.storefront_outlined),
                const SizedBox(width: 10),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(name, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w900)),
                      const SizedBox(height: 2),
                      Text('@$slug • ${role.toUpperCase()}'),
                    ],
                  ),
                ),
                IconButton(
                  tooltip: 'Changer entreprise',
                  onPressed: onPickBusiness,
                  icon: const Icon(Icons.swap_horiz),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Wrap(
              spacing: 10,
              runSpacing: 10,
              children: [
                _Badge(label: 'Plan', value: planLabel),
                _Badge(label: 'Commandes', value: canOrders ? 'Activées' : 'OFF'),
                _Badge(label: 'Ads', value: canAds ? 'Activées' : 'OFF'),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: FilledButton.icon(
                    onPressed: onOpenSettings,
                    icon: const Icon(Icons.tune),
                    label: const Text('Paramètres'),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: onOpenPublic,
                    icon: const Icon(Icons.public),
                    label: const Text('Mini-site'),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class _Badge extends StatelessWidget {
  final String label;
  final String value;
  const _Badge({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Chip(
      label: Text('$label: $value', overflow: TextOverflow.ellipsis),
    );
  }
}

class _DashTile extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final bool enabled;
  final VoidCallback onTap;

  const _DashTile({
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.enabled,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: enabled ? onTap : null,
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Opacity(
            opacity: enabled ? 1 : 0.45,
            child: Row(
              children: [
                Icon(icon, size: 26),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(title, style: const TextStyle(fontWeight: FontWeight.w800)),
                      const SizedBox(height: 4),
                      Text(subtitle, maxLines: 2, overflow: TextOverflow.ellipsis),
                    ],
                  ),
                ),
                Icon(enabled ? Icons.arrow_forward : Icons.lock, size: 18),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _ReadinessCard extends StatelessWidget {
  final Map<String, dynamic> business;
  final bool canOrders;

  const _ReadinessCard({required this.business, required this.canOrders});

  @override
  Widget build(BuildContext context) {
    final missing = <String>[];

    // Ces champs existent dans ton schema
    final logo = (business['logo_path'] ?? '').toString().trim();
    final cover = (business['cover_path'] ?? '').toString().trim();

    if (logo.isEmpty) missing.add('Logo');
    if (cover.isEmpty) missing.add('Couverture');
    if (!canOrders) missing.add('Activation commandes');

    final ok = missing.isEmpty;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Row(
          children: [
            Icon(ok ? Icons.verified : Icons.info_outline),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(ok ? 'Prêt pour le public' : 'À compléter',
                      style: const TextStyle(fontWeight: FontWeight.w900)),
                  const SizedBox(height: 4),
                  Text(ok ? 'Ton mini-site est prêt.' : 'Manque: ${missing.join(', ')}'),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\products\business_products_page.dart

import 'dart:typed_data';

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessProductsPage extends StatefulWidget {
  final String businessId;
  const BusinessProductsPage({super.key, required this.businessId});

  @override
  State<BusinessProductsPage> createState() => _BusinessProductsPageState();
}

enum _ProdFilter { active, inactive, missingPrice, missingMedia, hasVideo }

class _BusinessProductsPageState extends State<BusinessProductsPage> {
  static const _productMediaBucket = 'product_media';

  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;
  List<Map<String, dynamic>> _products = [];

  final _searchCtrl = TextEditingController();
  String _query = '';
  final Set<_ProdFilter> _filters = {};

  @override
  void initState() {
    super.initState();
    _searchCtrl.addListener(() {
      final q = _searchCtrl.text.trim().toLowerCase();
      if (q == _query) return;
      setState(() => _query = q);
    });
    _load();
  }

  @override
  void dispose() {
    _searchCtrl.dispose();
    super.dispose();
  }

  Future<void> _ensureAuthenticated() async {
    await _sb.auth.refreshSession();
    if (_sb.auth.currentSession == null || _sb.auth.currentUser == null) {
      throw Exception('Session manquante. Déconnecte-toi puis reconnecte-toi.');
    }
  }

  Map<String, dynamic>? _firstMedia(Map<String, dynamic> productRow) {
    final media = productRow['product_media'];
    if (media is List && media.isNotEmpty) {
      return Map<String, dynamic>.from(media.first as Map);
    }
    if (media is Map) return Map<String, dynamic>.from(media);
    return null;
  }

  String? _firstMediaType(Map<String, dynamic> productRow) {
    final m = _firstMedia(productRow);
    return m?['media_type']?.toString();
  }

  bool _hasMedia(Map<String, dynamic> productRow) {
    final media = productRow['product_media'];
    return (media is List && media.isNotEmpty);
  }

  bool _hasPrice(Map<String, dynamic> productRow) {
    return productRow['price_amount'] != null;
  }

  bool _isActive(Map<String, dynamic> productRow) {
    return productRow['is_active'] == true;
  }

  bool _isVideo(Map<String, dynamic> productRow) {
    final mt = (_firstMediaType(productRow) ?? '').toLowerCase();
    return mt == 'video';
  }

  String? _thumbUrlIfImage(Map<String, dynamic> productRow) {
    final m = _firstMedia(productRow);
    if (m == null) return null;

    final type = (m['media_type'] ?? '').toString().toLowerCase();
    if (type != 'image') return null;

    final path = (m['storage_path'] ?? '').toString();
    if (path.isEmpty) return null;

    return _sb.storage.from(_productMediaBucket).getPublicUrl(path);
  }

  List<Map<String, dynamic>> get _filteredProducts {
    var list = List<Map<String, dynamic>>.from(_products);

    if (_query.isNotEmpty) {
      list = list.where((p) {
        final title = (p['title'] ?? '').toString().toLowerCase();
        return title.contains(_query);
      }).toList();
    }

    if (_filters.isNotEmpty) {
      list = list.where((p) {
        final active = _isActive(p);
        final hasPrice = _hasPrice(p);
        final hasMedia = _hasMedia(p);
        final isVideo = _isVideo(p);

        if (_filters.contains(_ProdFilter.active) && !active) return false;
        if (_filters.contains(_ProdFilter.inactive) && active) return false;
        if (_filters.contains(_ProdFilter.missingPrice) && hasPrice) return false;
        if (_filters.contains(_ProdFilter.missingMedia) && hasMedia) return false;
        if (_filters.contains(_ProdFilter.hasVideo) && !isVideo) return false;

        return true;
      }).toList();
    }

    return list;
  }

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      await _ensureAuthenticated();

      final rows = await _sb
          .from('products')
          .select(
            'id,title,price_amount,currency,is_active,created_at,product_media(id,media_type,storage_path)',
          )
          .eq('business_id', widget.businessId)
          .order('created_at', ascending: false);

      _products = (rows as List)
          .map((e) => Map<String, dynamic>.from(e as Map))
          .toList();
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _openCreate() async {
    final createdProductId = await showModalBottomSheet<String>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (_) => _CreateProductSheet(businessId: widget.businessId),
    );

    if (createdProductId == null || createdProductId.isEmpty) return;

    await _load();
    if (!mounted) return;

    context.push('/business/${widget.businessId}/products/$createdProductId');
  }

  Future<void> _quickToggleActive(Map<String, dynamic> p) async {
    final id = (p['id'] ?? '').toString();
    if (id.isEmpty) return;
    final next = !(p['is_active'] == true);

    try {
      await _ensureAuthenticated();
      await _sb.from('products').update({'is_active': next}).eq('id', id);
      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final list = _filteredProducts;

    return Scaffold(
      body: SafeArea(
        child: RefreshIndicator(
          onRefresh: _load,
          child: CustomScrollView(
            slivers: [
              SliverAppBar(
                pinned: true,
                floating: true,
                title: const Text('Produits'),
                actions: [
                  IconButton(
                    tooltip: 'Rafraîchir',
                    onPressed: _loading ? null : _load,
                    icon: const Icon(Icons.refresh),
                  ),
                  IconButton(
                    tooltip: 'Nouveau produit',
                    onPressed: _openCreate,
                    icon: const Icon(Icons.add),
                  ),
                  const SizedBox(width: 6),
                ],
                bottom: PreferredSize(
                  preferredSize: const Size.fromHeight(118),
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
                    child: Column(
                      children: [
                        TextField(
                          controller: _searchCtrl,
                          decoration: InputDecoration(
                            hintText: 'Rechercher un produit…',
                            prefixIcon: const Icon(Icons.search),
                            suffixIcon: _query.isEmpty
                                ? null
                                : IconButton(
                                    tooltip: 'Effacer',
                                    onPressed: () => _searchCtrl.clear(),
                                    icon: const Icon(Icons.close),
                                  ),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(14),
                            ),
                          ),
                        ),
                        const SizedBox(height: 10),
                        Align(
                          alignment: Alignment.centerLeft,
                          child: SingleChildScrollView(
                            scrollDirection: Axis.horizontal,
                            child: Wrap(
                              spacing: 10,
                              children: [
                                FilterChip(
                                  label: const Text('Actifs'),
                                  selected: _filters.contains(_ProdFilter.active),
                                  onSelected: (v) => setState(() {
                                    v ? _filters.add(_ProdFilter.active) : _filters.remove(_ProdFilter.active);
                                    if (v) _filters.remove(_ProdFilter.inactive);
                                  }),
                                ),
                                FilterChip(
                                  label: const Text('Inactifs'),
                                  selected: _filters.contains(_ProdFilter.inactive),
                                  onSelected: (v) => setState(() {
                                    v ? _filters.add(_ProdFilter.inactive) : _filters.remove(_ProdFilter.inactive);
                                    if (v) _filters.remove(_ProdFilter.active);
                                  }),
                                ),
                                FilterChip(
                                  label: const Text('Prix manquant'),
                                  selected: _filters.contains(_ProdFilter.missingPrice),
                                  onSelected: (v) => setState(() {
                                    v ? _filters.add(_ProdFilter.missingPrice) : _filters.remove(_ProdFilter.missingPrice);
                                  }),
                                ),
                                FilterChip(
                                  label: const Text('Média manquant'),
                                  selected: _filters.contains(_ProdFilter.missingMedia),
                                  onSelected: (v) => setState(() {
                                    v ? _filters.add(_ProdFilter.missingMedia) : _filters.remove(_ProdFilter.missingMedia);
                                  }),
                                ),
                                FilterChip(
                                  label: const Text('Avec vidéo'),
                                  selected: _filters.contains(_ProdFilter.hasVideo),
                                  onSelected: (v) => setState(() {
                                    v ? _filters.add(_ProdFilter.hasVideo) : _filters.remove(_ProdFilter.hasVideo);
                                  }),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),

              if (_loading)
                const SliverFillRemaining(
                  child: Center(child: CircularProgressIndicator()),
                )
              else if (_error != null)
                SliverFillRemaining(
                  child: Center(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Text(_error!, style: const TextStyle(color: Colors.red)),
                    ),
                  ),
                )
              else if (_products.isEmpty)
                SliverFillRemaining(
                  child: Center(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Text('Aucun produit. Ajoute ton premier produit.'),
                          const SizedBox(height: 12),
                          FilledButton.icon(
                            onPressed: _openCreate,
                            icon: const Icon(Icons.add),
                            label: const Text('Créer un produit'),
                          ),
                        ],
                      ),
                    ),
                  ),
                )
              else if (list.isEmpty)
                const SliverFillRemaining(
                  child: Center(child: Text('Aucun résultat pour ce filtre/recherche.')),
                )
              else
                SliverPadding(
                  padding: const EdgeInsets.all(16),
                  sliver: SliverList.separated(
                    itemCount: list.length,
                    separatorBuilder: (_, __) => const SizedBox(height: 10),
                    itemBuilder: (context, i) {
                      final p = list[i];

                      final title = (p['title'] ?? '').toString();
                      final price = p['price_amount'];
                      final cur = p['currency']?.toString() ?? 'XOF';
                      final active = _isActive(p);

                      final thumb = _thumbUrlIfImage(p);
                      final hasMedia = _hasMedia(p);
                      final hasPrice = _hasPrice(p);

                      final isVideo = _isVideo(p);

                      final complete = active && hasPrice && hasMedia;

                      return Card(
                        child: ListTile(
                          leading: Container(
                            width: 56,
                            height: 56,
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(12),
                              color: Theme.of(context).colorScheme.surfaceContainerHighest,
                            ),
                            clipBehavior: Clip.antiAlias,
                            child: thumb != null
                                ? Image.network(
                                    thumb,
                                    fit: BoxFit.cover,
                                    errorBuilder: (_, __, ___) => const Icon(Icons.broken_image),
                                  )
                                : Center(
                                    child: Icon(
                                      !hasMedia ? Icons.image_not_supported : (isVideo ? Icons.play_circle_outline : Icons.image),
                                    ),
                                  ),
                          ),
                          title: Text(
                            title,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                          subtitle: Wrap(
                            spacing: 8,
                            runSpacing: 6,
                            children: [
                              Chip(label: Text(active ? 'Actif' : 'Inactif')),
                              Chip(label: Text(complete ? 'Complet' : 'À compléter')),
                              if (!hasPrice) const Chip(label: Text('Prix manquant')),
                              if (!hasMedia) const Chip(label: Text('Média manquant')),
                              if (hasMedia && isVideo) const Chip(label: Text('Vidéo')),
                            ],
                          ),
                          trailing: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Text(hasPrice ? '$price $cur' : '—', style: const TextStyle(fontWeight: FontWeight.w800)),
                              const SizedBox(height: 6),
                              PopupMenuButton<String>(
                                onSelected: (v) {
                                  if (v == 'toggle') _quickToggleActive(p);
                                },
                                itemBuilder: (_) => [
                                  PopupMenuItem(
                                    value: 'toggle',
                                    child: Text(active ? 'Désactiver' : 'Activer'),
                                  ),
                                ],
                              ),
                            ],
                          ),
                          onTap: () => context.push('/business/${widget.businessId}/products/${p['id']}'),
                        ),
                      );
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

// -------------------------
// Create product (PRO sheet)
// -------------------------

class _PickedMedia {
  final Uint8List bytes;
  final String ext; // sans point
  final String type; // image | video
  final String name; // affichage (nom original)

  _PickedMedia({
    required this.bytes,
    required this.ext,
    required this.type,
    required this.name,
  });
}

class _CreateProductSheet extends StatefulWidget {
  final String businessId;
  const _CreateProductSheet({required this.businessId});

  @override
  State<_CreateProductSheet> createState() => _CreateProductSheetState();
}

class _CreateProductSheetState extends State<_CreateProductSheet> {
  static const _productMediaBucket = 'product_media';

  final _sb = Supabase.instance.client;

  final _formKey = GlobalKey<FormState>();

  final _titleCtrl = TextEditingController();
  final _descCtrl = TextEditingController();
  final _priceCtrl = TextEditingController();

  String _currency = 'XOF';
  bool _isActive = true;

  bool _confirmed = false;

  // Media (multi)
  final List<_PickedMedia> _medias = [];

  // Categories
  bool _loadingCats = true;
  List<Map<String, dynamic>> _categories = [];
  final Set<String> _selectedCategoryIds = {};

  bool _saving = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadCategories();
  }

  @override
  void dispose() {
    _titleCtrl.dispose();
    _descCtrl.dispose();
    _priceCtrl.dispose();
    super.dispose();
  }

  Future<void> _ensureAuthenticated() async {
    await _sb.auth.refreshSession();
    if (_sb.auth.currentSession == null || _sb.auth.currentUser == null) {
      throw Exception('Session manquante. Déconnecte-toi puis reconnecte-toi.');
    }
  }

  Future<void> _loadCategories() async {
    setState(() => _loadingCats = true);
    try {
      final cats = await _sb.from('categories').select('id,name').order('name');
      _categories = (cats as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
    } catch (_) {
      // pas bloquant
    } finally {
      if (!mounted) return;
      setState(() => _loadingCats = false);
    }
  }

  String _extFromName(String name) {
    final idx = name.lastIndexOf('.');
    if (idx <= 0 || idx == name.length - 1) return '';
    return name.substring(idx + 1).toLowerCase();
  }

  bool _isVideoExt(String ext) {
    const vids = {'mp4', 'mov', 'm4v', 'avi', 'webm', 'mkv'};
    return vids.contains(ext.toLowerCase());
  }

  bool _isImageExt(String ext) {
    const imgs = {'jpg', 'jpeg', 'png', 'webp', 'gif'};
    return imgs.contains(ext.toLowerCase());
  }

  String _contentTypeFromExt(String ext) {
    final e = ext.toLowerCase();
    switch (e) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'webp':
        return 'image/webp';
      case 'gif':
        return 'image/gif';
      case 'mp4':
        return 'video/mp4';
      case 'mov':
        return 'video/quicktime';
      case 'webm':
        return 'video/webm';
      case 'm4v':
        return 'video/x-m4v';
      case 'avi':
        return 'video/x-msvideo';
      case 'mkv':
        return 'video/x-matroska';
      default:
        return 'application/octet-stream';
    }
  }

  Future<void> _pickMedia() async {
    setState(() => _error = null);

    if (_medias.length >= 8) {
      setState(() => _error = 'Limite: 8 médias maximum.');
      return;
    }

    final res = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: const [
        'jpg', 'jpeg', 'png', 'webp', 'gif',
        'mp4', 'mov', 'm4v', 'avi', 'webm', 'mkv',
      ],
      withData: true,
    );

    if (res == null || res.files.isEmpty) return;

    final f = res.files.first;
    final bytes = f.bytes;
    final name = f.name;

    var ext = (f.extension ?? '').toLowerCase();
    if (ext.isEmpty) ext = _extFromName(name);
    if (ext.startsWith('.')) ext = ext.substring(1);

    if (bytes == null || bytes.isEmpty) {
      setState(() => _error = 'Impossible de lire le fichier (bytes null).');
      return;
    }
    if (ext.isEmpty) {
      setState(() => _error = 'Extension inconnue. Choisis un fichier image/vidéo standard.');
      return;
    }

    final isVideo = _isVideoExt(ext);
    final isImage = _isImageExt(ext);

    if (!isVideo && !isImage) {
      setState(() => _error = 'Type non supporté: .$ext');
      return;
    }

    setState(() {
      _medias.add(
        _PickedMedia(
          bytes: bytes,
          ext: ext,
          type: isVideo ? 'video' : 'image',
          name: name,
        ),
      );
    });
  }

  Future<void> _createCategory() async {
    final ctrl = TextEditingController();
    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Nouvelle catégorie'),
        content: TextField(
          controller: ctrl,
          decoration: const InputDecoration(labelText: 'Nom'),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
          FilledButton(onPressed: () => Navigator.pop(context, true), child: const Text('Créer')),
        ],
      ),
    );

    if (ok != true) {
      ctrl.dispose();
      return;
    }

    final name = ctrl.text.trim();
    ctrl.dispose();
    if (name.isEmpty) return;

    try {
      await _ensureAuthenticated();
      final row = await _sb.from('categories').insert({'name': name}).select('id').single();
      final id = (row['id'] ?? '').toString();
      await _loadCategories();
      if (!mounted) return;
      setState(() {
        if (id.isNotEmpty) _selectedCategoryIds.add(id);
      });
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = 'Erreur création catégorie: $e');
    }
  }

  Future<void> _submit() async {
    final messenger = ScaffoldMessenger.of(context);
    setState(() => _error = null);

    if (!_formKey.currentState!.validate()) return;

    if (_medias.isEmpty) {
      setState(() => _error = 'Média obligatoire: ajoute une photo ou une vidéo.');
      return;
    }
    if (!_confirmed) {
      setState(() => _error = 'Tu dois cocher la confirmation de validation.');
      return;
    }

    final title = _titleCtrl.text.trim();
    final desc = _descCtrl.text.trim();

    final price = num.tryParse(_priceCtrl.text.trim().replaceAll(',', '.'));
    if (price == null || price <= 0) {
      setState(() => _error = 'Prix invalide (doit être un nombre > 0).');
      return;
    }

    setState(() => _saving = true);

    String? productId;
    final uploadedPaths = <String>[];

    try {
      await _ensureAuthenticated();

      // 1) Create product
      final inserted = await _sb
          .from('products')
          .insert({
            'business_id': widget.businessId,
            'title': title,
            'description': desc.isEmpty ? null : desc,
            'price_amount': price,
            'currency': _currency,
            'is_active': _isActive,
          })
          .select('id')
          .single();

      productId = (inserted['id'] as String);

      // 2) Upload + insert product_media
      for (final m in _medias) {
        final objectPath =
            '${widget.businessId}/products/$productId/media_${DateTime.now().millisecondsSinceEpoch}_${uploadedPaths.length}.${m.ext}';

        await _sb.storage.from(_productMediaBucket).uploadBinary(
              objectPath,
              m.bytes,
              fileOptions: FileOptions(
                upsert: true,
                contentType: _contentTypeFromExt(m.ext),
              ),
            );

        uploadedPaths.add(objectPath);

        await _sb.from('product_media').insert({
          'product_id': productId,
          'media_type': m.type,
          'storage_path': objectPath,
        });
      }

      // 3) Map categories (safe upsert)
      if (_selectedCategoryIds.isNotEmpty) {
        final rows = _selectedCategoryIds
            .map((id) => {'product_id': productId, 'category_id': id})
            .toList();

        await _sb.from('product_categories_map').upsert(
              rows,
              onConflict: 'product_id,category_id',
            );
      }

      // 4) Create a default variant (recommended for stock workflow)
      await _sb.from('product_variants').insert({
        'product_id': productId,
        'title': 'Standard',
        'sku': null,
        'options': {},
        'price_amount': null,
        'currency': _currency,
        'is_active': true,
      });

      messenger.showSnackBar(const SnackBar(content: Text('Produit créé avec succès.')));
      if (!mounted) return;

      Navigator.of(context).pop(productId);
    } on StorageException catch (e) {
      await _rollback(productId, uploadedPaths);
      setState(() => _error = 'Storage error: ${e.message}');
    } on PostgrestException catch (e) {
      await _rollback(productId, uploadedPaths);
      setState(() => _error = 'DB error: ${e.message}');
    } catch (e) {
      await _rollback(productId, uploadedPaths);
      setState(() => _error = e.toString());
    } finally {
      if (!mounted) return;
      setState(() => _saving = false);
    }
  }

  Future<void> _rollback(String? productId, List<String> uploadedPaths) async {
    try {
      // remove storage objects
      if (uploadedPaths.isNotEmpty) {
        try {
          await _sb.storage.from(_productMediaBucket).remove(uploadedPaths);
        } catch (_) {}
      }
      if (productId != null) {
        try {
          await _sb.from('products').delete().eq('id', productId);
        } catch (_) {
          try {
            await _sb.from('products').update({'is_active': false}).eq('id', productId);
          } catch (_) {}
        }
      }
    } catch (_) {
      // ignore rollback failure
    }
  }

  @override
  Widget build(BuildContext context) {
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    return SafeArea(
      child: Padding(
        padding: EdgeInsets.fromLTRB(16, 8, 16, 16 + bottomInset),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  const Expanded(
                    child: Text(
                      'Nouveau produit',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.w900),
                    ),
                  ),
                  IconButton(
                    tooltip: 'Fermer',
                    onPressed: _saving ? null : () => Navigator.of(context).pop(),
                    icon: const Icon(Icons.close),
                  ),
                ],
              ),

              if (_error != null) ...[
                const SizedBox(height: 8),
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(10),
                  decoration: BoxDecoration(
                    color: Colors.red.withOpacity(0.10),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(_error!, style: const TextStyle(color: Colors.red)),
                ),
              ],

              const SizedBox(height: 12),

              Form(
                key: _formKey,
                child: Column(
                  children: [
                    TextFormField(
                      controller: _titleCtrl,
                      decoration: const InputDecoration(labelText: 'Titre *'),
                      textInputAction: TextInputAction.next,
                      validator: (v) => (v == null || v.trim().isEmpty) ? 'Titre requis' : null,
                    ),
                    const SizedBox(height: 10),
                    TextFormField(
                      controller: _descCtrl,
                      decoration: const InputDecoration(labelText: 'Description (optionnel)'),
                      minLines: 2,
                      maxLines: 4,
                    ),
                    const SizedBox(height: 10),
                    Row(
                      children: [
                        Expanded(
                          child: TextFormField(
                            controller: _priceCtrl,
                            decoration: const InputDecoration(labelText: 'Prix *'),
                            keyboardType: TextInputType.number,
                            validator: (v) {
                              final txt = (v ?? '').trim().replaceAll(',', '.');
                              final p = num.tryParse(txt);
                              if (p == null || p <= 0) return 'Prix invalide';
                              return null;
                            },
                          ),
                        ),
                        const SizedBox(width: 10),
                        DropdownButton<String>(
                          value: _currency,
                          items: const [
                            DropdownMenuItem(value: 'XOF', child: Text('XOF')),
                            DropdownMenuItem(value: 'USD', child: Text('USD')),
                            DropdownMenuItem(value: 'EUR', child: Text('EUR')),
                          ],
                          onChanged: _saving ? null : (v) => setState(() => _currency = v ?? 'XOF'),
                        ),
                      ],
                    ),
                    const SizedBox(height: 10),
                    SwitchListTile(
                      value: _isActive,
                      onChanged: _saving ? null : (v) => setState(() => _isActive = v),
                      title: const Text('Actif (visible au public)'),
                      subtitle: const Text('Si désactivé, le produit ne sera pas visible sur Explorer.'),
                    ),

                    const SizedBox(height: 8),
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        'Catégories (optionnel)',
                        style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w800),
                      ),
                    ),
                    const SizedBox(height: 8),
                    if (_loadingCats)
                      const Align(alignment: Alignment.centerLeft, child: CircularProgressIndicator())
                    else
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          ..._categories.map((c) {
                            final id = c['id'].toString();
                            final name = c['name'].toString();
                            final selected = _selectedCategoryIds.contains(id);
                            return FilterChip(
                              label: Text(name),
                              selected: selected,
                              onSelected: _saving
                                  ? null
                                  : (v) => setState(() {
                                        v ? _selectedCategoryIds.add(id) : _selectedCategoryIds.remove(id);
                                      }),
                            );
                          }),
                          ActionChip(
                            label: const Text('Ajouter catégorie'),
                            avatar: const Icon(Icons.add, size: 18),
                            onPressed: _saving ? null : _createCategory,
                          ),
                        ],
                      ),

                    const SizedBox(height: 14),
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        'Médias * (photo/vidéo)',
                        style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w800),
                      ),
                    ),
                    const SizedBox(height: 8),

                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton.icon(
                            onPressed: _saving ? null : _pickMedia,
                            icon: const Icon(Icons.upload_file),
                            label: Text(_medias.isEmpty ? 'Ajouter un média' : 'Ajouter un autre'),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 10),

                    if (_medias.isNotEmpty)
                      Column(
                        children: List.generate(_medias.length, (i) {
                          final m = _medias[i];
                          return Card(
                            child: ListTile(
                              leading: Container(
                                width: 52,
                                height: 52,
                                decoration: BoxDecoration(
                                  borderRadius: BorderRadius.circular(12),
                                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                                ),
                                clipBehavior: Clip.antiAlias,
                                child: m.type == 'image'
                                    ? Image.memory(m.bytes, fit: BoxFit.cover)
                                    : const Icon(Icons.play_circle_outline, size: 30),
                              ),
                              title: Text(m.name, maxLines: 1, overflow: TextOverflow.ellipsis),
                              subtitle: Text('Type: ${m.type} • .${m.ext}'),
                              trailing: IconButton(
                                tooltip: 'Retirer',
                                onPressed: _saving ? null : () => setState(() => _medias.removeAt(i)),
                                icon: const Icon(Icons.delete_outline),
                              ),
                            ),
                          );
                        }),
                      ),

                    const SizedBox(height: 10),
                    CheckboxListTile(
                      value: _confirmed,
                      onChanged: _saving ? null : (v) => setState(() => _confirmed = v ?? false),
                      title: const Text('Je confirme que le prix et les médias sont corrects. *'),
                      controlAffinity: ListTileControlAffinity.leading,
                      contentPadding: EdgeInsets.zero,
                    ),

                    const SizedBox(height: 12),
                    SizedBox(
                      width: double.infinity,
                      child: FilledButton.icon(
                        onPressed: _saving ? null : _submit,
                        icon: const Icon(Icons.check),
                        label: Text(_saving ? 'Création...' : 'Créer le produit'),
                      ),
                    ),
                    const SizedBox(height: 8),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\products\product_detail_page.dart

import 'dart:typed_data';

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class ProductDetailPage extends StatefulWidget {
  final String businessId;
  final String productId;
  const ProductDetailPage({
    super.key,
    required this.businessId,
    required this.productId,
  });

  @override
  State<ProductDetailPage> createState() => _ProductDetailPageState();
}

class _ProductDetailPageState extends State<ProductDetailPage> {
  static const _productMediaBucket = 'product_media';

  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;

  Map<String, dynamic>? _product;
  List<Map<String, dynamic>> _productMedia = [];

  List<Map<String, dynamic>> _variants = [];
  Map<String, int> _onHandByVariant = {};

  List<Map<String, dynamic>> _categories = [];
  Set<String> _selectedCategoryIds = {};

  // Optionnel: si table variant_media existe
  bool _variantMediaAvailable = true;
  Map<String, int> _variantMediaCounts = {};

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _ensureAuthenticated() async {
    await _sb.auth.refreshSession();
    if (_sb.auth.currentSession == null || _sb.auth.currentUser == null) {
      throw Exception('Session manquante. Déconnecte-toi puis reconnecte-toi.');
    }
  }

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      await _ensureAuthenticated();

      final p = await _sb
          .from('products')
          .select('id,business_id,title,description,price_amount,currency,is_active')
          .eq('id', widget.productId)
          .single();

      _product = Map<String, dynamic>.from(p as Map);

      final pm = await _sb
          .from('product_media')
          .select('id,media_type,storage_path')
          .eq('product_id', widget.productId);

      _productMedia = (pm as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final v = await _sb
          .from('product_variants')
          .select('id,title,sku,options,price_amount,currency,is_active,created_at')
          .eq('product_id', widget.productId)
          .order('created_at', ascending: false);

      _variants = (v as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final oh = await _sb
          .from('inventory_on_hand')
          .select('variant_id,on_hand')
          .eq('product_id', widget.productId);

      _onHandByVariant = {
        for (final r in (oh as List))
          (r as Map)['variant_id'].toString(): ((r)['on_hand'] as num?)?.toInt() ?? 0
      };

      final cats = await _sb.from('categories').select('id,name').order('name');
      _categories = (cats as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final pcm = await _sb
          .from('product_categories_map')
          .select('category_id')
          .eq('product_id', widget.productId);

      _selectedCategoryIds = (pcm as List)
          .map((e) => (e as Map)['category_id'].toString())
          .toSet();

      await _tryLoadVariantMediaCounts();
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _tryLoadVariantMediaCounts() async {
    if (_variants.isEmpty) return;

    try {
      // This will fail if table doesn't exist (we handle it)
      final ids = _variants.map((v) => v['id'].toString()).toList();

      // Supabase doesn't have group by easily; simplest: fetch rows and count locally
      final rows = await _sb
          .from('variant_media')
          .select('variant_id')
          .inFilter('variant_id', ids);

      final counts = <String, int>{};
      for (final r in (rows as List)) {
        final vid = (r as Map)['variant_id'].toString();
        counts[vid] = (counts[vid] ?? 0) + 1;
      }

      _variantMediaCounts = counts;
      _variantMediaAvailable = true;
    } catch (_) {
      _variantMediaAvailable = false;
      _variantMediaCounts = {};
    }
  }

  String _currency() => (_product?['currency'] ?? 'XOF').toString();

  String? _publicUrl(String? path) {
    if (path == null || path.isEmpty) return null;
    return _sb.storage.from(_productMediaBucket).getPublicUrl(path);
  }

  bool get _isActive => _product?['is_active'] == true;

  bool get _hasPrice => _product?['price_amount'] != null;

  bool get _hasMedia => _productMedia.isNotEmpty;

  Future<void> _toggleActive(bool v) async {
    try {
      await _ensureAuthenticated();
      await _sb.from('products').update({'is_active': v}).eq('id', widget.productId);
      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _editProduct() async {
    final titleCtrl = TextEditingController(text: _product?['title']?.toString() ?? '');
    final descCtrl = TextEditingController(text: _product?['description']?.toString() ?? '');
    final priceCtrl = TextEditingController(text: _product?['price_amount']?.toString() ?? '');

    final ok = await showModalBottomSheet<bool>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (ctx) {
        final bottomInset = MediaQuery.of(ctx).viewInsets.bottom;
        return SafeArea(
          child: Padding(
            padding: EdgeInsets.fromLTRB(16, 12, 16, 16 + bottomInset),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Align(
                  alignment: Alignment.centerLeft,
                  child: Text('Modifier produit', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w900)),
                ),
                const SizedBox(height: 10),
                TextField(controller: titleCtrl, decoration: const InputDecoration(labelText: 'Titre')),
                const SizedBox(height: 10),
                TextField(
                  controller: descCtrl,
                  decoration: const InputDecoration(labelText: 'Description'),
                  minLines: 2,
                  maxLines: 4,
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: priceCtrl,
                  decoration: const InputDecoration(labelText: 'Prix (optionnel)'),
                  keyboardType: TextInputType.number,
                ),
                const SizedBox(height: 14),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () => Navigator.pop(ctx, false),
                        child: const Text('Annuler'),
                      ),
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: FilledButton(
                        onPressed: () => Navigator.pop(ctx, true),
                        child: const Text('Enregistrer'),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );

    if (ok != true) {
      titleCtrl.dispose();
      descCtrl.dispose();
      priceCtrl.dispose();
      return;
    }

    try {
      await _ensureAuthenticated();
      final price = num.tryParse(priceCtrl.text.trim().replaceAll(',', '.'));
      await _sb.from('products').update({
        'title': titleCtrl.text.trim(),
        'description': descCtrl.text.trim().isEmpty ? null : descCtrl.text.trim(),
        'price_amount': price,
      }).eq('id', widget.productId);

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    } finally {
      titleCtrl.dispose();
      descCtrl.dispose();
      priceCtrl.dispose();
    }
  }

  // -------------------
  // Product media manage
  // -------------------

  String _extFromName(String name) {
    final idx = name.lastIndexOf('.');
    if (idx <= 0 || idx == name.length - 1) return '';
    return name.substring(idx + 1).toLowerCase();
  }

  bool _isVideoExt(String ext) {
    const vids = {'mp4', 'mov', 'm4v', 'avi', 'webm', 'mkv'};
    return vids.contains(ext.toLowerCase());
  }

  bool _isImageExt(String ext) {
    const imgs = {'jpg', 'jpeg', 'png', 'webp', 'gif'};
    return imgs.contains(ext.toLowerCase());
  }

  String _contentTypeFromExt(String ext) {
    final e = ext.toLowerCase();
    switch (e) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'webp':
        return 'image/webp';
      case 'gif':
        return 'image/gif';
      case 'mp4':
        return 'video/mp4';
      case 'mov':
        return 'video/quicktime';
      case 'webm':
        return 'video/webm';
      case 'm4v':
        return 'video/x-m4v';
      case 'avi':
        return 'video/x-msvideo';
      case 'mkv':
        return 'video/x-matroska';
      default:
        return 'application/octet-stream';
    }
  }

  Future<void> _addProductMedia() async {
    try {
      await _ensureAuthenticated();

      final res = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: const [
          'jpg', 'jpeg', 'png', 'webp', 'gif',
          'mp4', 'mov', 'm4v', 'avi', 'webm', 'mkv',
        ],
        withData: true,
      );
      if (res == null || res.files.isEmpty) return;

      final f = res.files.first;
      final bytes = f.bytes;
      if (bytes == null || bytes.isEmpty) throw Exception('Impossible de lire le fichier.');

      final name = f.name;
      var ext = (f.extension ?? '').toLowerCase();
      if (ext.isEmpty) ext = _extFromName(name);
      if (ext.startsWith('.')) ext = ext.substring(1);

      if (ext.isEmpty) throw Exception('Extension inconnue.');
      final isVideo = _isVideoExt(ext);
      final isImage = _isImageExt(ext);
      if (!isVideo && !isImage) throw Exception('Type non supporté: .$ext');

      final type = isVideo ? 'video' : 'image';

      final objectPath =
          '${widget.businessId}/products/${widget.productId}/media_${DateTime.now().millisecondsSinceEpoch}.$ext';

      await _sb.storage.from(_productMediaBucket).uploadBinary(
            objectPath,
            bytes,
            fileOptions: FileOptions(
              upsert: true,
              contentType: _contentTypeFromExt(ext),
            ),
          );

      await _sb.from('product_media').insert({
        'product_id': widget.productId,
        'media_type': type,
        'storage_path': objectPath,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _deleteProductMedia(Map<String, dynamic> mediaRow) async {
    final id = (mediaRow['id'] ?? '').toString();
    final path = (mediaRow['storage_path'] ?? '').toString();
    if (id.isEmpty) return;

    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Supprimer ce média ?'),
        content: const Text('Il sera supprimé du produit.'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
          FilledButton(onPressed: () => Navigator.pop(context, true), child: const Text('Supprimer')),
        ],
      ),
    );
    if (ok != true) return;

    try {
      await _ensureAuthenticated();
      await _sb.from('product_media').delete().eq('id', id);

      if (path.isNotEmpty) {
        try {
          await _sb.storage.from(_productMediaBucket).remove([path]);
        } catch (_) {}
      }

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  // -------------------
  // Categories manage
  // -------------------

  Future<void> _editCategories() async {
    final temp = Set<String>.from(_selectedCategoryIds);

    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (ctx, setLocalState) => AlertDialog(
          title: const Text('Catégories'),
          content: SizedBox(
            width: 420,
            height: 420,
            child: ListView(
              children: _categories.map((c) {
                final id = c['id'].toString();
                final name = c['name'].toString();
                final checked = temp.contains(id);
                return CheckboxListTile(
                  value: checked,
                  title: Text(name),
                  onChanged: (v) {
                    setLocalState(() {
                      if (v == true) {
                        temp.add(id);
                      } else {
                        temp.remove(id);
                      }
                    });
                  },
                );
              }).toList(),
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text('Annuler')),
            ElevatedButton(onPressed: () => Navigator.pop(ctx, true), child: const Text('Enregistrer')),
          ],
        ),
      ),
    );

    if (ok != true) return;

    try {
      await _ensureAuthenticated();

      final toDelete = _selectedCategoryIds.difference(temp);
      for (final id in toDelete) {
        await _sb
            .from('product_categories_map')
            .delete()
            .eq('product_id', widget.productId)
            .eq('category_id', id);
      }

      final toAdd = temp.difference(_selectedCategoryIds);
      if (toAdd.isNotEmpty) {
        await _sb.from('product_categories_map').upsert(
          toAdd.map((id) => {'product_id': widget.productId, 'category_id': id}).toList(),
          onConflict: 'product_id,category_id',
        );
      }

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  // -------------------
  // Variants manage
  // -------------------

  Map<String, dynamic> _optionsMap(dynamic raw) {
    if (raw is Map) return Map<String, dynamic>.from(raw);
    return {};
  }

  Future<void> _addVariant() async {
    final created = await showModalBottomSheet<Map<String, dynamic>>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (_) => _VariantEditorSheet(
        currency: _currency(),
        initial: const {},
        title: 'Nouvelle variante',
      ),
    );

    if (created == null) return;

    try {
      await _ensureAuthenticated();
      await _sb.from('product_variants').insert({
        'product_id': widget.productId,
        'title': created['title'],
        'sku': (created['sku'] as String?)?.trim().isEmpty == true ? null : created['sku'],
        'price_amount': created['price_amount'],
        'currency': _currency(),
        'is_active': created['is_active'] ?? true,
        'options': created['options'] ?? {},
      });
      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _editVariant(Map<String, dynamic> v) async {
    final init = {
      'title': (v['title'] ?? '').toString(),
      'sku': v['sku']?.toString(),
      'price_amount': v['price_amount'],
      'is_active': v['is_active'] == true,
      'options': _optionsMap(v['options']),
    };

    final updated = await showModalBottomSheet<Map<String, dynamic>>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (_) => _VariantEditorSheet(
        currency: _currency(),
        initial: init,
        title: 'Modifier variante',
      ),
    );

    if (updated == null) return;

    try {
      await _ensureAuthenticated();
      await _sb.from('product_variants').update({
        'title': updated['title'],
        'sku': (updated['sku'] as String?)?.trim().isEmpty == true ? null : updated['sku'],
        'price_amount': updated['price_amount'],
        'is_active': updated['is_active'] ?? true,
        'options': updated['options'] ?? {},
      }).eq('id', v['id']);

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _adjustStock(String variantId) async {
    final deltaCtrl = TextEditingController();
    final reasonCtrl = TextEditingController();

    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Ajuster stock'),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: deltaCtrl,
                decoration: const InputDecoration(labelText: 'Delta (ex: 5 ou -2)'),
                keyboardType: TextInputType.number,
              ),
              TextField(controller: reasonCtrl, decoration: const InputDecoration(labelText: 'Raison (optionnel)')),
            ],
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
          ElevatedButton(onPressed: () => Navigator.pop(context, true), child: const Text('Enregistrer')),
        ],
      ),
    );

    if (ok != true) {
      deltaCtrl.dispose();
      reasonCtrl.dispose();
      return;
    }

    final delta = int.tryParse(deltaCtrl.text.trim());
    if (delta == null || delta == 0) {
      deltaCtrl.dispose();
      reasonCtrl.dispose();
      return;
    }

    try {
      await _ensureAuthenticated();
      final user = _sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');

      await _sb.from('inventory_movements').insert({
        'variant_id': variantId,
        'delta_qty': delta,
        'reason': reasonCtrl.text.trim().isEmpty ? null : reasonCtrl.text.trim(),
        'created_by': user.id,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    } finally {
      deltaCtrl.dispose();
      reasonCtrl.dispose();
    }
  }

  Future<void> _openVariantMedia(String variantId) async {
    if (!_variantMediaAvailable) {
      showDialog(
        context: context,
        builder: (_) => AlertDialog(
          title: const Text('Médias variante non activés'),
          content: const Text(
            'La table "variant_media" n’existe pas encore.\n'
            'Exécute le SQL fourni (variant_media) puis réessaye.',
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: const Text('OK')),
          ],
        ),
      );
      return;
    }

    await showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (_) => _VariantMediaSheet(
        businessId: widget.businessId,
        productId: widget.productId,
        variantId: variantId,
      ),
    );

    await _load();
  }

  // -------------------
  // UI
  // -------------------

  @override
  Widget build(BuildContext context) {
    final p = _product;

    if (_loading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }
    if (_error != null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Produit')),
        body: Center(child: Text(_error!, style: const TextStyle(color: Colors.red))),
      );
    }
    if (p == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Produit')),
        body: const Center(child: Text('Produit introuvable')),
      );
    }

    final title = p['title']?.toString() ?? 'Produit';
    final price = p['price_amount'];
    final cur = _currency();
    final completeness = (_isActive && _hasPrice && _hasMedia);

    return DefaultTabController(
      length: 4,
      child: Scaffold(
        body: SafeArea(
          child: RefreshIndicator(
            onRefresh: _load,
            child: NestedScrollView(
              headerSliverBuilder: (context, inner) => [
                SliverAppBar(
                  pinned: true,
                  floating: true,
                  title: Text(title, maxLines: 1, overflow: TextOverflow.ellipsis),
                  actions: [
                    IconButton(onPressed: _load, tooltip: 'Rafraîchir', icon: const Icon(Icons.refresh)),
                    IconButton(onPressed: _editProduct, tooltip: 'Modifier produit', icon: const Icon(Icons.edit)),
                    IconButton(onPressed: _addProductMedia, tooltip: 'Ajouter média', icon: const Icon(Icons.add_photo_alternate)),
                    IconButton(onPressed: _addVariant, tooltip: 'Ajouter variante', icon: const Icon(Icons.add)),
                    PopupMenuButton<String>(
                      onSelected: (v) {
                        if (v == 'categories') _editCategories();
                        if (v == 'public') context.push('/p/${widget.productId}');
                      },
                      itemBuilder: (_) => const [
                        PopupMenuItem(value: 'categories', child: Text('Catégories')),
                        PopupMenuItem(value: 'public', child: Text('Ouvrir page publique')),
                      ],
                    ),
                    const SizedBox(width: 6),
                  ],
                  bottom: const TabBar(
                    tabs: [
                      Tab(text: 'Overview'),
                      Tab(text: 'Médias'),
                      Tab(text: 'Variantes'),
                      Tab(text: 'Catégories'),
                    ],
                  ),
                ),
              ],
              body: TabBarView(
                children: [
                  // Overview
                  ListView(
                    padding: const EdgeInsets.all(16),
                    children: [
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(14),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Expanded(
                                    child: Text(
                                      title,
                                      style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w900),
                                    ),
                                  ),
                                  Column(
                                    children: [
                                      const Text('Actif', style: TextStyle(fontWeight: FontWeight.w700)),
                                      Switch(value: _isActive, onChanged: _toggleActive),
                                    ],
                                  ),
                                ],
                              ),
                              const SizedBox(height: 8),
                              Text(p['description']?.toString() ?? ''),
                              const SizedBox(height: 10),
                              Wrap(
                                spacing: 10,
                                runSpacing: 10,
                                children: [
                                  Chip(label: Text('Prix: ${price ?? '—'} $cur')),
                                  Chip(label: Text('Médias: ${_productMedia.length}')),
                                  Chip(label: Text('Variantes: ${_variants.length}')),
                                  Chip(label: Text(completeness ? 'Complet' : 'À compléter')),
                                ],
                              ),
                              const SizedBox(height: 10),
                              if (!completeness)
                                const Text(
                                  'Astuce: pour être visible sur Explorer, un produit doit être Actif + Prix défini + au moins 1 média.',
                                  style: TextStyle(color: Colors.black54),
                                ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                      Card(
                        child: ListTile(
                          leading: const Icon(Icons.public),
                          title: const Text('Page publique'),
                          subtitle: const Text('Voir le rendu client'),
                          onTap: () => context.push('/p/${widget.productId}'),
                        ),
                      ),
                    ],
                  ),

                  // Médias
                  ListView(
                    padding: const EdgeInsets.all(16),
                    children: [
                      Row(
                        children: [
                          const Expanded(
                            child: Text('Médias produit', style: TextStyle(fontWeight: FontWeight.w900)),
                          ),
                          FilledButton.icon(
                            onPressed: _addProductMedia,
                            icon: const Icon(Icons.add),
                            label: const Text('Ajouter'),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_productMedia.isEmpty)
                        const Card(
                          child: Padding(
                            padding: EdgeInsets.all(14),
                            child: Text('Aucun média. Ajoute au moins une photo/vidéo.'),
                          ),
                        )
                      else
                        ..._productMedia.map((m) {
                          final type = (m['media_type'] ?? '').toString().toLowerCase();
                          final path = (m['storage_path'] ?? '').toString();
                          final url = _publicUrl(path);

                          return Card(
                            child: ListTile(
                              leading: Container(
                                width: 56,
                                height: 56,
                                decoration: BoxDecoration(
                                  borderRadius: BorderRadius.circular(12),
                                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                                ),
                                clipBehavior: Clip.antiAlias,
                                child: type == 'image' && url != null
                                    ? Image.network(url, fit: BoxFit.cover, errorBuilder: (_, __, ___) => const Icon(Icons.broken_image))
                                    : Icon(type == 'video' ? Icons.play_circle_outline : Icons.image),
                              ),
                              title: Text(type == 'video' ? 'Vidéo' : 'Image'),
                              subtitle: Text(path, maxLines: 1, overflow: TextOverflow.ellipsis),
                              trailing: IconButton(
                                tooltip: 'Supprimer',
                                onPressed: () => _deleteProductMedia(m),
                                icon: const Icon(Icons.delete_outline),
                              ),
                            ),
                          );
                        }),
                    ],
                  ),

                  // Variantes
                  ListView(
                    padding: const EdgeInsets.all(16),
                    children: [
                      Row(
                        children: [
                          const Expanded(
                            child: Text('Variantes & Stock', style: TextStyle(fontWeight: FontWeight.w900)),
                          ),
                          FilledButton.icon(
                            onPressed: _addVariant,
                            icon: const Icon(Icons.add),
                            label: const Text('Ajouter'),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_variants.isEmpty)
                        const Card(
                          child: Padding(
                            padding: EdgeInsets.all(14),
                            child: Text('Aucune variante. Clique “Ajouter”.'),
                          ),
                        )
                      else
                        ..._variants.map((v) {
                          final vid = v['id'].toString();
                          final onHand = _onHandByVariant[vid] ?? 0;

                          final opt = _optionsMap(v['options']);
                          final optText = opt.entries.map((e) => '${e.key}: ${e.value}').join(' • ');
                          final varPrice = v['price_amount'];
                          final active = v['is_active'] == true;

                          final mediaCount = _variantMediaCounts[vid] ?? 0;

                          return Card(
                            child: Padding(
                              padding: const EdgeInsets.all(12),
                              child: Column(
                                children: [
                                  Row(
                                    children: [
                                      Expanded(
                                        child: Text(
                                          v['title']?.toString() ?? '',
                                          style: const TextStyle(fontWeight: FontWeight.w900),
                                        ),
                                      ),
                                      Chip(label: Text(active ? 'Actif' : 'Inactif')),
                                    ],
                                  ),
                                  const SizedBox(height: 6),
                                  Text(
                                    'SKU: ${v['sku'] ?? '—'} • Stock: $onHand • Prix: ${varPrice ?? '—'} ${_currency()}',
                                  ),
                                  if (optText.isNotEmpty) ...[
                                    const SizedBox(height: 6),
                                    Text(optText, style: const TextStyle(color: Colors.black54)),
                                  ],
                                  const SizedBox(height: 10),
                                  Wrap(
                                    spacing: 10,
                                    runSpacing: 10,
                                    children: [
                                      OutlinedButton.icon(
                                        onPressed: () => _editVariant(v),
                                        icon: const Icon(Icons.edit),
                                        label: const Text('Modifier'),
                                      ),
                                      OutlinedButton.icon(
                                        onPressed: () => _adjustStock(vid),
                                        icon: const Icon(Icons.inventory),
                                        label: const Text('Stock'),
                                      ),
                                      OutlinedButton.icon(
                                        onPressed: () => _openVariantMedia(vid),
                                        icon: const Icon(Icons.perm_media),
                                        label: Text(_variantMediaAvailable ? 'Médias ($mediaCount)' : 'Médias (off)'),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          );
                        }),
                    ],
                  ),

                  // Catégories
                  ListView(
                    padding: const EdgeInsets.all(16),
                    children: [
                      Row(
                        children: [
                          const Expanded(
                            child: Text('Catégories', style: TextStyle(fontWeight: FontWeight.w900)),
                          ),
                          FilledButton.icon(
                            onPressed: _editCategories,
                            icon: const Icon(Icons.edit),
                            label: const Text('Modifier'),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_selectedCategoryIds.isEmpty)
                        const Card(
                          child: Padding(
                            padding: EdgeInsets.all(14),
                            child: Text('Aucune catégorie associée.'),
                          ),
                        )
                      else
                        Wrap(
                          spacing: 10,
                          runSpacing: 10,
                          children: _categories
                              .where((c) => _selectedCategoryIds.contains(c['id'].toString()))
                              .map((c) => Chip(label: Text(c['name'].toString())))
                              .toList(),
                        ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// -------------------------
// Variant editor (bottomsheet)
// -------------------------

class _VariantEditorSheet extends StatefulWidget {
  final String currency;
  final Map<String, dynamic> initial;
  final String title;

  const _VariantEditorSheet({
    required this.currency,
    required this.initial,
    required this.title,
  });

  @override
  State<_VariantEditorSheet> createState() => _VariantEditorSheetState();
}

class _VariantEditorSheetState extends State<_VariantEditorSheet> {
  final _titleCtrl = TextEditingController();
  final _skuCtrl = TextEditingController();
  final _priceCtrl = TextEditingController();

  bool _active = true;
  final Map<String, dynamic> _options = {};

  @override
  void initState() {
    super.initState();
    _titleCtrl.text = (widget.initial['title'] ?? '').toString();
    _skuCtrl.text = (widget.initial['sku'] ?? '').toString();
    _active = widget.initial['is_active'] == true;

    final p = widget.initial['price_amount'];
    _priceCtrl.text = (p == null) ? '' : p.toString();

    final opt = widget.initial['options'];
    if (opt is Map) {
      _options.addAll(Map<String, dynamic>.from(opt));
    }
  }

  @override
  void dispose() {
    _titleCtrl.dispose();
    _skuCtrl.dispose();
    _priceCtrl.dispose();
    super.dispose();
  }

  Future<void> _addOption() async {
    final kCtrl = TextEditingController();
    final vCtrl = TextEditingController();

    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Ajouter option'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(controller: kCtrl, decoration: const InputDecoration(labelText: 'Clé (ex: Couleur)')),
            TextField(controller: vCtrl, decoration: const InputDecoration(labelText: 'Valeur (ex: Rouge)')),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
          FilledButton(onPressed: () => Navigator.pop(context, true), child: const Text('Ajouter')),
        ],
      ),
    );

    if (ok == true) {
      final k = kCtrl.text.trim();
      final v = vCtrl.text.trim();
      if (k.isNotEmpty && v.isNotEmpty) {
        setState(() => _options[k] = v);
      }
    }

    kCtrl.dispose();
    vCtrl.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    return SafeArea(
      child: Padding(
        padding: EdgeInsets.fromLTRB(16, 12, 16, 16 + bottomInset),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Align(
                alignment: Alignment.centerLeft,
                child: Text(widget.title, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w900)),
              ),
              const SizedBox(height: 10),
              TextField(controller: _titleCtrl, decoration: const InputDecoration(labelText: 'Titre *')),
              const SizedBox(height: 10),
              TextField(controller: _skuCtrl, decoration: const InputDecoration(labelText: 'SKU (optionnel)')),
              const SizedBox(height: 10),
              TextField(
                controller: _priceCtrl,
                decoration: InputDecoration(labelText: 'Prix (optionnel) • ${widget.currency}'),
                keyboardType: TextInputType.number,
              ),
              const SizedBox(height: 10),
              SwitchListTile(
                value: _active,
                onChanged: (v) => setState(() => _active = v),
                title: const Text('Actif'),
              ),
              const SizedBox(height: 10),

              Row(
                children: [
                  const Expanded(
                    child: Text('Options', style: TextStyle(fontWeight: FontWeight.w900)),
                  ),
                  OutlinedButton.icon(
                    onPressed: _addOption,
                    icon: const Icon(Icons.add),
                    label: const Text('Ajouter'),
                  ),
                ],
              ),
              const SizedBox(height: 10),
              if (_options.isEmpty)
                const Align(
                  alignment: Alignment.centerLeft,
                  child: Text('Aucune option (ex: Couleur, Taille).'),
                )
              else
                Wrap(
                  spacing: 10,
                  runSpacing: 10,
                  children: _options.entries.map((e) {
                    return Chip(
                      label: Text('${e.key}: ${e.value}'),
                      onDeleted: () => setState(() => _options.remove(e.key)),
                    );
                  }).toList(),
                ),

              const SizedBox(height: 14),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Annuler'),
                    ),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: FilledButton(
                      onPressed: () {
                        final title = _titleCtrl.text.trim();
                        if (title.isEmpty) return;

                        final priceTxt = _priceCtrl.text.trim().replaceAll(',', '.');
                        final price = priceTxt.isEmpty ? null : num.tryParse(priceTxt);

                        Navigator.pop(context, {
                          'title': title,
                          'sku': _skuCtrl.text.trim(),
                          'price_amount': price,
                          'is_active': _active,
                          'options': _options,
                        });
                      },
                      child: const Text('Valider'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// -------------------------
// Variant media sheet (optional)
// Requires table variant_media
// -------------------------

class _VariantMediaSheet extends StatefulWidget {
  final String businessId;
  final String productId;
  final String variantId;

  const _VariantMediaSheet({
    required this.businessId,
    required this.productId,
    required this.variantId,
  });

  @override
  State<_VariantMediaSheet> createState() => _VariantMediaSheetState();
}

class _VariantMediaSheetState extends State<_VariantMediaSheet> {
  static const _bucket = 'product_media';

  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;
  List<Map<String, dynamic>> _items = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _ensureAuthenticated() async {
    await _sb.auth.refreshSession();
    if (_sb.auth.currentSession == null || _sb.auth.currentUser == null) {
      throw Exception('Session manquante.');
    }
  }

  String? _publicUrl(String? path) {
    if (path == null || path.isEmpty) return null;
    return _sb.storage.from(_bucket).getPublicUrl(path);
  }

  String _extFromName(String name) {
    final idx = name.lastIndexOf('.');
    if (idx <= 0 || idx == name.length - 1) return '';
    return name.substring(idx + 1).toLowerCase();
  }

  bool _isVideoExt(String ext) {
    const vids = {'mp4', 'mov', 'm4v', 'avi', 'webm', 'mkv'};
    return vids.contains(ext.toLowerCase());
  }

  bool _isImageExt(String ext) {
    const imgs = {'jpg', 'jpeg', 'png', 'webp', 'gif'};
    return imgs.contains(ext.toLowerCase());
  }

  String _contentTypeFromExt(String ext) {
    final e = ext.toLowerCase();
    if (e == 'jpg' || e == 'jpeg') return 'image/jpeg';
    if (e == 'png') return 'image/png';
    if (e == 'webp') return 'image/webp';
    if (e == 'gif') return 'image/gif';
    if (e == 'mp4') return 'video/mp4';
    if (e == 'mov') return 'video/quicktime';
    if (e == 'webm') return 'video/webm';
    if (e == 'm4v') return 'video/x-m4v';
    if (e == 'avi') return 'video/x-msvideo';
    if (e == 'mkv') return 'video/x-matroska';
    return 'application/octet-stream';
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
      _items = [];
    });

    try {
      await _ensureAuthenticated();
      final rows = await _sb
          .from('variant_media')
          .select('id,media_type,storage_path,created_at')
          .eq('variant_id', widget.variantId)
          .order('created_at', ascending: false);

      _items = (rows as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _add() async {
    try {
      await _ensureAuthenticated();

      final res = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: const [
          'jpg', 'jpeg', 'png', 'webp', 'gif',
          'mp4', 'mov', 'm4v', 'avi', 'webm', 'mkv',
        ],
        withData: true,
      );
      if (res == null || res.files.isEmpty) return;

      final f = res.files.first;
      final bytes = f.bytes;
      if (bytes == null || bytes.isEmpty) throw Exception('Impossible de lire le fichier.');

      final name = f.name;
      var ext = (f.extension ?? '').toLowerCase();
      if (ext.isEmpty) ext = _extFromName(name);
      if (ext.startsWith('.')) ext = ext.substring(1);

      if (ext.isEmpty) throw Exception('Extension inconnue.');
      final isVideo = _isVideoExt(ext);
      final isImage = _isImageExt(ext);
      if (!isVideo && !isImage) throw Exception('Type non supporté: .$ext');

      final type = isVideo ? 'video' : 'image';

      final objectPath =
          '${widget.businessId}/products/${widget.productId}/variants/${widget.variantId}/media_${DateTime.now().millisecondsSinceEpoch}.$ext';

      await _sb.storage.from(_bucket).uploadBinary(
            objectPath,
            bytes,
            fileOptions: FileOptions(
              upsert: true,
              contentType: _contentTypeFromExt(ext),
            ),
          );

      await _sb.from('variant_media').insert({
        'variant_id': widget.variantId,
        'media_type': type,
        'storage_path': objectPath,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _remove(Map<String, dynamic> row) async {
    final id = (row['id'] ?? '').toString();
    final path = (row['storage_path'] ?? '').toString();
    if (id.isEmpty) return;

    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Supprimer ce média ?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
          FilledButton(onPressed: () => Navigator.pop(context, true), child: const Text('Supprimer')),
        ],
      ),
    );
    if (ok != true) return;

    try {
      await _ensureAuthenticated();
      await _sb.from('variant_media').delete().eq('id', id);

      if (path.isNotEmpty) {
        try {
          await _sb.storage.from(_bucket).remove([path]);
        } catch (_) {}
      }
      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    return SafeArea(
      child: Padding(
        padding: EdgeInsets.fromLTRB(16, 8, 16, 16 + bottomInset),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              children: [
                const Expanded(
                  child: Text('Médias variante', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w900)),
                ),
                IconButton(onPressed: _add, tooltip: 'Ajouter', icon: const Icon(Icons.add)),
                IconButton(onPressed: _load, tooltip: 'Rafraîchir', icon: const Icon(Icons.refresh)),
              ],
            ),
            const SizedBox(height: 10),
            if (_loading)
              const Padding(
                padding: EdgeInsets.all(20),
                child: CircularProgressIndicator(),
              )
            else if (_error != null)
              Text(_error!, style: const TextStyle(color: Colors.red))
            else if (_items.isEmpty)
              const Padding(
                padding: EdgeInsets.all(12),
                child: Text('Aucun média pour cette variante.'),
              )
            else
              Flexible(
                child: ListView(
                  children: _items.map((m) {
                    final type = (m['media_type'] ?? '').toString().toLowerCase();
                    final path = (m['storage_path'] ?? '').toString();
                    final url = _publicUrl(path);

                    return Card(
                      child: ListTile(
                        leading: Container(
                          width: 56,
                          height: 56,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(12),
                            color: Theme.of(context).colorScheme.surfaceContainerHighest,
                          ),
                          clipBehavior: Clip.antiAlias,
                          child: type == 'image' && url != null
                              ? Image.network(url, fit: BoxFit.cover, errorBuilder: (_, __, ___) => const Icon(Icons.broken_image))
                              : Icon(type == 'video' ? Icons.play_circle_outline : Icons.image),
                        ),
                        title: Text(type == 'video' ? 'Vidéo' : 'Image'),
                        subtitle: Text(path, maxLines: 1, overflow: TextOverflow.ellipsis),
                        trailing: IconButton(
                          tooltip: 'Supprimer',
                          onPressed: () => _remove(m),
                          icon: const Icon(Icons.delete_outline),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\public\landing_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class LandingPage extends StatefulWidget {
  const LandingPage({super.key});

  @override
  State<LandingPage> createState() => _LandingPageState();
}

class _LandingPageState extends State<LandingPage> {
  final _search = TextEditingController();
  bool _loading = true;
  String? _error;

  List<Map<String, dynamic>> _items = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    _search.dispose();
    super.dispose();
  }

  bool get _loggedIn => Supabase.instance.client.auth.currentSession != null;

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;
      final q = _search.text.trim();

      var req = sb
          .from('businesses')
          .select('id,name,slug,description,is_active,is_verified')
          .eq('is_active', true)
          .order('created_at', ascending: false)
          .limit(30);

      if (q.isNotEmpty) {
        req = sb
            .from('businesses')
            .select('id,name,slug,description,is_active,is_verified')
            .eq('is_active', true)
            .or('name.ilike.%$q%,slug.ilike.%$q%')
            .order('created_at', ascending: false)
            .limit(30);
      }

      final rows = await req;
      _items = (rows as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
    } catch (e) {
      _error = e.toString();
    } finally {
      // ignore: control_flow_in_finally
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Explorer'),
        actions: [
          if (_loggedIn)
            TextButton(
              onPressed: () => context.push('/home'),
              child: const Text('Dashboard'),
            )
          else
            TextButton(
              onPressed: () => context.push('/login'),
              child: const Text('Se connecter'),
            ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(
              controller: _search,
              decoration: InputDecoration(
                labelText: 'Rechercher une boutique (nom ou slug)',
                suffixIcon: IconButton(
                  onPressed: _load,
                  icon: const Icon(Icons.search),
                ),
              ),
              onSubmitted: (_) => _load(),
            ),
            const SizedBox(height: 12),
            if (_loading) const Expanded(child: Center(child: CircularProgressIndicator()))
            else if (_error != null)
              Expanded(child: Center(child: Text(_error!, style: const TextStyle(color: Colors.red))))
            else if (_items.isEmpty)
              const Expanded(child: Center(child: Text('Aucune boutique trouvée.')))
            else
              Expanded(
                child: ListView.separated(
                  itemCount: _items.length,
                  separatorBuilder: (_, __) => const SizedBox(height: 8),
                  itemBuilder: (_, i) {
                    final b = _items[i];
                    final name = (b['name'] ?? '').toString();
                    final slug = (b['slug'] ?? '').toString();
                    final verified = b['is_verified'] == true;

                    return Card(
                      child: ListTile(
                        title: Row(
                          children: [
                            Expanded(child: Text(name, maxLines: 1, overflow: TextOverflow.ellipsis)),
                            if (verified) const SizedBox(width: 8),
                            if (verified)
                              const Icon(Icons.verified, size: 18),
                          ],
                        ),
                        subtitle: Text('@$slug', maxLines: 1, overflow: TextOverflow.ellipsis),
                        trailing: const Icon(Icons.arrow_forward),
                        onTap: () => context.push('/b/$slug'),
                      ),
                    );
                  },
                ),
              ),
          ],
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\requests\business_requests_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessRequestsPage extends StatefulWidget {
  final String businessId;
  const BusinessRequestsPage({super.key, required this.businessId});

  @override
  State<BusinessRequestsPage> createState() => _BusinessRequestsPageState();
}

class _BusinessRequestsPageState extends State<BusinessRequestsPage> {
  bool _loading = true;
  String? _error;
  List<Map<String, dynamic>> _requests = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;
      final rows = await sb
          .from('service_requests')
          .select('id,status,type,created_at,address_text,total_estimate,currency,customer_user_id')
          .eq('business_id', widget.businessId)
          .order('created_at', ascending: false);

      _requests = (rows as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
    } catch (e) {
      _error = e.toString();
    } finally {
      // ignore: control_flow_in_finally
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Demandes (B3)'),
        actions: [
          IconButton(onPressed: _loading ? null : _load, icon: const Icon(Icons.refresh)),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
              ? Center(child: Text(_error!, style: const TextStyle(color: Colors.red)))
              : ListView(
                  padding: const EdgeInsets.all(16),
                  children: _requests.map((r) {
                    final est = r['total_estimate'];
                    final cur = r['currency']?.toString() ?? 'XOF';
                    return Card(
                      child: ListTile(
                        title: Text('Statut: ${r['status']} • Type: ${r['type']}'),
                        subtitle: Text(r['address_text']?.toString() ?? ''),
                        trailing: Text(est == null ? '' : '$est $cur'),
                        onTap: () => context.push('/business/${widget.businessId}/requests/${r['id']}'),
                      ),
                    );
                  }).toList(),
                ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\requests\request_detail_page.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class RequestDetailPage extends StatefulWidget {
  final String businessId;
  final String requestId;

  const RequestDetailPage({
    super.key,
    required this.businessId,
    required this.requestId,
  });

  @override
  State<RequestDetailPage> createState() => _RequestDetailPageState();
}

class _RequestDetailPageState extends State<RequestDetailPage> {
  bool _loading = true;
  String? _error;

  Map<String, dynamic>? _request;
  List<Map<String, dynamic>> _messages = [];
  List<Map<String, dynamic>> _history = [];
  List<Map<String, dynamic>> _assignments = [];
  List<Map<String, dynamic>> _quotes = [];
  List<Map<String, dynamic>> _invoices = [];
  List<Map<String, dynamic>> _paymentIntents = [];

  final _msgCtrl = TextEditingController();

  static const _statuses = <String>[
    'new',
    'accepted',
    'rejected',
    'in_progress',
    'delivered',
    'closed',
    'cancelled',
  ];

  static const _providers = <String>[
    'google_play',
    'cinetpay',
    'fedapay',
    'manual',
  ];

  @override
  void initState() {
    super.initState();
    _load();
  }

  @override
  void dispose() {
    _msgCtrl.dispose();
    super.dispose();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final sb = Supabase.instance.client;

      final r = await sb
          .from('service_requests')
          .select('id,business_id,customer_user_id,status,type,address_text,notes,total_estimate,currency,created_at,updated_at')
          .eq('id', widget.requestId)
          .single();

      _request = Map<String, dynamic>.from(r as Map);

      final msgs = await sb
          .from('service_request_messages')
          .select('id,sender_user_id,message,created_at')
          .eq('request_id', widget.requestId)
          .order('created_at', ascending: true);

      _messages = (msgs as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final hist = await sb
          .from('service_request_status_history')
          .select('id,from_status,to_status,actor_user_id,note,created_at')
          .eq('request_id', widget.requestId)
          .order('created_at', ascending: false);

      _history = (hist as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final asg = await sb
          .from('service_request_assignments')
          .select('id,staff_user_id,assigned_by_user_id,role,assigned_at,unassigned_at')
          .eq('request_id', widget.requestId)
          .order('assigned_at', ascending: false);

      _assignments = (asg as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final q = await sb
          .from('quotes')
          .select('id,status,total,currency,created_at,updated_at')
          .eq('request_id', widget.requestId)
          .order('created_at', ascending: false);

      _quotes = (q as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final inv = await sb
          .from('invoices')
          .select('id,status,total,currency,issued_at,paid_at,created_at,updated_at')
          .eq('request_id', widget.requestId)
          .order('created_at', ascending: false);

      _invoices = (inv as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

      final pi = await sb
          .from('payment_intents')
          .select('id,status,provider,amount,currency,external_ref,created_at,updated_at,invoice_id,request_id')
          .eq('request_id', widget.requestId)
          .order('created_at', ascending: false);

      _paymentIntents = (pi as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
    } catch (e) {
      _error = e.toString();
    } finally {
      // ignore: control_flow_in_finally
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _sendMessage() async {
    final text = _msgCtrl.text.trim();
    if (text.isEmpty) return;

    try {
      final sb = Supabase.instance.client;
      final user = sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');

      await sb.from('service_request_messages').insert({
        'request_id': widget.requestId,
        'sender_user_id': user.id,
        'message': text,
      });

      _msgCtrl.clear();
      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _changeStatus(String next) async {
    final current = _request?['status']?.toString();
    if (current == null || current == next) return;

    try {
      final sb = Supabase.instance.client;
      final user = sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');

      await sb.from('service_requests').update({'status': next}).eq('id', widget.requestId);

      await sb.from('service_request_status_history').insert({
        'request_id': widget.requestId,
        'from_status': current,
        'to_status': next,
        'actor_user_id': user.id,
        'note': null,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _assignStaff() async {
    try {
      final sb = Supabase.instance.client;
      final user = sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');

      final members = await sb
          .from('business_members')
          .select('user_id,role,created_at')
          .eq('business_id', widget.businessId)
          .order('created_at');

      final list = (members as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();
      if (list.isEmpty) return;

      String selected = list.first['user_id'].toString();

      final ok = await showDialog<bool>(
        // ignore: use_build_context_synchronously
        context: context,
        builder: (_) => AlertDialog(
          title: const Text('Affecter un staff'),
          content: DropdownButton<String>(
            isExpanded: true,
            value: selected,
            items: list.map((m) {
              final uid = m['user_id'].toString();
              final role = m['role']?.toString() ?? 'staff';
              return DropdownMenuItem(
                value: uid,
                child: Text('$uid • $role', overflow: TextOverflow.ellipsis),
              );
            }).toList(),
            onChanged: (v) {
              if (v == null) return;
              selected = v;
              (context as Element).markNeedsBuild();
            },
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
            ElevatedButton(onPressed: () => Navigator.pop(context, true), child: const Text('Affecter')),
          ],
        ),
      );

      if (ok != true) return;

      await sb.from('service_request_assignments').insert({
        'request_id': widget.requestId,
        'staff_user_id': selected,
        'assigned_by_user_id': user.id,
        'role': 'primary',
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _unassign(String assignmentId) async {
    try {
      final sb = Supabase.instance.client;
      await sb.from('service_request_assignments').update({
        'unassigned_at': DateTime.now().toIso8601String(),
      }).eq('id', assignmentId);

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _createQuote() async {
    try {
      final sb = Supabase.instance.client;
      final user = sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');
      final r = _request;
      if (r == null) return;

      await sb.from('quotes').insert({
        'request_id': widget.requestId,
        'business_id': widget.businessId,
        'customer_user_id': r['customer_user_id'],
        'status': 'draft',
        'currency': r['currency'] ?? 'XOF',
        'subtotal': 0,
        'tax': 0,
        'total': 0,
        'created_by': user.id,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _createInvoice() async {
    try {
      final sb = Supabase.instance.client;
      final user = sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');
      final r = _request;
      if (r == null) return;

      await sb.from('invoices').insert({
        'request_id': widget.requestId,
        'business_id': widget.businessId,
        'customer_user_id': r['customer_user_id'],
        'status': 'draft',
        'currency': r['currency'] ?? 'XOF',
        'subtotal': 0,
        'tax': 0,
        'total': 0,
        'created_by': user.id,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  Future<void> _createPaymentIntent() async {
    if (_invoices.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Crée une facture d’abord.')));
      return;
    }

    try {
      final sb = Supabase.instance.client;
      final user = sb.auth.currentUser;
      if (user == null) throw Exception('Session manquante.');

      final invoice = _invoices.first;
      final invoiceId = invoice['id'].toString();
      final amount = (invoice['total'] as num?)?.toDouble() ?? 0.0;
      final currency = invoice['currency']?.toString() ?? 'XOF';

      String provider = _providers.first;

      final ok = await showDialog<bool>(
        context: context,
        builder: (_) => AlertDialog(
          title: const Text('Créer un payment_intent'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DropdownButton<String>(
                isExpanded: true,
                value: provider,
                items: _providers
                    .map((p) => DropdownMenuItem(value: p, child: Text(p)))
                    .toList(),
                onChanged: (v) {
                  if (v == null) return;
                  provider = v;
                  (context as Element).markNeedsBuild();
                },
              ),
              const SizedBox(height: 8),
              Text('Facture: $invoiceId'),
              Text('Montant: $amount $currency'),
            ],
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Annuler')),
            ElevatedButton(onPressed: () => Navigator.pop(context, true), child: const Text('Créer')),
          ],
        ),
      );

      if (ok != true) return;

      await sb.from('payment_intents').insert({
        'business_id': widget.businessId,
        'request_id': widget.requestId,
        'invoice_id': invoiceId,
        'provider': provider,
        'amount': amount,
        'currency': currency,
        'status': 'pending',
        'created_by': user.id,
      });

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erreur: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    final r = _request;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Détail demande'),
        actions: [
          IconButton(onPressed: _loading ? null : _load, icon: const Icon(Icons.refresh)),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : _error != null
              ? Center(child: Text(_error!, style: const TextStyle(color: Colors.red)))
              : r == null
                  ? const Center(child: Text('Demande introuvable'))
                  : DefaultTabController(
                      length: 5,
                      child: Column(
                        children: [
                          Card(
                            margin: const EdgeInsets.all(12),
                            child: Padding(
                              padding: const EdgeInsets.all(12),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text('Statut: ${r['status']} • Type: ${r['type']}',
                                      style: const TextStyle(fontWeight: FontWeight.w700)),
                                  const SizedBox(height: 6),
                                  Text(r['address_text']?.toString() ?? ''),
                                  const SizedBox(height: 6),
                                  Text('Notes: ${r['notes'] ?? ''}'),
                                ],
                              ),
                            ),
                          ),
                          const TabBar(
                            tabs: [
                              Tab(text: 'Chat'),
                              Tab(text: 'Statut'),
                              Tab(text: 'Staff'),
                              Tab(text: 'Devis/Factures'),
                              Tab(text: 'Paiement'),
                            ],
                          ),
                          Expanded(
                            child: TabBarView(
                              children: [
                                // Chat
                                Column(
                                  children: [
                                    Expanded(
                                      child: ListView(
                                        padding: const EdgeInsets.all(12),
                                        children: _messages.map((m) {
                                          return Card(
                                            child: ListTile(
                                              title: Text(m['message']?.toString() ?? ''),
                                              subtitle: Text('from: ${m['sender_user_id']}'),
                                            ),
                                          );
                                        }).toList(),
                                      ),
                                    ),
                                    Padding(
                                      padding: const EdgeInsets.all(12),
                                      child: Row(
                                        children: [
                                          Expanded(
                                            child: TextField(
                                              controller: _msgCtrl,
                                              decoration: const InputDecoration(
                                                labelText: 'Message',
                                              ),
                                            ),
                                          ),
                                          const SizedBox(width: 8),
                                          ElevatedButton(
                                            onPressed: _sendMessage,
                                            child: const Text('Envoyer'),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ],
                                ),

                                // Statut
                                ListView(
                                  padding: const EdgeInsets.all(12),
                                  children: [
                                    DropdownButtonFormField<String>(
                                      initialValue: r['status']?.toString(),
                                      items: _statuses
                                          .map((s) => DropdownMenuItem(value: s, child: Text(s)))
                                          .toList(),
                                      onChanged: (v) {
                                        if (v == null) return;
                                        _changeStatus(v);
                                      },
                                      decoration: const InputDecoration(labelText: 'Changer statut'),
                                    ),
                                    const SizedBox(height: 12),
                                    const Text('Historique', style: TextStyle(fontWeight: FontWeight.w700)),
                                    const SizedBox(height: 8),
                                    ..._history.map((h) => Card(
                                          child: ListTile(
                                            title: Text('${h['from_status'] ?? '-'} -> ${h['to_status']}'),
                                            subtitle: Text('by ${h['actor_user_id']}'),
                                          ),
                                        )),
                                  ],
                                ),

                                // Staff
                                ListView(
                                  padding: const EdgeInsets.all(12),
                                  children: [
                                    ElevatedButton.icon(
                                      onPressed: _assignStaff,
                                      icon: const Icon(Icons.person_add),
                                      label: const Text('Affecter un staff'),
                                    ),
                                    const SizedBox(height: 12),
                                    const Text('Affectations', style: TextStyle(fontWeight: FontWeight.w700)),
                                    const SizedBox(height: 8),
                                    if (_assignments.isEmpty)
                                      const Text('Aucune affectation.')
                                    else
                                      ..._assignments.map((a) {
                                        final unassigned = a['unassigned_at'] != null;
                                        return Card(
                                          child: ListTile(
                                            title: Text('staff: ${a['staff_user_id']} • role: ${a['role']}'),
                                            subtitle: Text(unassigned ? 'Unassigned' : 'Active'),
                                            trailing: unassigned
                                                ? null
                                                : IconButton(
                                                    tooltip: 'Unassign',
                                                    onPressed: () => _unassign(a['id'].toString()),
                                                    icon: const Icon(Icons.remove_circle),
                                                  ),
                                          ),
                                        );
                                      }),
                                  ],
                                ),

                                // Quotes / Invoices
                                ListView(
                                  padding: const EdgeInsets.all(12),
                                  children: [
                                    Row(
                                      children: [
                                        Expanded(
                                          child: ElevatedButton(
                                            onPressed: _createQuote,
                                            child: const Text('Créer devis'),
                                          ),
                                        ),
                                        const SizedBox(width: 8),
                                        Expanded(
                                          child: ElevatedButton(
                                            onPressed: _createInvoice,
                                            child: const Text('Créer facture'),
                                          ),
                                        ),
                                      ],
                                    ),
                                    const SizedBox(height: 12),
                                    const Text('Devis', style: TextStyle(fontWeight: FontWeight.w700)),
                                    const SizedBox(height: 8),
                                    if (_quotes.isEmpty)
                                      const Text('Aucun devis.')
                                    else
                                      ..._quotes.map((q) => Card(
                                            child: ListTile(
                                              title: Text('status=${q['status']} • total=${q['total']} ${q['currency']}'),
                                              subtitle: Text('id=${q['id']}'),
                                            ),
                                          )),
                                    const SizedBox(height: 12),
                                    const Text('Factures', style: TextStyle(fontWeight: FontWeight.w700)),
                                    const SizedBox(height: 8),
                                    if (_invoices.isEmpty)
                                      const Text('Aucune facture.')
                                    else
                                      ..._invoices.map((i) => Card(
                                            child: ListTile(
                                              title: Text('status=${i['status']} • total=${i['total']} ${i['currency']}'),
                                              subtitle: Text('id=${i['id']}'),
                                            ),
                                          )),
                                  ],
                                ),

                                // Paiement
                                ListView(
                                  padding: const EdgeInsets.all(12),
                                  children: [
                                    ElevatedButton(
                                      onPressed: _createPaymentIntent,
                                      child: const Text('Créer payment_intent (sur dernière facture)'),
                                    ),
                                    const SizedBox(height: 12),
                                    const Text('Payment intents', style: TextStyle(fontWeight: FontWeight.w700)),
                                    const SizedBox(height: 8),
                                    if (_paymentIntents.isEmpty)
                                      const Text('Aucun payment_intent.')
                                    else
                                      ..._paymentIntents.map((p) => Card(
                                            child: ListTile(
                                              title: Text('status=${p['status']} • provider=${p['provider']}'),
                                              subtitle: Text('amount=${p['amount']} ${p['currency']} • id=${p['id']}'),
                                            ),
                                          )),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\firebase_options.dart

// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyC6MQ_LsqoSKl7iBchO6kMwonhJHbRXvvs',
    appId: '1:433429123250:web:a9925dcbb53db9747fb9ab',
    messagingSenderId: '433429123250',
    projectId: 'com-example-flutter-appli-1',
    authDomain: 'com-example-flutter-appli-1.firebaseapp.com',
    storageBucket: 'com-example-flutter-appli-1.firebasestorage.app',
    measurementId: 'G-X7QSSFZT6P',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAmHzMiyb3oYAbuNu_wKmXFlI--Eql3xW8',
    appId: '1:433429123250:android:5bdacb7713dbdbf47fb9ab',
    messagingSenderId: '433429123250',
    projectId: 'com-example-flutter-appli-1',
    storageBucket: 'com-example-flutter-appli-1.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyBn3pDvXdc0s0myGPKFW7IXHt1bBDtGaEA',
    appId: '1:433429123250:ios:555dd8654b9f7c9f7fb9ab',
    messagingSenderId: '433429123250',
    projectId: 'com-example-flutter-appli-1',
    storageBucket: 'com-example-flutter-appli-1.firebasestorage.app',
    iosBundleId: 'com.example.flutterApplication1',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyBn3pDvXdc0s0myGPKFW7IXHt1bBDtGaEA',
    appId: '1:433429123250:ios:555dd8654b9f7c9f7fb9ab',
    messagingSenderId: '433429123250',
    projectId: 'com-example-flutter-appli-1',
    storageBucket: 'com-example-flutter-appli-1.firebasestorage.app',
    iosBundleId: 'com.example.flutterApplication1',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyC6MQ_LsqoSKl7iBchO6kMwonhJHbRXvvs',
    appId: '1:433429123250:web:cf23ebdc1098d38d7fb9ab',
    messagingSenderId: '433429123250',
    projectId: 'com-example-flutter-appli-1',
    authDomain: 'com-example-flutter-appli-1.firebaseapp.com',
    storageBucket: 'com-example-flutter-appli-1.firebasestorage.app',
    measurementId: 'G-BQ1L1MTWBC',
  );
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\main.dart

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'firebase_options.dart';
import 'core/env.dart';
import 'core/router.dart';
import 'core/notifications/push_service.dart';

// NEW: panier global
import 'features/cart/cart_service.dart';
import 'features/cart/cart_scope.dart';

// Panier global (conservé pendant la session)
final CartService cartService = CartService();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  Env.validate();

  await Supabase.initialize(url: Env.supabaseUrl, anonKey: Env.supabaseAnonKey);
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  runApp(const App());

  // Initialize notifications after the first frame so UI isn't blocked.
  WidgetsBinding.instance.addPostFrameCallback((_) {
    NotificationService.init()
        .then((_) => NotificationService.requestPermissionAndSyncToken())
        .catchError((e, st) {
      debugPrint('NotificationService initialization failed: $e');
      debugPrint('$st');
    });
  });
}

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    final seed = const Color(0xFF4F46E5); // indigo premium

    return CartScope(
      cart: cartService,
      child: MaterialApp.router(
        title: 'PME/TPE',
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          useMaterial3: true,
          colorSchemeSeed: seed,
          brightness: Brightness.light,
          cardTheme: CardThemeData(
            elevation: 1,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          ),
          inputDecorationTheme: InputDecorationTheme(
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(14)),
          ),
          filledButtonTheme: FilledButtonThemeData(
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
            ),
          ),
        ),
        darkTheme: ThemeData(
          useMaterial3: true,
          colorSchemeSeed: seed,
          brightness: Brightness.dark,
        ),
        routerConfig: appRouter,
      ),
    );
  }
}

=============================================================================================

=============================================================================================

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\core\router.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'router_refresh.dart';

// Auth
import '../features/auth/login_page.dart';
import '../features/auth/auth_callback_page.dart';

// Public
import '../features/public/landing_page.dart';
import '../features/explore/explore_page.dart';
import '../features/business/public_business_page.dart';
import '../features/products/public_product_page.dart';

// App
import '../features/home/home_page.dart';
import '../features/business/create_business_page.dart';
import '../features/business/business_settings_page.dart';
import '../features/business/business_hours_page.dart';
import '../features/business/business_links_page.dart';
import '../features/business/business_domains_page.dart';

import '../features/products/business_products_page.dart';
import '../features/products/product_detail_page.dart';

import '../features/requests/business_requests_page.dart';
import '../features/requests/request_detail_page.dart';

import '../features/posts/business_posts_page.dart';
import '../features/posts/post_detail_page.dart';

// Cart
import '../features/cart/cart_page.dart';
import '../features/cart/checkout_page.dart';

final _authRefresh = GoRouterRefreshStream(
  Supabase.instance.client.auth.onAuthStateChange,
);

final appRouter = GoRouter(
  refreshListenable: _authRefresh,
  initialLocation: '/explore',

  redirect: (context, state) {
    final uri = state.uri;
    final path = uri.path;

    final session = Supabase.instance.client.auth.currentSession;
    final loggedIn = session != null;

    final isLogin = path == '/login';
    final isCallback = path == '/auth/callback';

    // Public routes (sans login)
    final isLanding = path == '/';
    final isExplore = path == '/explore';
    final isPublicBusiness = path.startsWith('/b/');
    final isPublicProduct = path.startsWith('/p/');
    final isCart = path == '/cart';

    // Checkout = public URL mais protégé (doit être loggé)
    final isCheckout = path == '/checkout';

    final isPublic = isLanding ||
        isExplore ||
        isPublicBusiness ||
        isPublicProduct ||
        isCart ||
        isLogin ||
        isCallback;

    if (!loggedIn) {
      // si non loggé et essaie checkout -> login + next
      if (isCheckout) {
        final full = Uri.encodeComponent(uri.toString());
        return '/login?next=$full';
      }

      // Autoriser les pages publiques
      if (isPublic) return null;

      // Tout le reste est protégé
      final full = Uri.encodeComponent(uri.toString());
      return '/login?next=$full';
    }

    // Logged-in: empêcher de rester sur /login et /auth/callback
    if (isLogin || isCallback) {
      final next = uri.queryParameters['next'];
      if (next != null && next.trim().isNotEmpty) {
        return Uri.decodeComponent(next);
      }
      return '/home';
    }

    return null;
  },

  routes: [
    // ========== PUBLIC ==========
    GoRoute(
      path: '/',
      builder: (context, state) => const LandingPage(),
    ),

    GoRoute(
      path: '/explore',
      builder: (context, state) => const ExplorePage(),
    ),

    GoRoute(
      path: '/b/:slug',
      builder: (context, state) =>
          PublicBusinessPage(slug: state.pathParameters['slug']!),
    ),

    GoRoute(
      path: '/p/:pid',
      builder: (context, state) =>
          PublicProductPage(productId: state.pathParameters['pid']!),
    ),

    // Cart public
    GoRoute(
      path: '/cart',
      builder: (context, state) => const CartPage(),
    ),
    GoRoute(
      path: '/checkout',
      builder: (context, state) => const CheckoutPage(),
    ),

    // ========== AUTH ==========
    GoRoute(
      path: '/login',
      builder: (context, state) => const LoginPage(),
    ),
    GoRoute(
      path: '/auth/callback',
      builder: (context, state) => const AuthCallbackPage(),
    ),

    // ========== APP (protégé) ==========
    GoRoute(
      path: '/home',
      builder: (context, state) => const HomePage(),
    ),

    GoRoute(
      path: '/business/create',
      builder: (context, state) => const CreateBusinessPage(),
    ),

    GoRoute(
      path: '/business/:id/settings',
      builder: (context, state) =>
          BusinessSettingsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: 'hours',
          builder: (context, state) =>
              BusinessHoursPage(businessId: state.pathParameters['id']!),
        ),
        GoRoute(
          path: 'links',
          builder: (context, state) =>
              BusinessLinksPage(businessId: state.pathParameters['id']!),
        ),
        GoRoute(
          path: 'domains',
          builder: (context, state) =>
              BusinessDomainsPage(businessId: state.pathParameters['id']!),
        ),
      ],
    ),

    GoRoute(
      path: '/business/:id/products',
      builder: (context, state) =>
          BusinessProductsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: ':pid',
          builder: (context, state) => ProductDetailPage(
            businessId: state.pathParameters['id']!,
            productId: state.pathParameters['pid']!,
          ),
        ),
      ],
    ),

    GoRoute(
      path: '/business/:id/requests',
      builder: (context, state) =>
          BusinessRequestsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: ':rid',
          builder: (context, state) => RequestDetailPage(
            businessId: state.pathParameters['id']!,
            requestId: state.pathParameters['rid']!,
          ),
        ),
      ],
    ),

    // Posts
    GoRoute(
      path: '/business/:id/posts',
      builder: (context, state) =>
          BusinessPostsPage(businessId: state.pathParameters['id']!),
      routes: [
        GoRoute(
          path: ':postId',
          builder: (context, state) => BusinessPostDetailPage(
            businessId: state.pathParameters['id']!,
            postId: state.pathParameters['postId']!,
          ),
        ),
      ],
    ),
  ],

  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: const Text('Erreur')),
    body: Center(child: Text(state.error.toString())),
  ),
);

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\explore\explore_page.dart

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:video_player/video_player.dart';

import '../cart/cart_scope.dart';
import '../cart/cart_service.dart';

// Ajuste le chemin selon ton projet :
import '../../core/route_observer.dart';

class ExplorePage extends StatefulWidget {
  const ExplorePage({super.key});

  @override
  State<ExplorePage> createState() => _ExplorePageState();
}

class _ExplorePageState extends State<ExplorePage> with RouteAware, WidgetsBindingObserver {
  final _sb = Supabase.instance.client;

  final _pageController = PageController();
  final _items = <_ExploreItem>[];

  bool _loading = false;
  bool _loadingMore = false;
  bool _hasMore = true;
  String? _error;

  static const _pageSize = 20;

  static const _productMediaBucket = 'product_media';
  static const _businessLogosBucket = 'business_logos';

  // UX
  int _currentIndex = 0;
  bool _videoAutoplay = true;

  // Son OFF par défaut
  bool _muted = true;

  // Visibilité de la route + app lifecycle
  bool _routeVisible = true;
  bool _appResumed = true;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _loadInitial();
    _pageController.addListener(_onPageChangedListener);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final route = ModalRoute.of(context);
    if (route is PageRoute) {
      routeObserver.subscribe(this, route);
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    routeObserver.unsubscribe(this);

    _pageController.removeListener(_onPageChangedListener);
    _pageController.dispose();
    super.dispose();
  }

  // RouteAware
  @override
  void didPushNext() {
    // Une nouvelle page couvre Explore => couper autoplay => pause/silence
    if (!mounted) return;
    setState(() => _routeVisible = false);
  }

  @override
  void didPopNext() {
    // Retour sur Explore
    if (!mounted) return;
    setState(() => _routeVisible = true);
  }

  // App lifecycle
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final resumed = state == AppLifecycleState.resumed;
    if (!mounted) return;
    setState(() => _appResumed = resumed);
  }

  void _onPageChangedListener() {
    final page = _pageController.page;
    if (page == null) return;
    final idx = page.round();
    if (idx != _currentIndex && idx >= 0 && idx < max(1, _items.length)) {
      setState(() => _currentIndex = idx);
    }
  }

  Future<void> _loadInitial() async {
    setState(() {
      _loading = true;
      _error = null;
      _items.clear();
      _hasMore = true;
      _currentIndex = 0;
    });

    try {
      await _loadMore(reset: true);
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _loadMore({bool reset = false}) async {
    if (_loadingMore) return;
    if (!_hasMore && !reset) return;

    setState(() => _loadingMore = true);

    final offset = reset ? 0 : _items.length;

    final resp = await _sb
        .from('products')
        .select('''
          id,title,description,price_amount,currency,created_at,business_id,
          businesses(id,name,slug,logo_path),
          product_media!inner(id,media_type,storage_path)
        ''')
        .eq('is_active', true)
        .not('price_amount', 'is', null)
        .order('created_at', ascending: false)
        .range(offset, offset + _pageSize - 1);

    final rows = (resp as List).map((e) => Map<String, dynamic>.from(e as Map)).toList();

    final newItems = rows
        .map(_ExploreItem.fromRow)
        .where((x) => x.businessSlug.isNotEmpty && (x.mediaPath ?? '').isNotEmpty)
        .toList();

    if (!mounted) return;
    setState(() {
      if (reset) _items.clear();
      _items.addAll(newItems);
      _hasMore = rows.length == _pageSize;
      _loadingMore = false;

      if (_currentIndex >= _items.length) {
        _currentIndex = max(0, _items.length - 1);
      }
    });
  }

  String? _productMediaUrl(_ExploreItem item) {
    final path = item.mediaPath;
    if (path == null || path.isEmpty) return null;
    return _sb.storage.from(_productMediaBucket).getPublicUrl(path);
  }

  String? _posterUrl(_ExploreItem item) {
    final logoPath = item.businessLogoPath;
    if (logoPath == null || logoPath.isEmpty) return null;
    return _sb.storage.from(_businessLogosBucket).getPublicUrl(logoPath);
  }

  Future<void> _addToCartAndOpen(_ExploreItem item, String? mediaUrl) async {
    final cart = CartScope.of(context);
    final messenger = ScaffoldMessenger.of(context);

    if (item.priceAmount == null) {
      messenger.showSnackBar(const SnackBar(content: Text('Prix non défini pour ce produit.')));
      return;
    }

    try {
      cart.add(
        productId: item.productId,
        businessId: item.businessId,
        title: item.title,
        unitPrice: item.priceAmount!,
        currency: item.currency,
        mediaUrl: mediaUrl,
        qty: 1,
      );

      messenger.showSnackBar(const SnackBar(content: Text('Ajouté au panier')));
      if (!mounted) return;
      context.push('/cart');
    } on CartBusinessMismatch {
      final ok = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text('Panier d’une autre boutique'),
          content: const Text(
            'Votre panier contient déjà des produits d’une autre boutique. Voulez-vous vider le panier ?',
          ),
          actions: [
            TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Annuler')),
            ElevatedButton(onPressed: () => Navigator.of(ctx).pop(true), child: const Text('Vider')),
          ],
        ),
      );

      if (ok == true) {
        cart.clear();
        cart.add(
          productId: item.productId,
          businessId: item.businessId,
          title: item.title,
          unitPrice: item.priceAmount!,
          currency: item.currency,
          mediaUrl: mediaUrl,
          qty: 1,
        );
        messenger.showSnackBar(const SnackBar(content: Text('Nouveau panier créé')));
        if (!mounted) return;
        context.push('/cart');
      }
    } catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Erreur panier: $e')));
    }
  }

  Widget _cartIcon(BuildContext context) {
    final cart = CartScope.of(context);

    return AnimatedBuilder(
      animation: cart,
      builder: (context, child) {
        final qty = cart.totalQty;
        return Stack(
          children: [
            IconButton(
              tooltip: 'Panier',
              onPressed: () => context.push('/cart'),
              icon: const Icon(Icons.shopping_cart_outlined),
            ),
            if (qty > 0)
              Positioned(
                right: 6,
                top: 6,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.redAccent,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '$qty',
                    style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  void _openBusinessSpace() {
    final user = _sb.auth.currentUser;
    if (user == null) {
      final next = Uri.encodeComponent('/home');
      context.push('/login?next=$next');
    } else {
      context.go('/home');
    }
  }

  bool get _canPlayMediaNow => _routeVisible && _appResumed;

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, result) {
        if (didPop) return;
      },
      child: Scaffold(
        body: _loading
            ? const Center(child: CircularProgressIndicator())
            : (_error != null)
                ? _ErrorView(message: _error!, onRetry: _loadInitial)
                : NotificationListener<ScrollNotification>(
                    onNotification: (_) {
                      final page = _pageController.hasClients ? (_pageController.page ?? 0) : 0;
                      if (_hasMore && !_loadingMore && page >= max(0, _items.length - 3)) {
                        _loadMore();
                      }
                      return false;
                    },
                    child: PageView.builder(
                      controller: _pageController,
                      scrollDirection: Axis.vertical,
                      physics: const _SnappyPageScrollPhysics(),
                      itemCount: max(1, _items.length),
                      itemBuilder: (context, index) {
                        if (_items.isEmpty) {
                          return _EmptyExplore(onRefresh: _loadInitial, onOpenBusinessSpace: _openBusinessSpace);
                        }

                        final item = _items[index];
                        final mediaUrl = _productMediaUrl(item);
                        final posterUrl = _posterUrl(item);

                        final isActivePage = index == _currentIndex;

                        // Pré-charger page voisine
                        final preload = (index == _currentIndex) || (index == _currentIndex + 1) || (index == _currentIndex - 1);

                        // IMPORTANT: autoplay seulement si route visible + app resumed
                        final allowAutoplay = _videoAutoplay && isActivePage && _canPlayMediaNow;

                        return Stack(
                          fit: StackFit.expand,
                          children: [
                            GestureDetector(
                              onTap: () => context.push('/p/${item.productId}'),
                              child: _MediaBackground(
                                mediaUrl: mediaUrl,
                                posterUrl: posterUrl,
                                mediaType: item.mediaType,
                                autoplay: allowAutoplay,
                                preload: preload && _canPlayMediaNow,
                                muted: _muted,
                                onToggleMute: () => setState(() => _muted = !_muted),
                              ),
                            ),
                            const _BottomGradient(),
                            _OverlayInfo(
                              item: item,
                              onOpenBusiness: () => context.push('/b/${item.businessSlug}'),
                              onOpenProduct: () => context.push('/p/${item.productId}'),
                              onAddToCart: () => _addToCartAndOpen(item, mediaUrl),
                            ),
                            Positioned(
                              top: MediaQuery.of(context).padding.top + 10,
                              left: 16,
                              right: 16,
                              child: Row(
                                children: [
                                  const Text('Explorer', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w700)),
                                  const Spacer(),
                                  TextButton.icon(
                                    onPressed: _openBusinessSpace,
                                    icon: const Icon(Icons.store_mall_directory_outlined),
                                    label: const Text('Espace entreprise'),
                                  ),
                                  _cartIcon(context),

                                  IconButton(
                                    tooltip: _videoAutoplay ? 'Auto-play: ON' : 'Auto-play: OFF',
                                    onPressed: () => setState(() => _videoAutoplay = !_videoAutoplay),
                                    icon: Icon(_videoAutoplay ? Icons.play_circle : Icons.pause_circle),
                                  ),

                                  IconButton(
                                    tooltip: _muted ? 'Son: OFF' : 'Son: ON',
                                    onPressed: () => setState(() => _muted = !_muted),
                                    icon: Icon(_muted ? Icons.volume_off : Icons.volume_up),
                                  ),

                                  IconButton(
                                    tooltip: 'Rafraîchir',
                                    onPressed: _loadInitial,
                                    icon: const Icon(Icons.refresh),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        );
                      },
                    ),
                  ),
      ),
    );
  }
}

class _ExploreItem {
  final String productId;
  final String title;
  final String? description;
  final num? priceAmount;
  final String currency;

  final String businessId;
  final String businessName;
  final String businessSlug;
  final String? businessLogoPath;

  final String? mediaType;
  final String? mediaPath;

  _ExploreItem({
    required this.productId,
    required this.title,
    required this.description,
    required this.priceAmount,
    required this.currency,
    required this.businessId,
    required this.businessName,
    required this.businessSlug,
    required this.businessLogoPath,
    required this.mediaType,
    required this.mediaPath,
  });

  static _ExploreItem fromRow(Map<String, dynamic> row) {
    final biz = row['businesses'];
    Map<String, dynamic>? bizMap;
    if (biz is Map) bizMap = Map<String, dynamic>.from(biz);
    if (biz is List && biz.isNotEmpty) bizMap = Map<String, dynamic>.from(biz.first as Map);

    final media = row['product_media'];
    Map<String, dynamic>? m0;
    if (media is List && media.isNotEmpty) m0 = Map<String, dynamic>.from(media.first as Map);
    if (media is Map) m0 = Map<String, dynamic>.from(media);

    return _ExploreItem(
      productId: (row['id'] ?? '').toString(),
      title: (row['title'] ?? '').toString(),
      description: row['description']?.toString(),
      priceAmount: row['price_amount'] as num?,
      currency: (row['currency'] ?? 'XOF').toString(),
      businessId: (row['business_id'] ?? '').toString(),
      businessName: (bizMap?['name'] ?? '').toString(),
      businessSlug: (bizMap?['slug'] ?? '').toString(),
      businessLogoPath: (bizMap?['logo_path'])?.toString(),
      mediaType: m0?['media_type']?.toString(),
      mediaPath: m0?['storage_path']?.toString(),
    );
  }
}

class _MediaBackground extends StatelessWidget {
  final String? mediaUrl;
  final String? posterUrl;
  final String? mediaType;
  final bool autoplay;
  final bool preload;
  final bool muted;
  final VoidCallback onToggleMute;

  const _MediaBackground({
    required this.mediaUrl,
    required this.posterUrl,
    required this.mediaType,
    required this.autoplay,
    required this.preload,
    required this.muted,
    required this.onToggleMute,
  });

  @override
  Widget build(BuildContext context) {
    if (mediaUrl == null) {
      return Container(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        child: const Center(child: Icon(Icons.image_not_supported)),
      );
    }

    final mt = (mediaType ?? '').toLowerCase();

    if (mt == 'video') {
      return _VideoBackground(
        url: mediaUrl!,
        posterUrl: posterUrl,
        autoplay: autoplay,
        preload: preload,
        muted: muted,
        onToggleMute: onToggleMute,
      );
    }

    return _ProImage(url: mediaUrl!);
  }
}

class _ProImage extends StatelessWidget {
  final String url;
  const _ProImage({required this.url});

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        Image.network(
          url,
          fit: BoxFit.cover,
          errorBuilder: (_, __, ___) => Container(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
            child: const Center(child: Icon(Icons.broken_image)),
          ),
        ),
        BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 14, sigmaY: 14),
          child: Container(color: Colors.black.withOpacity(0.12)),
        ),
        Center(
          child: Image.network(
            url,
            fit: BoxFit.contain,
            alignment: Alignment.center,
            loadingBuilder: (context, child, progress) {
              if (progress == null) return child;
              return const Center(child: CircularProgressIndicator());
            },
            errorBuilder: (_, __, ___) => const Center(child: Icon(Icons.broken_image)),
          ),
        ),
      ],
    );
  }
}

class _VideoBackground extends StatefulWidget {
  final String url;
  final String? posterUrl;
  final bool autoplay;
  final bool preload;
  final bool muted;
  final VoidCallback onToggleMute;

  const _VideoBackground({
    required this.url,
    required this.posterUrl,
    required this.autoplay,
    required this.preload,
    required this.muted,
    required this.onToggleMute,
  });

  @override
  State<_VideoBackground> createState() => _VideoBackgroundState();
}

class _VideoBackgroundState extends State<_VideoBackground> {
  VideoPlayerController? _controller;
  bool _init = false;
  String? _err;

  // IMPORTANT: respecte pause manuelle (autoplay ne relance pas derrière)
  bool _userPaused = false;

  @override
  void initState() {
    super.initState();
    if (widget.preload || widget.autoplay) {
      _setup();
    }
  }

  @override
  void didUpdateWidget(covariant _VideoBackground oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.url != widget.url) {
      _disposeController();
      _err = null;
      _init = false;
      _userPaused = false;
      if (widget.preload || widget.autoplay) {
        _setup();
      }
      return;
    }

    if ((_controller == null || !_init) && (widget.preload || widget.autoplay) && _err == null) {
      _setup();
      return;
    }

    final c = _controller;
    if (!_init || c == null) return;

    // Si la page n’est pas active => pause + silence forcé
    if (!widget.autoplay) {
      // Quand on quitte la page active, on reset la pause manuelle (comportement type TikTok)
      if (oldWidget.autoplay == true && widget.autoplay == false) {
        _userPaused = false;
      }
      _pauseAndSilence(c);
      return;
    }

    // Page active: si l’utilisateur a mis pause, on respecte
    if (_userPaused) {
      _pauseAndSilence(c);
      return;
    }

    // Sinon autoplay normal
    c.setVolume(widget.muted ? 0.0 : 1.0);
    if (!c.value.isPlaying) c.play();
  }

  Future<void> _setup() async {
    try {
      final c = VideoPlayerController.networkUrl(Uri.parse(widget.url));
      _controller = c;

      await c.initialize();
      c.setLooping(true);

      if (!mounted) return;
      setState(() => _init = true);

      if (widget.autoplay && !_userPaused) {
        c.setVolume(widget.muted ? 0.0 : 1.0);
        c.play();
      } else {
        _pauseAndSilence(c);
      }
    } catch (e) {
      if (!mounted) return;
      setState(() => _err = e.toString());
    }
  }

  void _pauseAndSilence(VideoPlayerController c) {
    // “hard stop” audio
    if (c.value.isPlaying) {
      c.pause();
    }
    c.setVolume(0.0);
  }

  void _disposeController() {
    final c = _controller;
    _controller = null;
    _init = false;
    if (c != null) {
      _pauseAndSilence(c);
      c.dispose();
    }
  }

  @override
  void dispose() {
    _disposeController();
    super.dispose();
  }

  void _togglePlay() {
    final c = _controller;
    if (!_init || c == null) return;

    setState(() {
      if (c.value.isPlaying) {
        _userPaused = true;
        _pauseAndSilence(c);
      } else {
        _userPaused = false;
        c.setVolume(widget.muted ? 0.0 : 1.0);
        c.play();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_err != null) {
      if ((widget.posterUrl ?? '').isNotEmpty) {
        return Stack(
          fit: StackFit.expand,
          children: [
            _ProImage(url: widget.posterUrl!),
            Center(
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.45),
                  borderRadius: BorderRadius.circular(14),
                ),
                child: const Text(
                  'Vidéo indisponible',
                  style: TextStyle(color: Colors.white70, fontWeight: FontWeight.w700),
                ),
              ),
            ),
          ],
        );
      }
      return Container(
        color: Colors.black,
        alignment: Alignment.center,
        child: const Text('Vidéo indisponible', textAlign: TextAlign.center, style: TextStyle(color: Colors.white70)),
      );
    }

    if (!_init || _controller == null) {
      if ((widget.posterUrl ?? '').isNotEmpty) {
        return Stack(
          fit: StackFit.expand,
          children: [
            _ProImage(url: widget.posterUrl!),
            const Center(child: Icon(Icons.play_circle_fill, size: 64, color: Colors.white70)),
          ],
        );
      }
      return Container(color: Colors.black, alignment: Alignment.center, child: const CircularProgressIndicator());
    }

    final c = _controller!;

    return Stack(
      fit: StackFit.expand,
      children: [
        FittedBox(
          fit: BoxFit.cover,
          child: SizedBox(
            width: c.value.size.width,
            height: c.value.size.height,
            child: VideoPlayer(c),
          ),
        ),

        Positioned.fill(
          child: Material(color: Colors.transparent, child: InkWell(onTap: _togglePlay)),
        ),

        Align(
          alignment: Alignment.center,
          child: AnimatedOpacity(
            opacity: c.value.isPlaying ? 0.0 : 1.0,
            duration: const Duration(milliseconds: 160),
            child: Container(
              padding: const EdgeInsets.all(14),
              decoration: BoxDecoration(color: Colors.black.withOpacity(0.45), shape: BoxShape.circle),
              child: const Icon(Icons.play_arrow, color: Colors.white, size: 44),
            ),
          ),
        ),

        Positioned(
          right: 12,
          top: 12,
          child: IconButton.filledTonal(
            onPressed: widget.onToggleMute,
            icon: Icon(widget.muted ? Icons.volume_off : Icons.volume_up),
          ),
        ),
      ],
    );
  }
}

class _SnappyPageScrollPhysics extends PageScrollPhysics {
  const _SnappyPageScrollPhysics({super.parent});

  @override
  _SnappyPageScrollPhysics applyTo(ScrollPhysics? ancestor) {
    return _SnappyPageScrollPhysics(parent: buildParent(ancestor));
  }

  @override
  double get minFlingDistance => 5.0;

  @override
  double get minFlingVelocity => 180.0;

  @override
  double get dragStartDistanceMotionThreshold => 2.0;
}

class _BottomGradient extends StatelessWidget {
  const _BottomGradient();

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: Container(
        height: 260,
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Colors.transparent, Colors.black54, Colors.black87],
          ),
        ),
      ),
    );
  }
}

class _OverlayInfo extends StatelessWidget {
  final _ExploreItem item;
  final VoidCallback onOpenBusiness;
  final VoidCallback onOpenProduct;
  final VoidCallback onAddToCart;

  const _OverlayInfo({
    required this.item,
    required this.onOpenBusiness,
    required this.onOpenProduct,
    required this.onAddToCart,
  });

  String _price() {
    if (item.priceAmount == null) return '';
    return '${item.priceAmount} ${item.currency}';
  }

  @override
  Widget build(BuildContext context) {
    final canOrder = item.priceAmount != null;

    return Positioned(
      left: 16,
      right: 16,
      bottom: 22,
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                InkWell(
                  onTap: onOpenBusiness,
                  child: Text(
                    '@${item.businessSlug} • ${item.businessName}',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w700),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  item.title,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.w800),
                ),
                if ((item.description ?? '').trim().isNotEmpty) ...[
                  const SizedBox(height: 6),
                  Text(item.description!, maxLines: 2, overflow: TextOverflow.ellipsis, style: const TextStyle(color: Colors.white70)),
                ],
                const SizedBox(height: 8),
                if (_price().isNotEmpty) Text(_price(), style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w700)),
              ],
            ),
          ),
          const SizedBox(width: 12),
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              FilledButton(onPressed: onOpenProduct, child: const Text('Voir')),
              const SizedBox(height: 10),
              FilledButton.icon(
                onPressed: canOrder ? onAddToCart : null,
                icon: const Icon(Icons.shopping_cart_checkout),
                label: const Text('Commander'),
              ),
              const SizedBox(height: 10),
              OutlinedButton(
                onPressed: onOpenBusiness,
                style: OutlinedButton.styleFrom(foregroundColor: Colors.white),
                child: const Text('Boutique'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;

  const _ErrorView({required this.message, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(message, style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 12),
            FilledButton(onPressed: onRetry, child: const Text('Réessayer')),
          ],
        ),
      ),
    );
  }
}

class _EmptyExplore extends StatelessWidget {
  final VoidCallback onRefresh;
  final VoidCallback onOpenBusinessSpace;

  const _EmptyExplore({required this.onRefresh, required this.onOpenBusinessSpace});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(18),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('Aucun produit publié pour le moment.'),
            const SizedBox(height: 10),
            FilledButton(onPressed: onRefresh, child: const Text('Rafraîchir')),
            const SizedBox(height: 10),
            OutlinedButton.icon(
              onPressed: onOpenBusinessSpace,
              icon: const Icon(Icons.store_mall_directory_outlined),
              label: const Text('Espace entreprise'),
            ),
          ],
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\products\public_product_page.dart

import 'dart:ui' show ImageFilter;

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:video_player/video_player.dart';

import '../cart/cart_scope.dart';
import '../cart/cart_service.dart';

// IMPORTANT:
// 1) Create a global RouteObserver in (example) lib/core/route_observer.dart:
//    final RouteObserver<PageRoute<dynamic>> routeObserver = RouteObserver<PageRoute<dynamic>>();
// 2) Add it to GoRouter(observers: [routeObserver])
// Adjust this import path to your project:
import '../../core/route_observer.dart';

class PublicProductPage extends StatefulWidget {
  final String productId;
  const PublicProductPage({super.key, required this.productId});

  @override
  State<PublicProductPage> createState() => _PublicProductPageState();
}

class _PublicProductPageState extends State<PublicProductPage>
    with RouteAware, WidgetsBindingObserver {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;

  Map<String, dynamic>? _product;
  List<Map<String, dynamic>> _variants = [];

  String? _selectedVariantId;

  static const _productMediaBucket = 'product_media';

  bool get _loggedIn => _sb.auth.currentSession != null;

  // Audio: OFF by default (page-level)
  bool _muted = true;

  // Route/app visibility => hard-stop video audio when not visible
  bool _routeVisible = true;
  bool _appResumed = true;

  bool get _pageActive => _routeVisible && _appResumed;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _load();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final r = ModalRoute.of(context);
    if (r is PageRoute) routeObserver.subscribe(this, r);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    routeObserver.unsubscribe(this);
    super.dispose();
  }

  // RouteAware: another route covers this page
  @override
  void didPushNext() {
    if (!mounted) return;
    setState(() => _routeVisible = false);
  }

  // RouteAware: coming back to this page
  @override
  void didPopNext() {
    if (!mounted) return;
    setState(() => _routeVisible = true);
  }

  // App lifecycle: background/foreground
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final resumed = state == AppLifecycleState.resumed;
    if (!mounted) return;
    setState(() => _appResumed = resumed);
  }

  Future<void> _load() async {
    if (!mounted) return;

    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final p = await _sb
          .from('products')
          .select(
            'id,title,description,price_amount,currency,business_id,'
            'businesses(id,name,slug),'
            'product_media(id,media_type,storage_path)',
          )
          .eq('id', widget.productId)
          .maybeSingle();

      if (p == null) {
        if (!mounted) return;
        setState(() => _error = 'Produit introuvable.');
        return;
      }

      final v = await _sb
          .from('product_variants')
          .select('id,title,price_amount,currency,is_active,options,created_at')
          .eq('product_id', widget.productId)
          .eq('is_active', true)
          .order('created_at', ascending: true);

      final variants = (v as List)
          .map((e) => Map<String, dynamic>.from(e as Map))
          .toList();

      if (!mounted) return;
      setState(() {
        _product = Map<String, dynamic>.from(p as Map);
        _variants = variants;

        if (_variants.isNotEmpty) {
          _selectedVariantId ??= _variants.first['id']?.toString();
        }
      });
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  // ---------------- MEDIA HELPERS ----------------

  List<Map<String, dynamic>> _mediaList() {
    final media = _product?['product_media'];
    if (media is List) {
      return media.map((e) => Map<String, dynamic>.from(e as Map)).toList();
    }
    if (media is Map) {
      return [Map<String, dynamic>.from(media)];
    }
    return [];
  }

  ({String? url, String? type}) _primaryMedia() {
    final list = _mediaList();
    if (list.isEmpty) return (url: null, type: null);

    // Prefer image as hero if available
    Map<String, dynamic> chosen = list.first;
    for (final m in list) {
      final t = (m['media_type'] ?? '').toString().toLowerCase();
      if (t == 'image') {
        chosen = m;
        break;
      }
    }

    final type = (chosen['media_type'] ?? '').toString().toLowerCase();
    final path = (chosen['storage_path'] ?? '').toString();
    if (path.isEmpty) return (url: null, type: type.isEmpty ? null : type);

    final url = _sb.storage.from(_productMediaBucket).getPublicUrl(path);
    return (url: url, type: type.isEmpty ? null : type);
  }

  // Used for cart thumb: use primary hero media (prefer image)
  String? _mediaUrlForCart() => _primaryMedia().url;

  // ---------------- CART ----------------

  Widget _cartIcon(BuildContext context) {
    final cart = CartScope.of(context);

    return AnimatedBuilder(
      animation: cart,
      builder: (context, child) {
        final qty = cart.totalQty;
        return Stack(
          clipBehavior: Clip.none,
          children: [
            IconButton(
              tooltip: 'Panier',
              onPressed: () => context.push('/cart'),
              icon: const Icon(Icons.shopping_cart_outlined),
            ),
            if (qty > 0)
              Positioned(
                right: 6,
                top: 6,
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.redAccent,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '$qty',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  void _openBusinessSpace() {
    if (_loggedIn) {
      context.go('/home');
    } else {
      final next = Uri.encodeComponent('/home');
      context.push('/login?next=$next');
    }
  }

  Map<String, dynamic>? get _selectedVariant {
    if (_selectedVariantId == null) return null;
    for (final v in _variants) {
      if (v['id']?.toString() == _selectedVariantId) return v;
    }
    return null;
  }

  String _cartLineId(String productId, {String? variantId}) {
    if (variantId == null || variantId.isEmpty) return productId;
    return '$productId::$variantId';
  }

  Future<void> _addToCartAndOpen() async {
    final p = _product;
    if (p == null) return;

    final messenger = ScaffoldMessenger.of(context);
    final cart = CartScope.of(context);

    final baseProductId = (p['id'] ?? '').toString();
    final businessId = (p['business_id'] ?? '').toString();
    final title = (p['title'] ?? '').toString();

    num? unitPrice = p['price_amount'] as num?;
    String currency = (p['currency'] ?? 'XOF').toString();

    final variant = _selectedVariant;
    final variantId = variant?['id']?.toString();
    final variantTitle = (variant?['title'] ?? '').toString().trim();

    if (variant != null) {
      final vPrice = variant['price_amount'];
      if (vPrice is num) unitPrice = vPrice;
      currency = (variant['currency'] ?? currency).toString();
    }

    if (unitPrice == null || unitPrice <= 0) {
      messenger.showSnackBar(
        const SnackBar(content: Text('Prix indisponible pour ce produit.')),
      );
      return;
    }

    final lineId = _cartLineId(baseProductId, variantId: variantId);
    final lineTitle = variantTitle.isEmpty ? title : '$title — $variantTitle';

    try {
      cart.add(
        productId: lineId,
        businessId: businessId,
        title: lineTitle,
        unitPrice: unitPrice,
        currency: currency,
        mediaUrl: _mediaUrlForCart(),
        qty: 1,
      );

      messenger.showSnackBar(const SnackBar(content: Text('Ajouté au panier')));
      if (!mounted) return;
      context.push('/cart');
    } on CartBusinessMismatch {
      final ok = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text('Panier d’une autre boutique'),
          content: const Text(
            'Votre panier contient déjà des produits d’une autre boutique. Voulez-vous vider le panier ?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text('Annuler'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: const Text('Vider'),
            ),
          ],
        ),
      );

      if (ok == true) {
        cart.clear();
        cart.add(
          productId: lineId,
          businessId: businessId,
          title: lineTitle,
          unitPrice: unitPrice,
          currency: currency,
          mediaUrl: _mediaUrlForCart(),
          qty: 1,
        );
        if (!mounted) return;
        context.push('/cart');
      }
    } catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Erreur panier: $e')));
    }
  }

  // ---------------- UI ----------------

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () =>
              context.canPop() ? context.pop() : context.go('/explore'),
        ),
        title: const Text('Produit'),
        actions: [
          IconButton(
            tooltip: _muted ? 'Son: OFF' : 'Son: ON',
            onPressed: () => setState(() => _muted = !_muted),
            icon: Icon(_muted ? Icons.volume_off : Icons.volume_up),
          ),
          TextButton.icon(
            onPressed: _openBusinessSpace,
            icon: const Icon(Icons.storefront),
            label: const Text('Espace'),
          ),
          _cartIcon(context),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : (_error != null)
              ? Center(
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child:
                        Text(_error!, style: const TextStyle(color: Colors.red)),
                  ),
                )
              : _buildContent(context),
    );
  }

  Widget _buildContent(BuildContext context) {
    final p = _product!;
    final title = (p['title'] ?? '').toString();
    final desc = (p['description'] ?? '').toString();

    final biz = p['businesses'];
    Map<String, dynamic>? bizMap;
    if (biz is Map) bizMap = Map<String, dynamic>.from(biz);
    if (biz is List && biz.isNotEmpty) {
      bizMap = Map<String, dynamic>.from(biz.first as Map);
    }
    final slug = (bizMap?['slug'] ?? '').toString();

    final media = _primaryMedia();
    final mediaUrl = media.url;
    final mediaType = (media.type ?? '').toLowerCase();

    num? basePrice = p['price_amount'] as num?;
    String baseCur = (p['currency'] ?? 'XOF').toString();

    final variant = _selectedVariant;
    if (variant != null && variant['price_amount'] is num) {
      basePrice = variant['price_amount'] as num;
      baseCur = (variant['currency'] ?? baseCur).toString();
    }

    final priceText = (basePrice == null) ? '—' : '$basePrice $baseCur';

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        if (mediaUrl != null)
          ClipRRect(
            borderRadius: BorderRadius.circular(16),
            child: AspectRatio(
              aspectRatio: 1,
              child: _MediaHero(
                url: mediaUrl,
                type: mediaType,
                active: _pageActive,
                muted: _muted,
                onToggleMute: () => setState(() => _muted = !_muted),
              ),
            ),
          ),
        const SizedBox(height: 14),
        Text(title,
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.w800)),
        if (desc.trim().isNotEmpty) ...[
          const SizedBox(height: 8),
          Text(desc),
        ],
        const SizedBox(height: 14),

        if (_variants.isNotEmpty) ...[
          const Text('Variante', style: TextStyle(fontWeight: FontWeight.w800)),
          const SizedBox(height: 8),
          DropdownButtonFormField<String>(
            initialValue: _selectedVariantId,
            decoration: const InputDecoration(labelText: 'Choisir une variante'),
            items: _variants.map((v) {
              final id = v['id']?.toString() ?? '';
              final t = (v['title'] ?? 'Variante').toString();
              final pr = v['price_amount'];
              final cur = (v['currency'] ?? baseCur).toString();
              final subtitle = (pr is num) ? ' — $pr $cur' : '';
              return DropdownMenuItem(
                value: id,
                child: Text('$t$subtitle',
                    maxLines: 1, overflow: TextOverflow.ellipsis),
              );
            }).toList(),
            onChanged: (val) => setState(() => _selectedVariantId = val),
          ),
          const SizedBox(height: 10),
        ],

        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Row(
              children: [
                const Text('Prix', style: TextStyle(fontWeight: FontWeight.w700)),
                const Spacer(),
                Text(priceText,
                    style: const TextStyle(fontWeight: FontWeight.w800)),
              ],
            ),
          ),
        ),

        const SizedBox(height: 12),
        FilledButton.icon(
          onPressed: _addToCartAndOpen,
          icon: const Icon(Icons.shopping_cart_checkout),
          label: const Text('Commander'),
        ),
        const SizedBox(height: 10),
        OutlinedButton.icon(
          onPressed: () => context.push('/cart'),
          icon: const Icon(Icons.shopping_cart_outlined),
          label: const Text('Voir le panier'),
        ),

        const SizedBox(height: 12),
        FilledButton(
          onPressed: slug.isEmpty ? null : () => context.push('/b/$slug'),
          child: const Text('Voir la boutique'),
        ),
      ],
    );
  }
}

class _MediaHero extends StatelessWidget {
  final String url;
  final String type; // image | video
  final bool active; // route visible + app resumed
  final bool muted;
  final VoidCallback onToggleMute;

  const _MediaHero({
    required this.url,
    required this.type,
    required this.active,
    required this.muted,
    required this.onToggleMute,
  });

  @override
  Widget build(BuildContext context) {
    final t = type.toLowerCase();

    if (t == 'video') {
      return _VideoHero(
        url: url,
        active: active,
        muted: muted,
        onToggleMute: onToggleMute,
      );
    }

    // IMAGE: blur background + contain foreground
    return Stack(
      fit: StackFit.expand,
      children: [
        Image.network(
          url,
          fit: BoxFit.cover,
          errorBuilder: (_, __, ___) => Container(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
            child: const Center(child: Icon(Icons.broken_image)),
          ),
        ),
        BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 14, sigmaY: 14),
          child: Container(color: Colors.black.withOpacity(0.15)),
        ),
        Center(
          child: Image.network(
            url,
            fit: BoxFit.contain,
            errorBuilder: (_, __, ___) => const Icon(Icons.broken_image),
            loadingBuilder: (_, child, progress) {
              if (progress == null) return child;
              return const Center(child: CircularProgressIndicator());
            },
          ),
        ),
      ],
    );
  }
}

class _VideoHero extends StatefulWidget {
  final String url;
  final bool active;
  final bool muted;
  final VoidCallback onToggleMute;

  const _VideoHero({
    required this.url,
    required this.active,
    required this.muted,
    required this.onToggleMute,
  });

  @override
  State<_VideoHero> createState() => _VideoHeroState();
}

class _VideoHeroState extends State<_VideoHero> {
  VideoPlayerController? _controller;
  bool _init = false;
  String? _err;

  // If user paused manually, we do NOT auto-resume (safety + predictable UX)
  bool _userPaused = true;

  @override
  void initState() {
    super.initState();
    _setup();
  }

  @override
  void didUpdateWidget(covariant _VideoHero oldWidget) {
    super.didUpdateWidget(oldWidget);

    // URL changed => full reset
    if (oldWidget.url != widget.url) {
      _disposeController();
      _err = null;
      _init = false;
      _userPaused = true;
      _setup();
      return;
    }

    final c = _controller;
    if (!_init || c == null) return;

    // If page not active => hard stop (pause + volume 0)
    if (!widget.active) {
      _userPaused = true; // do not auto-resume when user comes back
      _pauseAndSilence(c);
      return;
    }

    // Active: apply volume
    c.setVolume(widget.muted ? 0.0 : 1.0);

    // If user had not paused and was playing, keep it playing.
    // If user paused, keep it paused.
    if (_userPaused) {
      if (c.value.isPlaying) _pauseAndSilence(c);
    }
  }

  Future<void> _setup() async {
    try {
      final c = VideoPlayerController.networkUrl(
        Uri.parse(widget.url),
        videoPlayerOptions: VideoPlayerOptions(
          mixWithOthers: false,
        ),
      );
      _controller = c;

      await c.initialize();
      c.setLooping(true);

      if (!mounted) return;
      setState(() => _init = true);

      // Start paused by default (user taps to play).
      _pauseAndSilence(c);

      // Apply current mute state even while paused
      c.setVolume(widget.muted ? 0.0 : 1.0);

      // If page not active, enforce silence
      if (!widget.active) {
        _userPaused = true;
        _pauseAndSilence(c);
      }
    } catch (e) {
      if (!mounted) return;
      setState(() => _err = e.toString());
    }
  }

  void _pauseAndSilence(VideoPlayerController c) {
    if (c.value.isPlaying) c.pause();
    c.setVolume(0.0);
  }

  void _disposeController() {
    final c = _controller;
    _controller = null;
    _init = false;
    if (c != null) {
      _pauseAndSilence(c);
      c.dispose();
    }
  }

  @override
  void dispose() {
    _disposeController();
    super.dispose();
  }

  void _toggle() {
    final c = _controller;
    if (c == null || !_init) return;

    // If page is not active, never play
    if (!widget.active) {
      _userPaused = true;
      _pauseAndSilence(c);
      return;
    }

    setState(() {
      if (c.value.isPlaying) {
        _userPaused = true;
        _pauseAndSilence(c);
      } else {
        _userPaused = false;
        c.setVolume(widget.muted ? 0.0 : 1.0);
        c.play();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_err != null) {
      return Container(
        color: Colors.black,
        alignment: Alignment.center,
        child: Text(
          'Impossible de lire la vidéo.\n$_err',
          textAlign: TextAlign.center,
          style: const TextStyle(color: Colors.white70),
        ),
      );
    }

    if (!_init || _controller == null) {
      return Container(
        color: Colors.black,
        alignment: Alignment.center,
        child: const CircularProgressIndicator(),
      );
    }

    final c = _controller!;

    return Stack(
      fit: StackFit.expand,
      children: [
        FittedBox(
          fit: BoxFit.cover,
          child: SizedBox(
            width: c.value.size.width,
            height: c.value.size.height,
            child: VideoPlayer(c),
          ),
        ),

        // Tap anywhere: play/pause
        Positioned.fill(
          child: Material(
            color: Colors.transparent,
            child: InkWell(onTap: _toggle),
          ),
        ),

        // Play overlay
        Align(
          alignment: Alignment.center,
          child: AnimatedOpacity(
            opacity: c.value.isPlaying ? 0.0 : 1.0,
            duration: const Duration(milliseconds: 180),
            child: Container(
              padding: const EdgeInsets.all(14),
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.45),
                shape: BoxShape.circle,
              ),
              child: const Icon(Icons.play_arrow, color: Colors.white, size: 44),
            ),
          ),
        ),

        // Mute button (video-level)
        Positioned(
          right: 12,
          top: 12,
          child: IconButton.filledTonal(
            onPressed: widget.onToggleMute,
            icon: Icon(widget.muted ? Icons.volume_off : Icons.volume_up),
          ),
        ),
      ],
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\posts\post_detail_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

class BusinessPostDetailPage extends StatelessWidget {
  final String businessId;
  final String postId;

  const BusinessPostDetailPage({
    super.key,
    required this.businessId,
    required this.postId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.canPop() ? context.pop() : context.push('/business/$businessId/posts'),
        ),
        title: const Text('Détail Post'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Text('TODO: afficher/éditer le post $postId'),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\orders\order_product_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:url_launcher/url_launcher.dart';

class OrderProductPage extends StatefulWidget {
  final String productId;
  const OrderProductPage({super.key, required this.productId});

  @override
  State<OrderProductPage> createState() => _OrderProductPageState();
}

class _OrderProductPageState extends State<OrderProductPage> {
  final sb = Supabase.instance.client;

  final _formKey = GlobalKey<FormState>();
  final _nameCtrl = TextEditingController();
  final _phoneCtrl = TextEditingController();
  final _addressCtrl = TextEditingController();

  bool _loading = false;
  String? _error;
  Map<String, dynamic>? _product;

  @override
  void initState() {
    super.initState();
    _loadProduct();
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    _phoneCtrl.dispose();
    _addressCtrl.dispose();
    super.dispose();
  }

  Future<void> _loadProduct() async {
    setState(() {
      _error = null;
      _product = null;
    });

    try {
      final row = await sb
          .from('products')
          .select('id, title, price_amount, business_id')
          .eq('id', widget.productId)
          .single();

      if (!mounted) return;
      setState(() => _product = Map<String, dynamic>.from(row as Map));
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    }
  }

  Future<void> _submit() async {
    // Capture tout ce qui dépend de context AVANT le premier await (lint OK)
    final messenger = ScaffoldMessenger.of(context);
    final router = GoRouter.of(context);

    final session = sb.auth.currentSession;
    if (session == null) {
      messenger.showSnackBar(
        const SnackBar(content: Text("Connecte-toi d'abord pour commander.")),
      );
      router.push('/login');
      return;
    }

    if (_product == null) {
      messenger.showSnackBar(
        const SnackBar(content: Text("Produit indisponible. Réessaie.")),
      );
      return;
    }

    if (!_formKey.currentState!.validate()) return;

    setState(() => _loading = true);

    try {
      final userId = session.user.id;
      final p = _product!;

      final priceNum = (p['price_amount'] as num?) ?? 0;
      final amount = priceNum.toDouble();

      // 1) Créer la request (status 'new' + total_estimate)
      final req = await sb
          .from('service_requests')
          .insert({
            'business_id': p['business_id'],
            'customer_user_id': userId,
            'type': 'catalog',
            'status': 'new',
            'notes':
                "Commande produit: ${p['title']} | Client: ${_nameCtrl.text.trim()} | Tel: ${_phoneCtrl.text.trim()}",
            'address_text': _addressCtrl.text.trim(),
            'total_estimate': amount,
            'currency': 'XOF',
          })
          .select('id')
          .single();

      final requestId = (req as Map)['id'];

      // 2) Créer l’item (unit_price_snapshot + title_snapshot)
      await sb.from('service_request_items').insert({
        'request_id': requestId,
        'product_id': p['id'],
        'title_snapshot': (p['title'] ?? '').toString(),
        'qty': 1,
        'unit_price_snapshot': amount,
      });

      // 3) Appeler l’Edge Function
      // IMPORTANT: le nom ici = nom du dossier de fonction.
      // Si ton dossier est supabase/functions/create_payment_intent => invoke('create_payment_intent')
      final res = await sb.functions.invoke(
        'create_payment_intent',
        body: {
          'request_id': requestId,
          'provider': 'PAYDUNYA',
          // 'amount': amount, // optionnel (si tu veux forcer)
        },
      );

      final data = res.data;
      final paymentUrl = (data is Map) ? data['payment_url'] : null;

      if (paymentUrl == null || paymentUrl.toString().isEmpty) {
        throw Exception("payment_url absent dans la réponse: $data");
      }

      if (!mounted) return;
      messenger.showSnackBar(
        const SnackBar(content: Text('Redirection vers paiement...')),
      );

      final ok = await launchUrl(
        Uri.parse(paymentUrl.toString()),
        mode: LaunchMode.externalApplication,
      );

      if (!ok) {
        throw Exception("Impossible d'ouvrir l'URL de paiement.");
      }
    } catch (e) {
      if (!mounted) return;
      messenger.showSnackBar(
        SnackBar(content: Text('Erreur: $e')),
      );
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final p = _product;

    if (p == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Commander')),
        body: Center(
          child: _error == null
              ? const CircularProgressIndicator()
              : Padding(
                  padding: const EdgeInsets.all(16),
                  child: Text(_error!, style: const TextStyle(color: Colors.red)),
                ),
        ),
      );
    }

    final title = (p['title'] ?? '').toString();
    final price = (p['price_amount'] ?? '').toString();

    return Scaffold(
      appBar: AppBar(title: Text('Commander $title')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              Text('$price XOF', style: Theme.of(context).textTheme.headlineSmall),
              const SizedBox(height: 12),

              TextFormField(
                controller: _nameCtrl,
                decoration: const InputDecoration(labelText: 'Nom complet'),
                validator: (v) => (v == null || v.trim().isEmpty) ? 'Nom requis' : null,
                textInputAction: TextInputAction.next,
              ),
              TextFormField(
                controller: _phoneCtrl,
                decoration: const InputDecoration(labelText: 'Téléphone'),
                validator: (v) => (v == null || v.trim().isEmpty) ? 'Téléphone requis' : null,
                keyboardType: TextInputType.phone,
                textInputAction: TextInputAction.next,
              ),
              TextFormField(
                controller: _addressCtrl,
                decoration: const InputDecoration(labelText: 'Adresse complète'),
                validator: (v) => (v == null || v.trim().isEmpty) ? 'Adresse requise' : null,
                minLines: 2,
                maxLines: 4,
              ),

              const SizedBox(height: 20),
              ElevatedButton.icon(
                onPressed: _loading ? null : _submit,
                icon: _loading
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.payment),
                label: Text(_loading ? 'Traitement...' : 'Procéder au paiement'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\billing\plans_page.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:url_launcher/url_launcher.dart';

class PlansPage extends StatefulWidget {
  const PlansPage({super.key});
  @override
  State<PlansPage> createState() => _PlansPageState();
}

class _PlansPageState extends State<PlansPage> {
  final sb = Supabase.instance.client;
  List<Map<String, dynamic>> _plans = [];
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadPlans();
  }

  Future<void> _loadPlans() async {
    final rows = await sb.from('plans').select().order('monthly_price_amount', ascending: true);
    setState(() {
      _plans = List<Map<String, dynamic>>.from(rows);
      _loading = false;
    });
  }

  Future<void> _subscribe(String code) async {
    final res = await sb.functions.invoke('billing/subscribe', body: {
      'business_id': sb.auth.currentUser!.id,
      'plan_code': code,
    });
    final url = res.data?['payment_url'];
    if (url != null) await launchUrl(Uri.parse(url));
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) return const Scaffold(body: Center(child: CircularProgressIndicator()));

    return Scaffold(
      appBar: AppBar(title: const Text('Choisir un plan')),
      body: ListView.builder(
        itemCount: _plans.length,
        itemBuilder: (ctx, i) {
          final p = _plans[i];
          return Card(
            margin: const EdgeInsets.all(12),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(p['name'], style: Theme.of(context).textTheme.titleLarge),
                  Text(p['description'] ?? ''),
                  const SizedBox(height: 10),
                  Text('${p['monthly_price_amount'] ?? 0} XOF / mois'),
                  const SizedBox(height: 10),
                  ElevatedButton(
                    onPressed: () => _subscribe(p['code']),
                    child: const Text('Souscrire'),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\supabase\functions\create_payment_intent\providers\paydunya.ts
D:\Dev\PME_TPE\PME_TPE\supabase\functions\billing_subscribe\providers\paydunya.ts


export interface PayDunyaCheckoutParams {
  amount: number;
  description: string;
  reference: string;
  callbackUrl: string;
}

export class PayDunya {
  static async createCheckout(params: PayDunyaCheckoutParams): Promise<string> {
    const apiKey = Deno.env.get("PAYDUNYA_API_KEY");
    const apiSecret = Deno.env.get("PAYDUNYA_API_SECRET");
    const masterKey = Deno.env.get("PAYDUNYA_MASTER_KEY");

    if (!apiKey || !apiSecret || !masterKey) {
      throw new Error("PayDunya env keys missing");
    }

    const payload = {
      invoice: {
        total_amount: params.amount,
        description: params.description,
      },
      store: {
        name: "PME_TPE",
      },
      actions: {
        callback_url: params.callbackUrl,
        return_url: params.callbackUrl,
        cancel_url: params.callbackUrl,
      },
      custom_data: {
        reference: params.reference,
      },
    };

    const res = await fetch("https://app.paydunya.com/api/v1/checkout-invoice/create", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "PAYDUNYA-MASTER-KEY": masterKey,
        "PAYDUNYA-PRIVATE-KEY": apiSecret,
        "PAYDUNYA-PUBLIC-KEY": apiKey,
      },
      body: JSON.stringify(payload),
    });

    const json = await res.json();

    if (!res.ok || !json?.response_code || json.response_code !== "00") {
      throw new Error(`PayDunya error: ${JSON.stringify(json)}`);
    }

    return json.response_text; // URL de paiement
  }
}

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\supabase\functions\create_payment_intent\index.ts

import { serve } from 'https://deno.land/std@0.192.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { PayDunya } from './providers/paydunya.ts'  // ton wrapper local

serve(async (req) => {
  const sb = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  )

  const { request_id, product_id, amount, provider } = await req.json()

  // Vérif basique du user
  const auth = req.headers.get('Authorization')
  const token = auth?.replace('Bearer ', '')
  const { data: user, error: authErr } = await sb.auth.getUser(token)
  if (authErr || !user) return new Response('Unauthorized', { status: 401 })

  // Récupération commande
  const { data: reqRow, error: reqErr } = await sb
    .from('service_requests')
    .select('id, business_id, total_amount, currency')
    .eq('id', request_id)
    .maybeSingle()

  if (reqErr || !reqRow) return new Response('Invalid request', { status: 400 })

  const payAmount = amount ?? reqRow.total_amount

  // Créer un intent local
  const { data: intent, error: iErr } = await sb
    .from('payment_intents')
    .insert({
      business_id: reqRow.business_id,
      amount: payAmount,
      currency: reqRow.currency ?? 'XOF',
      provider,
      status: 'pending',
      created_by: user.user.id,
    })
    .select()
    .single()

  if (iErr) throw iErr

  // Appel provider
  const callbackUrl = `${Deno.env.get('PUBLIC_BASE_URL')}/payments/callback`
  const paymentUrl = await PayDunya.createCheckout({
    amount: payAmount,
    description: 'Commande PME_TPE',
    reference: intent.id,
    callbackUrl,
  })

  // Mise à jour
  await sb.from('payment_intents')
    .update({ external_ref: paymentUrl, status: 'initiated' })
    .eq('id', intent.id)

  return new Response(JSON.stringify({ payment_url: paymentUrl }), {
    headers: { 'Content-Type': 'application/json' },
  })
})

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\supabase\functions\billing_subscribe\index.ts

import { serve } from "https://deno.land/std@0.192.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3"
import { PayDunya } from "../providers/paydunya.ts"

serve(async (req) => {
  const { business_id, plan_code } = await req.json()
  const sb = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!)
  const { data: plan } = await sb.from('plans').select().eq('code', plan_code).single()
  if (!plan) return new Response('Plan inconnu', { status: 400 })

  // Création paiement
  const paymentUrl = await PayDunya.createCheckout({
    amount: plan.monthly_price_amount,
    description: `Abonnement ${plan.name}`,
    reference: crypto.randomUUID(),
    callbackUrl: `${Deno.env.get('PUBLIC_BASE_URL')}/billing/callback`
  })

  await sb.from('subscriptions').insert({
    business_id,
    provider: 'PAYDUNYA',
    status: 'pending',
    provider_customer_id: 'pme_tpe_user',
    provider_subscription_id: plan_code,
  })

  return new Response(JSON.stringify({ payment_url: paymentUrl }), {
    headers: { 'Content-Type': 'application/json' },
  })
})
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\supabase\functions\payments_callback\index.ts

import { serve } from "https://deno.land/std@0.192.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3"

serve(async (req) => {
  const payload = await req.json()
  const sb = createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
  )

  const { custom_data, status } = payload
  const ref = custom_data?.reference

  if (!ref) return new Response("Missing ref", { status: 400 })

  if (status === "completed" || status === "success") {
    await sb.rpc("apply_payment_reference", { ref })
  } else if (status === "failed") {
    await sb.from("payment_intents").update({ status: "failed" }).eq("id", ref)
  }

  return new Response("ok", { status: 200 })
})

=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\cart\cart_service.dart


import 'dart:math';
import 'package:flutter/foundation.dart';

class CartBusinessMismatch implements Exception {
  final String currentBusinessId;
  final String incomingBusinessId;
  CartBusinessMismatch(this.currentBusinessId, this.incomingBusinessId);

  @override
  String toString() =>
      'CartBusinessMismatch(current=$currentBusinessId, incoming=$incomingBusinessId)';
}

@immutable
class CartItem {
  final String productId;
  final String businessId;
  final String title;
  final num unitPrice;
  final String currency;
  final String? mediaUrl;
  final int qty;

  const CartItem({
    required this.productId,
    required this.businessId,
    required this.title,
    required this.unitPrice,
    required this.currency,
    this.mediaUrl,
    required this.qty,
  });

  CartItem copyWith({int? qty}) => CartItem(
        productId: productId,
        businessId: businessId,
        title: title,
        unitPrice: unitPrice,
        currency: currency,
        mediaUrl: mediaUrl,
        qty: qty ?? this.qty,
      );

  num get lineTotal => unitPrice * qty;
}

class CartService extends ChangeNotifier {
  String? _businessId;
  String? _currency;
  final Map<String, CartItem> _itemsByProduct = {};

  String? get businessId => _businessId;
  String get currency => _currency ?? 'XOF';

  List<CartItem> get items => _itemsByProduct.values.toList()
    ..sort((a, b) => a.title.toLowerCase().compareTo(b.title.toLowerCase()));

  int get totalQty => _itemsByProduct.values.fold(0, (s, it) => s + it.qty);
  num get subtotal => _itemsByProduct.values.fold<num>(0, (s, it) => s + it.lineTotal);

  bool get isEmpty => _itemsByProduct.isEmpty;

  void clear() {
    _businessId = null;
    _currency = null;
    _itemsByProduct.clear();
    notifyListeners();
  }

  void add({
    required String productId,
    required String businessId,
    required String title,
    required num unitPrice,
    required String currency,
    String? mediaUrl,
    int qty = 1,
  }) {
    if (_businessId != null && _businessId != businessId) {
      throw CartBusinessMismatch(_businessId!, businessId);
    }

    _businessId ??= businessId;
    _currency ??= currency;

    final existing = _itemsByProduct[productId];
    if (existing == null) {
      _itemsByProduct[productId] = CartItem(
        productId: productId,
        businessId: businessId,
        title: title,
        unitPrice: unitPrice,
        currency: currency,
        mediaUrl: mediaUrl,
        qty: max(1, qty),
      );
    } else {
      _itemsByProduct[productId] = existing.copyWith(qty: existing.qty + max(1, qty));
    }
    notifyListeners();
  }

  void setQty(String productId, int qty) {
    final existing = _itemsByProduct[productId];
    if (existing == null) return;

    if (qty <= 0) {
      _itemsByProduct.remove(productId);
      if (_itemsByProduct.isEmpty) {
        _businessId = null;
        _currency = null;
      }
    } else {
      _itemsByProduct[productId] = existing.copyWith(qty: qty);
    }
    notifyListeners();
  }

  void inc(String productId) {
    final existing = _itemsByProduct[productId];
    if (existing == null) return;
    setQty(productId, existing.qty + 1);
  }

  void dec(String productId) {
    final existing = _itemsByProduct[productId];
    if (existing == null) return;
    setQty(productId, existing.qty - 1);
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\cart\cart_scope.dart

import 'package:flutter/widgets.dart';
import 'cart_service.dart';

class CartScope extends InheritedNotifier<CartService> {
  const CartScope({
    super.key,
    required CartService cart,
    required Widget child,
  }) : super(notifier: cart, child: child);

  static CartService of(BuildContext context) {
    final scope = context.dependOnInheritedWidgetOfExactType<CartScope>();
    assert(scope != null, 'CartScope not found. Wrap MaterialApp with CartScope.');
    return scope!.notifier!;
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\cart\cart_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'cart_scope.dart';

class CartPage extends StatelessWidget {
  const CartPage({super.key});

  @override
  Widget build(BuildContext context) {
    final cart = CartScope.of(context);

    return Scaffold(
      appBar: AppBar(title: const Text('Panier')),
      body: AnimatedBuilder(
        animation: cart,
        builder: (context, child) {
          if (cart.isEmpty) {
            return const Center(child: Text('Votre panier est vide.'));
          }

          return Column(
            children: [
              Expanded(
                child: ListView.separated(
                  padding: const EdgeInsets.all(12),
                  itemCount: cart.items.length,
                  separatorBuilder: (context, index) => const SizedBox(height: 8),
                  itemBuilder: (context, i) {
                    final it = cart.items[i];
                    return Card(
                      child: ListTile(
                        title: Text(it.title),
                        subtitle: Text('${it.unitPrice} ${it.currency}  •  x${it.qty}'),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            IconButton(
                              onPressed: () => cart.dec(it.productId),
                              icon: const Icon(Icons.remove_circle_outline),
                            ),
                            Text('${it.qty}'),
                            IconButton(
                              onPressed: () => cart.inc(it.productId),
                              icon: const Icon(Icons.add_circle_outline),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ),
              SafeArea(
                top: false,
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: Column(
                    children: [
                      Row(
                        children: [
                          const Text('Total', style: TextStyle(fontWeight: FontWeight.w600)),
                          const Spacer(),
                          Text(
                            '${cart.subtotal} ${cart.currency}',
                            style: const TextStyle(fontWeight: FontWeight.w700),
                          ),
                        ],
                      ),
                      const SizedBox(height: 10),
                      Row(
                        children: [
                          Expanded(
                            child: OutlinedButton(
                              onPressed: cart.clear,
                              child: const Text('Vider'),
                            ),
                          ),
                          const SizedBox(width: 10),
                          Expanded(
                            child: ElevatedButton.icon(
                              onPressed: () => context.push('/checkout'),
                              icon: const Icon(Icons.payment),
                              label: const Text('Payer'),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}
=============================================================================================
D:\Dev\PME_TPE\PME_TPE\lib\features\cart\checkout_page.dart

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:url_launcher/url_launcher.dart';

import 'cart_scope.dart';

class CheckoutPage extends StatefulWidget {
  const CheckoutPage({super.key});

  @override
  State<CheckoutPage> createState() => _CheckoutPageState();
}

class _CheckoutPageState extends State<CheckoutPage> {
  final sb = Supabase.instance.client;
  final _formKey = GlobalKey<FormState>();

  final _nameCtrl = TextEditingController();
  final _phoneCtrl = TextEditingController();
  final _addressCtrl = TextEditingController();

  bool _loading = false;

  @override
  void dispose() {
    _nameCtrl.dispose();
    _phoneCtrl.dispose();
    _addressCtrl.dispose();
    super.dispose();
  }

  void _redirectToLogin(GoRouter router) {
    // Conserve l’historique: push, pas go
    router.push('/login?next=/checkout');
  }

  Future<void> _pay() async {
    // CAPTURE AVANT async gaps => pas de use_build_context_synchronously
    final messenger = ScaffoldMessenger.of(context);
    final router = GoRouter.of(context);

    final cart = CartScope.of(context);

    if (cart.isEmpty) {
      messenger.showSnackBar(const SnackBar(content: Text('Panier vide.')));
      return;
    }

    if (!_formKey.currentState!.validate()) return;

    final user = sb.auth.currentUser;
    if (user == null) {
      messenger.showSnackBar(const SnackBar(content: Text("Connecte-toi d'abord pour payer.")));
      _redirectToLogin(router);
      return;
    }

    setState(() => _loading = true);

    try {
      final businessId = cart.businessId!;
      final total = cart.subtotal;

      // 1) Créer service_request
      final reqRow = await sb.from('service_requests').insert({
        'business_id': businessId,
        'customer_user_id': user.id,
        'type': 'catalog',
        'status': 'new',
        'total_estimate': total,
        'currency': cart.currency,
        'address_text': _addressCtrl.text.trim(),
        'notes':
            'Commande depuis mini-site • Nom=${_nameCtrl.text.trim()} • Tel=${_phoneCtrl.text.trim()}',
      }).select('id').single();

      final requestId = reqRow['id'] as String;

      // 2) Créer service_request_items
      final itemsPayload = cart.items.map((it) {
        return {
          'request_id': requestId,
          'product_id': it.productId.split('::').first,
          'title_snapshot': it.title,
          'qty': it.qty,
          'unit_price_snapshot': it.unitPrice,
        };
      }).toList();

      await sb.from('service_request_items').insert(itemsPayload);

      // 3) Appeler Edge Function paiement (nom = dossier de la function)
      final res = await sb.functions.invoke(
        'create_payment_intent',
        body: {
          'request_id': requestId,
          'provider': 'PAYDUNYA',
          // 'amount': total, // optionnel (ta function accepte amount)
        },
      );

      final data = res.data;
      final url = (data is Map) ? (data['payment_url'] as String?) : null;
      if (url == null || url.isEmpty) {
        throw Exception('Aucune URL de paiement retournée.');
      }

      messenger.showSnackBar(const SnackBar(content: Text('Redirection vers paiement...')));

      final ok = await launchUrl(
        Uri.parse(url),
        mode: LaunchMode.externalApplication,
      );
      if (!ok) {
        throw Exception("Impossible d'ouvrir l'URL de paiement.");
      }

      cart.clear();

      if (!mounted) return;
      router.pop(); // retour panier
    } on PostgrestException catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Erreur commande: ${e.message}')));
    } catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Erreur: $e')));
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final cart = CartScope.of(context);

    return Scaffold(
      appBar: AppBar(title: const Text('Finaliser la commande')),
      body: AnimatedBuilder(
        animation: cart,
        builder: (context, child) {
          return Padding(
            padding: const EdgeInsets.all(16),
            child: Form(
              key: _formKey,
              child: ListView(
                children: [
                  Text(
                    'Total: ${cart.subtotal} ${cart.currency}',
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _nameCtrl,
                    decoration: const InputDecoration(labelText: 'Nom complet'),
                    validator: (v) => (v == null || v.trim().isEmpty) ? 'Nom requis' : null,
                  ),
                  const SizedBox(height: 10),
                  TextFormField(
                    controller: _phoneCtrl,
                    decoration: const InputDecoration(labelText: 'Téléphone'),
                    keyboardType: TextInputType.phone,
                    validator: (v) => (v == null || v.trim().isEmpty) ? 'Téléphone requis' : null,
                  ),
                  const SizedBox(height: 10),
                  TextFormField(
                    controller: _addressCtrl,
                    decoration: const InputDecoration(labelText: 'Adresse complète'),
                    maxLines: 2,
                    validator: (v) => (v == null || v.trim().isEmpty) ? 'Adresse requise' : null,
                  ),
                  const SizedBox(height: 18),
                  ElevatedButton.icon(
                    onPressed: _loading ? null : _pay,
                    icon: _loading
                        ? const SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Icon(Icons.payment),
                    label: Text(_loading ? 'Traitement...' : 'Procéder au paiement'),
                  ),
                  const SizedBox(height: 10),
                  Text(
                    "Note: si la boutique n'a pas l'autorisation de recevoir des commandes (entitlements), la création de commande peut être bloquée par RLS.",
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}

=============================================================================================

D:\Dev\PME_TPE\PME_TPE\lib\core\route_observer.dart

import 'package:flutter/material.dart';

final RouteObserver<PageRoute<dynamic>> routeObserver =
    RouteObserver<PageRoute<dynamic>>();

=============================================================================================

D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_members_page.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessMembersPage extends StatefulWidget {
  final String businessId;
  const BusinessMembersPage({super.key, required this.businessId});

  @override
  State<BusinessMembersPage> createState() => _BusinessMembersPageState();
}

class _BusinessMembersPageState extends State<BusinessMembersPage> {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  bool _busy = false;
  String? _error;

  String _myRole = 'staff';
  String _query = '';

  final List<_MemberVm> _members = [];

  bool get _isAdmin => _myRole == 'owner' || _myRole == 'admin';

  @override
  void initState() {
    super.initState();
    _load();
  }

  // -----------------------------
  // Helpers
  // -----------------------------

  String _roleLabel(String r) {
    switch (r) {
      case 'owner':
        return 'Owner';
      case 'admin':
        return 'Admin';
      default:
        return 'Staff';
    }
  }

  String _safeErr(Object e) {
    if (e is PostgrestException) return e.message;
    if (e is AuthException) return e.message;
    if (e is StorageException) return e.message;
    return e.toString();
  }

  bool _isValidEmail(String s) {
    final v = s.trim();
    if (v.isEmpty) return false;
    final re = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
    return re.hasMatch(v);
  }

  static String _shortUserId(String id) {
    if (id.length <= 8) return id;
    return '${id.substring(0, 4)}…${id.substring(id.length - 4)}';
  }

  static String _fmtDate(String? iso) {
    if (iso == null || iso.trim().isEmpty) return '—';
    final dt = DateTime.tryParse(iso);
    if (dt == null) return '—';
    String two(int n) => n.toString().padLeft(2, '0');
    return '${dt.year}-${two(dt.month)}-${two(dt.day)} ${two(dt.hour)}:${two(dt.minute)}';
  }

  // -----------------------------
  // Load
  // -----------------------------

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
      _members.clear();
    });

    try {
      final uid = _sb.auth.currentUser?.id;
      if (uid == null) throw Exception('Session manquante.');

      // 1) Mon rôle
      final me = await _sb
          .from('business_members')
          .select('role')
          .eq('business_id', widget.businessId)
          .eq('user_id', uid)
          .maybeSingle();

      _myRole = (me?['role'] ?? 'staff').toString();

      // 2) Membres + profils : on tente d'abord le join PostgREST,
      // puis fallback si la relation n'est pas détectée/cachée.
      List<Map<String, dynamic>> rows;
      try {
        final resp = await _sb
            .from('business_members')
            .select('user_id, role, created_at, profiles(full_name, display_name, email, photo_url)')
            .eq('business_id', widget.businessId)
            .order('created_at', ascending: true);

        rows = (resp as List)
            .map((e) => Map<String, dynamic>.from(e as Map))
            .toList();
      } on PostgrestException {
        final resp = await _sb
            .from('business_members')
            .select('user_id, role, created_at')
            .eq('business_id', widget.businessId)
            .order('created_at', ascending: true);

        final base = (resp as List)
            .map((e) => Map<String, dynamic>.from(e as Map))
            .toList();

        final userIds = base
            .map((m) => (m['user_id'] ?? '').toString())
            .where((x) => x.isNotEmpty)
            .toSet()
            .toList();

        Map<String, Map<String, dynamic>> profByUid = {};
        if (userIds.isNotEmpty) {
          // NOTE: construit une clause in('id1','id2'...)
          final inClause = '(${userIds.map((id) => "'$id'").join(',')})';

          final profResp = await _sb
              .from('profiles')
              .select('user_id, full_name, display_name, email, photo_url')
              .filter('user_id', 'in', inClause);

          final profList = (profResp as List)
              .map((e) => Map<String, dynamic>.from(e as Map))
              .toList();

          profByUid = {
            for (final p in profList) (p['user_id'] ?? '').toString(): p,
          };
        }

        rows = base.map((m) {
          final id = (m['user_id'] ?? '').toString();
          return {
            ...m,
            'profiles': profByUid[id],
          };
        }).toList();
      }

      final vms = rows.map((m) {
        final userId = (m['user_id'] ?? '').toString();
        final role = (m['role'] ?? 'staff').toString();
        final createdAt = m['created_at']?.toString();

        Map<String, dynamic>? prof;
        final raw = m['profiles'];
        if (raw is Map) prof = Map<String, dynamic>.from(raw);

        final fullName = (prof?['full_name'] ?? '').toString().trim();
        final displayName = (prof?['display_name'] ?? '').toString().trim();
        final email = (prof?['email'] ?? '').toString().trim();
        final photoUrl = (prof?['photo_url'] ?? '').toString().trim();

        final name = fullName.isNotEmpty
            ? fullName
            : (displayName.isNotEmpty
                ? displayName
                : (email.isNotEmpty ? email.split('@').first : _shortUserId(userId)));

        return _MemberVm(
          userId: userId,
          role: role,
          name: name,
          email: email.isNotEmpty ? email : '—',
          photoUrl: photoUrl.isNotEmpty ? photoUrl : null,
          createdAtIso: createdAt,
          isMe: userId == uid,
        );
      }).toList();

      if (!mounted) return;
      setState(() => _members.addAll(vms));
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = _safeErr(e));
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  // -----------------------------
  // Actions
  // -----------------------------

  Future<void> _addMemberFlow() async {
    if (!_isAdmin || _busy || _loading) return;

    final input = await showModalBottomSheet<_MemberInput>(
      context: context,
      isScrollControlled: true,
      useSafeArea: true,
      showDragHandle: true,
      builder: (_) => const _AddMemberSheet(),
    );

    if (input == null) return;

    // on ferme le clavier/focus proprement
    FocusManager.instance.primaryFocus?.unfocus();

    if (!_isValidEmail(input.email)) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Email invalide.')),
      );
      return;
    }

    setState(() => _busy = true);
    try {
      await _sb.rpc('add_business_member_by_email', params: {
        'bid': widget.businessId,
        'member_email': input.email.trim(),
        'new_role': input.role, // string: 'staff'|'admin' (cast enum côté PG)
      });

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Membre ajouté : ${input.email}')),
      );

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: ${_safeErr(e)}')),
      );
    } finally {
      if (!mounted) return;
      setState(() => _busy = false);
    }
  }

  Future<void> _changeRoleFlow(_MemberVm m) async {
    if (!_isAdmin || _busy || _loading) return;
    if (m.role == 'owner' || m.isMe) return;

    final newRole = await showModalBottomSheet<String>(
      context: context,
      isScrollControlled: true,
      useSafeArea: true,
      showDragHandle: true,
      builder: (_) => _ChangeRoleSheet(currentRole: m.role),
    );

    if (newRole == null || newRole == m.role) return;

    FocusManager.instance.primaryFocus?.unfocus();

    setState(() => _busy = true);
    try {
      await _sb.rpc('update_business_member_role', params: {
        'bid': widget.businessId,
        'member_user_id': m.userId,
        'new_role': newRole, // cast enum côté PG
      });

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Rôle mis à jour: ${m.name} → ${_roleLabel(newRole)}')),
      );

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: ${_safeErr(e)}')),
      );
    } finally {
      if (!mounted) return;
      setState(() => _busy = false);
    }
  }

  Future<void> _removeMemberFlow(_MemberVm m) async {
    if (!_isAdmin || _busy || _loading) return;

    if (m.role == 'owner') return;
    if (m.isMe) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Tu ne peux pas te retirer toi-même.')),
      );
      return;
    }

    final ok = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('Retirer ${m.name} ?'),
        content: const Text('Il perdra l’accès à cette entreprise.'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Annuler')),
          FilledButton(onPressed: () => Navigator.of(ctx).pop(true), child: const Text('Retirer')),
        ],
      ),
    );

    if (ok != true) return;

    setState(() => _busy = true);
    try {
      await _sb.rpc('remove_business_member', params: {
        'bid': widget.businessId,
        'member_user_id': m.userId,
      });

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Membre retiré: ${m.name}')),
      );

      await _load();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: ${_safeErr(e)}')),
      );
    } finally {
      if (!mounted) return;
      setState(() => _busy = false);
    }
  }

  // -----------------------------
  // UI
  // -----------------------------

  @override
  Widget build(BuildContext context) {
    final q = _query.trim().toLowerCase();
    final filtered = _members.where((m) {
      if (q.isEmpty) return true;
      return m.name.toLowerCase().contains(q) || m.email.toLowerCase().contains(q);
    }).toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Membres'),
        actions: [
          IconButton(
            onPressed: _loading ? null : _load,
            tooltip: 'Rafraîchir',
            icon: const Icon(Icons.refresh),
          ),
          if (_isAdmin)
            Padding(
              padding: const EdgeInsets.only(right: 8),
              child: FilledButton.icon(
                onPressed: (_busy || _loading) ? null : _addMemberFlow,
                icon: const Icon(Icons.person_add_alt_1),
                label: const Text('Ajouter'),
              ),
            ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : (_error != null)
              ? _ErrorView(message: _error!, onRetry: _load)
              : RefreshIndicator(
                  onRefresh: _load,
                  child: ListView(
                    padding: const EdgeInsets.all(12),
                    children: [
                      _TopCard(
                        myRole: _roleLabel(_myRole),
                        total: _members.length,
                        adminMode: _isAdmin,
                        busy: _busy,
                      ),
                      const SizedBox(height: 12),
                      TextField(
                        decoration: const InputDecoration(
                          prefixIcon: Icon(Icons.search),
                          hintText: 'Rechercher par nom ou email…',
                        ),
                        onChanged: (v) => setState(() => _query = v),
                      ),
                      const SizedBox(height: 12),
                      if (filtered.isEmpty)
                        const Padding(
                          padding: EdgeInsets.only(top: 28),
                          child: Center(child: Text('Aucun membre trouvé.')),
                        )
                      else
                        ...filtered.map((m) {
                          final canEdit = _isAdmin && m.role != 'owner' && !m.isMe;

                          return Card(
                            margin: const EdgeInsets.only(bottom: 10),
                            child: ListTile(
                              leading: CircleAvatar(
                                backgroundImage: (m.photoUrl != null) ? NetworkImage(m.photoUrl!) : null,
                                child: (m.photoUrl != null)
                                    ? null
                                    : Text(
                                        m.initial,
                                        style: const TextStyle(fontWeight: FontWeight.w800),
                                      ),
                              ),
                              title: Row(
                                children: [
                                  Expanded(
                                    child: Text(
                                      m.name,
                                      maxLines: 1,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  _RolePill(role: m.role, isMe: m.isMe),
                                ],
                              ),
                              subtitle: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    m.email,
                                    maxLines: 1,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  const SizedBox(height: 2),
                                  Text('Ajouté: ${_fmtDate(m.createdAtIso)}'),
                                ],
                              ),
                              isThreeLine: true,
                              trailing: canEdit
                                  ? PopupMenuButton<String>(
                                      onSelected: (v) {
                                        if (v == 'role') _changeRoleFlow(m);
                                        if (v == 'remove') _removeMemberFlow(m);
                                      },
                                      itemBuilder: (_) => const [
                                        PopupMenuItem(value: 'role', child: Text('Changer rôle')),
                                        PopupMenuItem(value: 'remove', child: Text('Retirer')),
                                      ],
                                    )
                                  : null,
                            ),
                          );
                        }),
                      const SizedBox(height: 20),
                    ],
                  ),
                ),
    );
  }
}

class _MemberVm {
  final String userId;
  final String role;
  final String name;
  final String email;
  final String? photoUrl;
  final String? createdAtIso;
  final bool isMe;

  _MemberVm({
    required this.userId,
    required this.role,
    required this.name,
    required this.email,
    required this.photoUrl,
    required this.createdAtIso,
    required this.isMe,
  });

  String get initial {
    final t = name.trim();
    if (t.isEmpty || t == '—') return '?';
    final rune = t.runes.isEmpty ? null : t.runes.first;
    if (rune == null) return '?';
    return String.fromCharCode(rune).toUpperCase();
  }
}

class _TopCard extends StatelessWidget {
  final String myRole;
  final int total;
  final bool adminMode;
  final bool busy;

  const _TopCard({
    required this.myRole,
    required this.total,
    required this.adminMode,
    required this.busy,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Total membres: $total', style: const TextStyle(fontWeight: FontWeight.w800)),
                  const SizedBox(height: 6),
                  Text('Mon rôle: $myRole'),
                  const SizedBox(height: 6),
                  Text(adminMode ? 'Mode admin: ON' : 'Mode admin: OFF'),
                ],
              ),
            ),
            if (busy)
              const SizedBox(
                width: 18,
                height: 18,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
          ],
        ),
      ),
    );
  }
}

class _RolePill extends StatelessWidget {
  final String role;
  final bool isMe;

  const _RolePill({required this.role, required this.isMe});

  String _label() {
    switch (role) {
      case 'owner':
        return 'OWNER';
      case 'admin':
        return 'ADMIN';
      default:
        return 'STAFF';
    }
  }

  @override
  Widget build(BuildContext context) {
    final text = isMe ? '${_label()} • MOI' : _label();
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(999),
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
      ),
      child: Text(text, style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w800)),
    );
  }
}

class _ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;
  const _ErrorView({required this.message, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 700),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(message, style: const TextStyle(color: Colors.red)),
              const SizedBox(height: 10),
              FilledButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Réessayer'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// -----------------------------
// Bottom sheets (sans Dropdown overlay)
// -----------------------------

class _MemberInput {
  final String email;
  final String role; // 'staff' or 'admin'
  const _MemberInput({required this.email, required this.role});
}

class _AddMemberSheet extends StatefulWidget {
  const _AddMemberSheet();

  @override
  State<_AddMemberSheet> createState() => _AddMemberSheetState();
}

class _AddMemberSheetState extends State<_AddMemberSheet> {
  final _emailCtrl = TextEditingController();
  String _role = 'staff';
  String? _err;

  bool _isValidEmail(String s) {
    final v = s.trim();
    if (v.isEmpty) return false;
    final re = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
    return re.hasMatch(v);
  }

  @override
  void dispose() {
    _emailCtrl.dispose();
    super.dispose();
  }

  void _submit() {
    final email = _emailCtrl.text.trim();
    if (!_isValidEmail(email)) {
      setState(() => _err = 'Email invalide.');
      return;
    }
    FocusManager.instance.primaryFocus?.unfocus();
    Navigator.of(context).pop(_MemberInput(email: email, role: _role));
  }

  @override
  Widget build(BuildContext context) {
    final bottom = MediaQuery.of(context).viewInsets.bottom;

    return Padding(
      padding: EdgeInsets.only(left: 16, right: 16, bottom: bottom + 16, top: 8),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Ajouter un membre', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w800)),
          const SizedBox(height: 12),
          TextField(
            controller: _emailCtrl,
            keyboardType: TextInputType.emailAddress,
            decoration: InputDecoration(
              labelText: 'Email du membre',
              hintText: 'ex: nom@gmail.com',
              errorText: _err,
            ),
            onChanged: (_) {
              if (_err != null) setState(() => _err = null);
            },
            onSubmitted: (_) => _submit(),
          ),
          const SizedBox(height: 12),
          const Text('Rôle', style: TextStyle(fontWeight: FontWeight.w700)),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              ChoiceChip(
                label: const Text('Staff'),
                selected: _role == 'staff',
                onSelected: (_) => setState(() => _role = 'staff'),
              ),
              ChoiceChip(
                label: const Text('Admin'),
                selected: _role == 'admin',
                onSelected: (_) => setState(() => _role = 'admin'),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => Navigator.of(context).pop(null),
                  child: const Text('Annuler'),
                ),
              ),
              const SizedBox(width: 10),
              Expanded(
                child: FilledButton(
                  onPressed: _submit,
                  child: const Text('Enregistrer'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _ChangeRoleSheet extends StatefulWidget {
  final String currentRole;
  const _ChangeRoleSheet({required this.currentRole});

  @override
  State<_ChangeRoleSheet> createState() => _ChangeRoleSheetState();
}

class _ChangeRoleSheetState extends State<_ChangeRoleSheet> {
  late String _role;

  @override
  void initState() {
    super.initState();
    _role = widget.currentRole;
  }

  @override
  Widget build(BuildContext context) {
    final bottom = MediaQuery.of(context).viewInsets.bottom;

    return Padding(
      padding: EdgeInsets.only(left: 16, right: 16, bottom: bottom + 16, top: 8),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Changer le rôle', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w800)),
          const SizedBox(height: 12),
          const Text('Sélection', style: TextStyle(fontWeight: FontWeight.w700)),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            children: [
              ChoiceChip(
                label: const Text('Staff'),
                selected: _role == 'staff',
                onSelected: (_) => setState(() => _role = 'staff'),
              ),
              ChoiceChip(
                label: const Text('Admin'),
                selected: _role == 'admin',
                onSelected: (_) => setState(() => _role = 'admin'),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => Navigator.of(context).pop(null),
                  child: const Text('Annuler'),
                ),
              ),
              const SizedBox(width: 10),
              Expanded(
                child: FilledButton(
                  onPressed: () {
                    FocusManager.instance.primaryFocus?.unfocus();
                    Navigator.of(context).pop(_role);
                  },
                  child: const Text('Enregistrer'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

=============================================================================================

D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_billing_page.dart

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class BusinessBillingPage extends StatefulWidget {
  final String businessId;
  const BusinessBillingPage({super.key, required this.businessId});

  @override
  State<BusinessBillingPage> createState() => _BusinessBillingPageState();
}

class _BusinessBillingPageState extends State<BusinessBillingPage> {
  final _sb = Supabase.instance.client;

  bool _loading = true;
  String? _error;
  Map<String, dynamic>? _ent;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final ent = await _sb
          .from('entitlements')
          .select('can_receive_orders, can_run_ads, visibility_multiplier, plans:plans(code,name)')
          .eq('business_id', widget.businessId)
          .single();

      _ent = Map<String, dynamic>.from(ent as Map);
    } catch (e) {
      _error = e.toString();
    } finally {
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final planCode = _ent?['plans']?['code']?.toString() ?? 'free';
    final planName = _ent?['plans']?['name']?.toString() ?? 'Free';
    final canOrders = _ent?['can_receive_orders'] == true;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Monétisation'),
        actions: [
          IconButton(onPressed: _load, tooltip: 'Rafraîchir', icon: const Icon(Icons.refresh)),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : (_error != null)
              ? Center(child: Padding(padding: const EdgeInsets.all(16), child: Text(_error!, style: const TextStyle(color: Colors.red))))
              : Padding(
                  padding: const EdgeInsets.all(16),
                  child: ListView(
                    children: [
                      Card(
                        child: ListTile(
                          leading: const Icon(Icons.workspace_premium),
                          title: Text('Plan actuel: $planName'),
                          subtitle: Text('Code: $planCode'),
                        ),
                      ),
                      const SizedBox(height: 12),
                      Card(
                        child: ListTile(
                          leading: Icon(canOrders ? Icons.check_circle : Icons.lock),
                          title: const Text('Réception des commandes'),
                          subtitle: Text(canOrders ? 'Activée' : 'Désactivée (plan requis)'),
                        ),
                      ),
                      const SizedBox(height: 12),

                      const Text(
                        'Étape suivante (pro)',
                        style: TextStyle(fontWeight: FontWeight.w900),
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        "Ici on branchera le paiement d’abonnement (Stripe / Mobile Money) + la mise à jour des entitlements côté serveur.",
                      ),
                      const SizedBox(height: 14),
                      FilledButton.icon(
                        onPressed: () {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('Paiement abonnement: étape suivante')),
                          );
                        },
                        icon: const Icon(Icons.payments),
                        label: const Text('Activer via paiement (à implémenter)'),
                      ),
                    ],
                  ),
                ),
    );
  }
}

=============================================================================================

D:\Dev\PME_TPE\PME_TPE\lib\features\business\business_ads_page.dart

import 'package:flutter/material.dart';

class BusinessAdsPage extends StatelessWidget {
  final String businessId;
  const BusinessAdsPage({super.key, required this.businessId});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Publicités')),
      body: const Center(
        child: Padding(
          padding: EdgeInsets.all(16),
          child: Text(
            'Ads: page prête côté UI.\nÉtape suivante: créer campagnes + ciblage + stats.',
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}

=============================================================================================

=============================================================================================
=============================================================================================
=============================================================================================
=============================================================================================
=============================================================================================
=============================================================================================
=============================================================================================
=============================================================================================
